package model.mindmap.evaluation;

import java.io.File;
import java.util.List;
import java.util.Map;

//import javax.xml.parsers.DocumentBuilder;
//import javax.xml.parsers.DocumentBuilderFactory;
//
//import org.w3c.dom.Document;
//import org.w3c.dom.Element;
//import org.w3c.dom.Node;
//import org.w3c.dom.NodeList;

import model.mindmap.basics.TreeNode;
//import evaluation.enums.MetaDataState;
//import evaluation.enums.Modus;
import model.mindmap.parser.AbstractEvaluationParser;
import model.mindmap.parser.AbstractParser;
import model.mindmap.parser.ParserFactory;

public class Evaluation {
  
  private Evaluation() {
    
  }
  
  /**
   * Takes a mindmap in .xml or .xmmap file format and creates a latex .tex TOC
   * file based on the input file.
   *
   * @see {@link #createTOC(String, String, String, String, String)}}
   *
   * @param readPath
   *          input file path
   * @param writePath
   *          output file path
   * @param templatePath
   *          template path
   */
  public static void craeteTOCMMtoLatex(String readPath, String writePath, String templatePath) {
    createTOC("MINDMANAGER", "LATEX", readPath, writePath, templatePath);
  }
  
  /**
   * Takes a mindmap in .xml or .xmmap file format and creates a word .docx TOC
   * file based on the input file.
   *
   * @see {@link #createTOC(String, String, String, String, String)}}
   *
   * @param readPath
   *          input file path
   * @param writePath
   *          output file path
   * @param templatePath
   *          template path
   */
  public static void craeteTOCMMtoWord(String readPath, String writePath, String templatePath) {
    createTOC("MINDMANAGER", "WORD", readPath, writePath, templatePath);
  }
  
  /**
   * This method creates a table of content file in the specified file format
   * based on the input file and template file.
   *
   * @param readParser
   *          input file format
   * @param writeParser
   *          output file format
   * @param readPath
   *          input file path
   * @param writePath
   *          output file path
   * @param templatePath
   *          template path
   */
  public static void createTOC(String readParser, String writeParser, String readPath, String writePath,
      String templatePath) {
    try {
      AbstractParser r = ParserFactory.getTOCParser(readParser);
      List<TreeNode> listOfRoots = r.read(new File(readPath));
      listOfRoots = Util.mergeTrees(listOfRoots);
      AbstractParser w = ParserFactory.getTOCParser(writeParser);
      w.write(writePath, listOfRoots, templatePath);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
  
  /**
   * This method performs the evaluation of a mindmap from a user in comparison
   * to a solution mindmap. In order to do this, several parameters are needed.
   * At first a specific parser must be chosen (currently only MindManager is
   * supported). The path to the user generated file (input) is needed as well
   * as the path to the sample solution. Further paths to the used template and
   * the meta file are needed. The template defines the look of the altered
   * solution/input files. This method also creates three new files. Two of them
   * are altered versions of the input/solution mindmaps and the third is an
   * overview of the evaluation results. The input and solution mindmaps must be
   * XML or XMMAP. It is critical that the chosen parser type and the template
   * fit together.
   *
   * @param parserType
   *          specifies the parser which will be used (currently only
   *          MindManager is supported)
   * @param input
   *          the path to the mindmap generated by the user
   * @param solution
   *          the path to the mindmap which represents the perfect solution
   * @param result
   *          the path where the result overview will be generated
   * @param alteredSolution
   *          the path where the altered solution will be generated
   * @param alteredInput
   *          the path where the altered input will be generated
   * @param metaData
   *          the path where the meta file is
   * @param template
   *          the path where the template file is
   * @throws Exception
   */
  public static void evaluate(String parserType, String input, String solution, String result, String alteredSolution,
      String alteredInput, String metaData, String template) throws Exception {
    RWExcel rwe = new RWExcel();
    AbstractEvaluationParser abstractEvaluationParser = ParserFactory.getEvaluationParser(parserType);
    List<TreeNode> inputRoots = abstractEvaluationParser.read(new File(input));
    List<TreeNode> solutionRoots = abstractEvaluationParser.read(new File(solution));
    // this must be called before handleMetaData()... //else there might be
    // redundant 'yes' in the meta file.
    Util.applyMetaDataFromSolutionToInput(solutionRoots, inputRoots);
    Properties properties = rwe.readMetaFile(metaData, solutionRoots);
    abstractEvaluationParser.setProperties(properties);
    // ...and after. //this is a must
    Util.applyMetaDataFromSolutionToInput(solutionRoots, inputRoots);
    Map<String, List<Tuple>> mapInput = Util.buildTuples(inputRoots);
    Map<String, List<Tuple>> mapSolutions = Util.buildTuples(solutionRoots);
    TupelDifferenceContainer resultDifferences = Util.getDifferenceTupel(mapSolutions, mapInput);
    Util.applyResultToNodes(solutionRoots, resultDifferences);
    Util.applyResultToNodes(inputRoots, resultDifferences);
    Util.checkIfFeedbackPossible(solutionRoots, inputRoots);
    Util.setRealPoints(solutionRoots);
    Util.setRealPoints(inputRoots);
    rwe.writeEvaluation(result, inputRoots, solutionRoots);
    abstractEvaluationParser.setPathsForAlteredOutputs(result, metaData, alteredInput, alteredSolution);
    abstractEvaluationParser.write(alteredInput, inputRoots, template);
    abstractEvaluationParser.write(alteredSolution, solutionRoots, template);
  }
}
