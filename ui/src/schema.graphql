# source: http://localhost:9000/api/graphql
# timestamp: Fri Mar 27 2020 15:04:02 GMT+0100 (Mitteleurop√§ische Normalzeit)

type Collection {
  id: Int!
  title: String!
  authors: [String!]!
  text: String!
  shortName: String!
  exerciseCount: Int!
  exercises: [Exercise!]!
  exercise(exId: Int!): Exercise
}

union ExContent = ProgExerciseContent | RegexExerciseContent | RoseExerciseContent | SqlExerciseContent | UmlExerciseContent | WebExerciseContent | XmlExerciseContent

type Exercise {
  id: Int!
  collectionId: Int!
  toolId: String!
  semanticVersion: SemanticVersion!
  title: String!
  authors: [String!]!
  text: String!
  tags: [ExTag!]!
  difficulty: Int
}

type ExerciseFile {
  name: String!
  resourcePath: String!
  fileType: String!
  editable: Boolean!
  content: String!
}

input ExerciseFileInput {
  name: String!
  resourcePath: String!
  fileType: String!
  editable: Boolean!
  content: String!
}

type ExTag {
  abbreviation: String!
  title: String!
}

type HtmlTask {
  text: String!
}

type ImplementationPart {
  base: String!
  files: [ExerciseFile!]!
  implFileName: String!
  sampleSolFileNames: [String!]!
}

type KeyValueObject {
  key: String!
  value: String!
}

type Lesson {
  id: Int!
  toolId: String!
  title: String!
  description: String!
}

type Mutation {
  correctProgramming(collId: Int!, exId: Int!, solution: ProgSolutionInput!): Int
  correctRegex(collId: Int!, exId: Int!, solution: String!): Int
  correctRose(collId: Int!, exId: Int!, solution: String!): Int
  correctSql(collId: Int!, exId: Int!, solution: String!): Int
  correctUml(collId: Int!, exId: Int!, solution: UmlClassDiagramInput!): Int
  correctWeb(collId: Int!, exId: Int!, solution: [ExerciseFileInput!]!): Int
  correctXml(collId: Int!, exId: Int!, solution: XmlSolutionInput!): Int
}

type ProgExerciseContent {
  functionName: String!
  foldername: String!
  filename: String!
  unitTestPart: UnitTestPart!
  implementationPart: ImplementationPart!
  sampleSolutions: [ProgSampleSolution!]!
}

type ProgSampleSolution {
  id: Int!
  sample: ProgSolution!
}

type ProgSolution {
  files: [ExerciseFile!]!
}

input ProgSolutionInput {
  files: [ExerciseFileInput!]!
}

type Query {
  tools: [Tool!]!
  tool(toolId: String!): Tool
}

enum RegexCorrectionType {
  EXTRACTION
  MATCHING
}

type RegexExerciseContent {
  maxPoints: Int!
  correctionType: RegexCorrectionType!
  sampleSolutions: [StringSampleSolution!]!
  matchTestData: [RegexMatchTestData!]!
  extractionTestData: [RegexExtractionTestData!]!
}

type RegexExtractionTestData {
  id: Int!
  base: String!
}

type RegexMatchTestData {
  id: Int!
  data: String!
  isIncluded: Boolean!
}

type RoseExerciseContent {
  fieldWidth: Int!
  fieldHeight: Int!
  isMultiplayer: Boolean!
  sampleSolutions: [StringSampleSolution!]!
}

type SemanticVersion {
  major: Int!
  minor: Int!
  patch: Int!
}

type SiteSpec {
  fileName: String!
  htmlTasks: [HtmlTask!]!
  htmlTaskCount: Int!
  jsTaskCount: Int!
}

type SqlExerciseContent {
  exerciseType: SqlExerciseType!
  hint: String
  sampleSolutions: [StringSampleSolution!]!
}

enum SqlExerciseType {
  SELECT
  CREATE
  DELETE
  INSERT
  UPDATE
}

type StringSampleSolution {
  id: Int!
  sample: String!
}

type Tool {
  id: String!
  name: String!
  state: ToolState!
  lessonCount: Int!
  lessons: [Lesson!]!
  lesson(lessonId: Int!): Lesson
  collectionCount: Int!
  collections: [Collection!]!
  collection(collId: Int!): Collection
  exerciseCount: Int!
  allExerciseMetaData: [Exercise!]!
  exerciseContent(collId: Int!, exId: Int!): ExContent
}

enum ToolState {
  ALPHA
  BETA
  LIVE
}

type UmlAssociation {
  assocType: UmlAssociationType!
  assocName: String
  firstEnd: String!
  firstMult: UmlMultiplicity!
  secondEnd: String!
  secondMult: UmlMultiplicity!
}

input UmlAssociationInput {
  assocType: UmlAssociationType!
  assocName: String
  firstEnd: String!
  firstMult: UmlMultiplicity!
  secondEnd: String!
  secondMult: UmlMultiplicity!
}

enum UmlAssociationType {
  AGGREGATION
  ASSOCIATION
  COMPOSITION
}

type UmlAttribute {
  visibility: UmlVisibility!
  memberName: String!
  memberType: String!
  isStatic: Boolean!
  isDerived: Boolean!
  isAbstract: Boolean!
}

input UmlAttributeInput {
  visibility: UmlVisibility!
  memberName: String!
  memberType: String!
  isStatic: Boolean = false
  isDerived: Boolean = false
  isAbstract: Boolean = false
}

type UmlClass {
  classType: UmlClassType!
  name: String!
  attributes: [UmlAttribute!]!
  methods: [UmlMethod!]!
}

type UmlClassDiagram {
  classes: [UmlClass!]!
  associations: [UmlAssociation!]!
  implementations: [UmlImplementation!]!
}

input UmlClassDiagramInput {
  classes: [UmlClassInput!]!
  associations: [UmlAssociationInput!]!
  implementations: [UmlImplementationInput!]!
}

input UmlClassInput {
  classType: UmlClassType!
  name: String!
  attributes: [UmlAttributeInput!]!
  methods: [UmlMethodInput!]!
}

enum UmlClassType {
  ABSTRACT
  CLASS
  INTERFACE
}

type UmlExerciseContent {
  toIgnore: [String!]!
  sampleSolutions: [UmlSampleSolution!]!
  mappings: [KeyValueObject!]!
}

type UmlImplementation {
  subClass: String!
  superClass: String!
}

input UmlImplementationInput {
  subClass: String!
  superClass: String!
}

type UmlMethod {
  visibility: UmlVisibility!
  memberName: String!
  memberType: String!
  parameters: String!
  isStatic: Boolean!
  isAbstract: Boolean!
}

input UmlMethodInput {
  visibility: UmlVisibility!
  memberName: String!
  memberType: String!
  parameters: String!
  isStatic: Boolean = false
  isAbstract: Boolean = false
}

enum UmlMultiplicity {
  SINGLE
  UNBOUND
}

type UmlSampleSolution {
  id: Int!
  sample: UmlClassDiagram!
}

enum UmlVisibility {
  PACKAGE
  PRIVATE
  PROTECTED
  PUBLIC
}

type UnitTestPart {
  unitTestType: UnitTestType!
  unitTestsDescription: String!
  unitTestFiles: [ExerciseFile!]!
  unitTestTestConfigs: [UnitTestTestConfig!]!
  simplifiedTestMainFile: ExerciseFile
  testFileName: String!
  sampleSolFileNames: [String!]!
}

type UnitTestTestConfig {
  id: Int!
  shouldFail: Boolean!
  description: String!
  file: ExerciseFile!
}

enum UnitTestType {
  Normal
  Simplified
}

type WebExerciseContent {
  htmlText: String
  jsText: String
  siteSpec: SiteSpec!
  files: [ExerciseFile!]!
  sampleSolutions: [WebSampleSolution!]!
}

type WebSampleSolution {
  id: Int!
  sample: [ExerciseFile!]!
}

type XmlExerciseContent {
  grammarDescription: String!
  rootNode: String!
  sampleSolutions: [XmlSampleSolution!]!
}

type XmlSampleSolution {
  id: Int!
  sample: XmlSolution!
}

type XmlSolution {
  document: String!
  grammar: String!
}

input XmlSolutionInput {
  document: String!
  grammar: String!
}
