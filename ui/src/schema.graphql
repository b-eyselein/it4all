# source: http://localhost:9000/api/graphql
# timestamp: Thu Aug 06 2020 14:49:04 GMT+0200 (Mitteleurop√§ische Sommerzeit)

interface AbstractCorrectionResult {
  points: Float!
  maxPoints: Float!
}

type AdditionalComparison {
  selectComparisons: SelectAdditionalComparisons
  insertComparison: SqlInsertComparisonMatchingResult
}

type AttributeList {
  elementName: String!
  attributeDefinitions: [String!]!
}

enum BinaryClassificationResultType {
  TruePositive
  FalsePositive
  FalseNegative
  TrueNegative
}

type CollectionTool {
  id: ID!
  name: String!
  state: ToolState!
  lessonCount: Long!
  lessons: [Lesson!]!
  lesson(lessonId: Int!): Lesson
  collectionCount: Long!
  collections: [ExerciseCollection!]!
  collection(collId: Int!): ExerciseCollection
  exerciseCount: Long!
  allExercises: [Exercise!]!
  proficiencies: [UserProficiency!]!
}

type DTDParseException {
  msg: String!
  parsedLine: String!
}

type ElementDefinition {
  elementName: String!
  content: String!
}

type ElementLine {
  elementName: String!
  elementDefinition: ElementDefinition!
  attributeLists: [AttributeList!]!
}

type ElementLineAnalysisResult {
  contentCorrect: Boolean!
  correctContent: String!
  attributesCorrect: Boolean!
  correctAttributes: String!
}

type ElementLineMatch implements NewMatch {
  matchType: MatchType!
  userArg: ElementLine
  sampleArg: ElementLine
  maybeAnalysisResult: ElementLineAnalysisResult
  userArgDescription: String
  sampleArgDescription: String
}

type Exercise {
  exerciseId: Int!
  collectionId: Int!
  toolId: String!
  title: String!
  authors: [String!]!
  text: String!
  topicsWithLevels: [TopicWithLevel!]!
  difficulty: Int!
  programmingContent: ProgrammingExerciseContent
  regexContent: RegexExerciseContent
  sqlContent: SqlExerciseContent
  umlContent: UmlExerciseContent
  webContent: WebExerciseContent
  xmlContent: XmlExerciseContent
  parts: [ExPart!]!
}

type ExerciseCollection {
  collectionId: Int!
  title: String!
  authors: [String!]!
  exerciseCount: Long!
  exercises: [Exercise!]!
  exercise(exId: Int!): Exercise
}

type ExerciseFile {
  name: String!
  fileType: String!
  editable: Boolean!
  content: String!
}

input ExerciseFileInput {
  name: String!
  fileType: String!
  editable: Boolean!
  content: String!
}

type ExPart {
  id: String!
  name: String!
  isEntryPart: Boolean!
  solved: Boolean!
}

type GradedHtmlTaskResult {
  id: Int!
  success: SuccessType!
  elementFound: Boolean!
  textContentResult: GradedTextResult
  attributeResults: [GradedTextResult!]!
  isSuccessful: Boolean!
  points: Float!
  maxPoints: Float!
}

type GradedJsActionResult {
  actionPerformed: Boolean!
  jsAction: JsAction!
  points: Float!
  maxPoints: Float!
}

type GradedJsHtmlElementSpecResult {
  id: Int!
  success: SuccessType!
  elementFound: Boolean!
  textContentResult: GradedTextResult
  attributeResults: [GradedTextResult!]!
  isSuccessful: Boolean!
  points: Float!
  maxPoints: Float!
}

type GradedJsTaskResult {
  id: Int!
  gradedPreResults: [GradedJsHtmlElementSpecResult!]!
  gradedPostResults: [GradedJsHtmlElementSpecResult!]!
  success: SuccessType!
  points: Float!
  maxPoints: Float!
  gradedJsActionResult: GradedJsActionResult!
}

type GradedTextResult {
  keyName: String!
  awaitedContent: String!
  maybeFoundContent: String
  isSuccessful: Boolean!
  points: Float!
  maxPoints: Float!
}

type HtmlTask {
  text: String!
}

type ImplementationPart {
  base: String!
  files: [ExerciseFile!]!
  implFileName: String!
  sampleSolFileNames: [String!]!
}

type JsAction {
  xpathQuery: String!
  actionType: JsActionType!
  keysToSend: String
}

enum JsActionType {
  Click
  FillOut
}

type KeyValueObject {
  key: String!
  value: String!
}

type Lesson {
  lessonId: Int!
  toolId: String!
  title: String!
  description: String!
  video: String
  contentCount: Long!
  contents: [LessonContent!]!
  content(lessonId: Int!): LessonContent
}

interface LessonContent {
  contentId: Int!
  lessonId: Int!
  toolId: String!
}

type LessonMultipleChoiceQuestion {
  id: Int!
  questionText: String!
  answers: [LessonMultipleChoiceQuestionAnswer!]!
}

type LessonMultipleChoiceQuestionAnswer {
  id: Int!
  answer: String!
  isCorrect: Boolean!
}

type LessonMultipleChoiceQuestionsContent implements LessonContent {
  contentId: Int!
  lessonId: Int!
  toolId: String!
  questions: [LessonMultipleChoiceQuestion!]!
}

type LessonTextContent implements LessonContent {
  contentId: Int!
  lessonId: Int!
  toolId: String!
  content: String!
}

type Level {
  title: String!
  levelIndex: Int!
}

type LoggedInUser {
  username: String!
  isAdmin: Boolean!
}

type LoggedInUserWithToken {
  loggedInUser: LoggedInUser!
  jwt: String!
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

interface MatchingResult {
  points: Float!
  maxPoints: Float!
  allMatches: [NewMatch!]!
}

enum MatchType {
  UNSUCCESSFUL_MATCH
  ONLY_SAMPLE
  ONLY_USER
  PARTIAL_MATCH
  SUCCESSFUL_MATCH
}

type Mutation {
  register(registerValues: RegisterValues!): String
  login(credentials: UserCredentials!): LoggedInUserWithToken
  me(userJwt: String!): UserMutations
}

interface NewMatch {
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

type NormalExecutionResult {
  successful: Boolean!
  logs: String!
}

type NormalUnitTestPart {
  unitTestsDescription: String!
  unitTestFiles: [ExerciseFile!]!
  unitTestTestConfigs: [UnitTestTestConfig!]!
  testFileName: String!
  folderName: String!
  sampleSolFileNames: [String!]!
  simplifiedTestMainFile: ExerciseFile
}

enum ProgExPart {
  TestCreation
  Implementation
  ActivityDiagram
}

interface ProgrammingAbstractResult {
  points: Float!
  maxPoints: Float!
}

type ProgrammingCorrectionResult {
  solutionSaved: Boolean!
  resultSaved: Boolean!
  proficienciesUpdated: Boolean
  result: ProgrammingAbstractResult!
}

type ProgrammingExerciseContent {
  filename: String!
  implementationPart: ImplementationPart!
  sampleSolutions: [ProgrammingSampleSolution!]!
  unitTestPart: UnitTestPart!
  part(partId: String!): ProgExPart
}

type ProgrammingExerciseMutations {
  correct(part: ProgExPart!, solution: ProgSolutionInput!): ProgrammingCorrectionResult!
}

type ProgrammingInternalErrorResult implements ProgrammingAbstractResult & AbstractCorrectionResult {
  msg: String!
  points: Float!
  maxPoints: Float!
}

type ProgrammingResult implements ProgrammingAbstractResult & AbstractCorrectionResult {
  proficienciesUpdated: Boolean
  simplifiedResults: [SimplifiedExecutionResult!]!
  normalResult: NormalExecutionResult
  unitTestResults: [UnitTestCorrectionResult!]!
  points: Float!
  maxPoints: Float!
}

type ProgrammingSampleSolution {
  id: Int!
  sample: ProgSolution!
}

type ProgSolution {
  files: [ExerciseFile!]!
}

input ProgSolutionInput {
  files: [ExerciseFileInput!]!
}

type Query {
  me(userJwt: String!): User
}

interface RegexAbstractResult {
  points: Float!
  maxPoints: Float!
}

type RegexCorrectionResult {
  solutionSaved: Boolean!
  resultSaved: Boolean!
  proficienciesUpdated: Boolean
  result: RegexAbstractResult!
}

enum RegexCorrectionType {
  MATCHING
  EXTRACTION
}

type RegexExerciseContent {
  maxPoints: Int!
  correctionType: RegexCorrectionType!
  matchTestData: [RegexMatchTestData!]!
  extractionTestData: [RegexExtractionTestData!]!
  sampleSolutions: [RegexSampleSolution!]!
  part(partId: String!): RegexExPart
}

type RegexExerciseMutations {
  correct(part: RegexExPart!, solution: String!): RegexCorrectionResult!
}

enum RegexExPart {
  RegexSingleExPart
}

type RegexExtractedValuesComparisonMatchingResult implements MatchingResult {
  allMatches: [RegexMatchMatch!]!
  points: Float!
  maxPoints: Float!
}

type RegexExtractionResult implements RegexAbstractResult & AbstractCorrectionResult {
  extractionResults: [RegexExtractionSingleResult!]!
  points: Float!
  maxPoints: Float!
}

type RegexExtractionSingleResult {
  base: String!
  extractionMatchingResult: RegexExtractedValuesComparisonMatchingResult!
  correct: Boolean!
}

type RegexExtractionTestData {
  id: Int!
  base: String!
}

type RegexInternalErrorResult implements RegexAbstractResult & AbstractCorrectionResult {
  msg: String!
  points: Float!
  maxPoints: Float!
}

type RegexMatchingResult implements RegexAbstractResult & AbstractCorrectionResult {
  matchingResults: [RegexMatchingSingleResult!]!
  points: Float!
  maxPoints: Float!
}

type RegexMatchingSingleResult {
  matchData: String!
  isIncluded: Boolean!
  resultType: BinaryClassificationResultType!
}

type RegexMatchMatch implements NewMatch {
  sampleArg: String
  userArg: String
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

type RegexMatchTestData {
  id: Int!
  data: String!
  isIncluded: Boolean!
}

type RegexSampleSolution {
  id: Int!
  sample: String!
}

input RegisterValues {
  username: String!
  firstPassword: String!
  secondPassword: String!
}

type SelectAdditionalComparisons {
  groupByComparison: SqlGroupByComparisonMatchingResult!
  orderByComparison: SqlOrderByComparisonMatchingResult!
  limitComparison: SqlLimitComparisonMatchingResult!
}

type SimplifiedExecutionResult {
  testId: Int!
  success: SuccessType!
  stdout: String
  testInput: String!
  awaited: String!
  gotten: String!
}

type SimplifiedUnitTestPart {
  simplifiedTestMainFile: ExerciseFile!
}

type SiteSpec {
  fileName: String!
  htmlTasks: [HtmlTask!]!
  htmlTaskCount: Int!
  jsTaskCount: Int!
}

interface SqlAbstractResult {
  points: Float!
  maxPoints: Float!
}

type SqlBinaryExpressionComparisonMatchingResult implements MatchingResult {
  allMatches: [SqlBinaryExpressionMatch!]!
  points: Float!
  maxPoints: Float!
}

type SqlBinaryExpressionMatch implements NewMatch {
  sampleArg: String
  userArg: String
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

type SqlCell {
  colName: String!
  content: String
  different: Boolean!
}

type SqlColumnComparisonMatchingResult implements MatchingResult {
  allMatches: [SqlColumnMatch!]!
  points: Float!
  maxPoints: Float!
}

type SqlColumnMatch implements NewMatch {
  sampleArg: String
  userArg: String
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

type SqlCorrectionResult {
  solutionSaved: Boolean!
  resultSaved: Boolean!
  proficienciesUpdated: Boolean
  result: SqlAbstractResult!
}

type SqlExecutionResult {
  userResult: SqlQueryResult
  sampleResult: SqlQueryResult
}

type SqlExerciseContent {
  exerciseType: SqlExerciseType!
  schemaName: String!
  sampleSolutions: [SqlSampleSolution!]!
  hint: String
  part(partId: String!): SqlExPart
  sqlDbContents: [SqlQueryResult!]!
}

type SqlExerciseMutations {
  correct(part: SqlExPart!, solution: String!): SqlCorrectionResult!
}

enum SqlExerciseType {
  INSERT
  SELECT
  CREATE
  DELETE
  UPDATE
}

enum SqlExPart {
  SqlSingleExPart
}

type SqlGroupByComparisonMatchingResult implements MatchingResult {
  allMatches: [SqlGroupByMatch!]!
  points: Float!
  maxPoints: Float!
}

type SqlGroupByMatch implements NewMatch {
  sampleArg: String
  userArg: String
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

type SqlInsertComparisonMatchingResult implements MatchingResult {
  allMatches: [SqlInsertMatch!]!
  points: Float!
  maxPoints: Float!
}

type SqlInsertMatch implements NewMatch {
  sampleArg: String
  userArg: String
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

type SqlInternalErrorResult implements SqlAbstractResult & AbstractCorrectionResult {
  msg: String!
  points: Float!
  maxPoints: Float!
}

type SqlKeyCellValueObject {
  key: String!
  value: SqlCell!
}

type SqlLimitComparisonMatchingResult implements MatchingResult {
  allMatches: [SqlLimitMatch!]!
  points: Float!
  maxPoints: Float!
}

type SqlLimitMatch implements NewMatch {
  sampleArg: String
  userArg: String
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

type SqlOrderByComparisonMatchingResult implements MatchingResult {
  allMatches: [SqlOrderByMatch!]!
  points: Float!
  maxPoints: Float!
}

type SqlOrderByMatch implements NewMatch {
  sampleArg: String
  userArg: String
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

type SqlQueriesStaticComparison {
  columnComparison: SqlColumnComparisonMatchingResult!
  tableComparison: SqlTableComparisonMatchingResult!
  joinExpressionComparison: SqlBinaryExpressionComparisonMatchingResult!
  whereComparison: SqlBinaryExpressionComparisonMatchingResult!
  additionalComparisons: AdditionalComparison!
}

type SqlQueryResult {
  columnNames: [String!]!
  rows: [SqlRow!]!
  tableName: String!
}

type SqlResult implements SqlAbstractResult & AbstractCorrectionResult {
  staticComparison: SqlQueriesStaticComparison!
  executionResult: SqlExecutionResult!
  points: Float!
  maxPoints: Float!
}

type SqlRow {
  cells: [SqlKeyCellValueObject!]!
}

type SqlSampleSolution {
  id: Int!
  sample: String!
}

type SqlTableComparisonMatchingResult implements MatchingResult {
  allMatches: [SqlTableMatch!]!
  points: Float!
  maxPoints: Float!
}

type SqlTableMatch implements NewMatch {
  sampleArg: String
  userArg: String
  matchType: MatchType!
  userArgDescription: String
  sampleArgDescription: String
}

enum SuccessType {
  ERROR
  NONE
  PARTIALLY
  COMPLETE
}

enum ToolState {
  PRE_ALPHA
  ALPHA
  BETA
  LIVE
}

type Topic {
  abbreviation: String!
  toolId: String!
  title: String!
  maxLevel: Level!
}

type TopicWithLevel {
  topic: Topic!
  level: Level!
}

interface UmlAbstractResult {
  points: Float!
  maxPoints: Float!
}

type UmlAssociation {
  assocType: UmlAssociationType!
  assocName: String
  firstEnd: String!
  firstMult: UmlMultiplicity!
  secondEnd: String!
  secondMult: UmlMultiplicity!
}

type UmlAssociationAnalysisResult {
  endsParallel: Boolean!
  assocTypeEqual: Boolean!
  correctAssocType: UmlAssociationType!
  multiplicitiesEqual: Boolean!
}

input UmlAssociationInput {
  assocType: UmlAssociationType = ASSOCIATION
  assocName: String
  firstEnd: String!
  firstMult: UmlMultiplicity!
  secondEnd: String!
  secondMult: UmlMultiplicity!
}

type UmlAssociationMatch implements NewMatch {
  matchType: MatchType!
  userArg: UmlAssociation
  sampleArg: UmlAssociation
  maybeAnalysisResult: UmlAssociationAnalysisResult
  userArgDescription: String
  sampleArgDescription: String
}

type UmlAssociationMatchingResult implements MatchingResult {
  allMatches: [UmlAssociationMatch!]!
  points: Float!
  maxPoints: Float!
}

enum UmlAssociationType {
  ASSOCIATION
  AGGREGATION
  COMPOSITION
}

type UmlAttribute {
  visibility: UmlVisibility!
  memberName: String!
  memberType: String!
  isStatic: Boolean!
  isDerived: Boolean!
  isAbstract: Boolean!
}

type UmlAttributeAnalysisResult {
  visibilityComparison: Boolean!
  correctVisibility: UmlVisibility!
  typeComparison: Boolean!
  correctType: String!
  staticCorrect: Boolean!
  correctStatic: Boolean!
  derivedCorrect: Boolean!
  correctDerived: Boolean!
  abstractCorrect: Boolean!
  correctAbstract: Boolean!
}

input UmlAttributeInput {
  visibility: UmlVisibility = PUBLIC
  memberName: String!
  memberType: String!
  isStatic: Boolean = false
  isDerived: Boolean = false
  isAbstract: Boolean = false
}

type UmlAttributeMatch implements NewMatch {
  matchType: MatchType!
  userArg: UmlAttribute
  sampleArg: UmlAttribute
  maybeAnalysisResult: UmlAttributeAnalysisResult
  userArgDescription: String
  sampleArgDescription: String
}

type UmlAttributeMatchingResult implements MatchingResult {
  allMatches: [UmlAttributeMatch!]!
  points: Float!
  maxPoints: Float!
}

type UmlClass {
  classType: UmlClassType!
  name: String!
  attributes: [UmlAttribute!]!
  methods: [UmlMethod!]!
}

type UmlClassDiagram {
  classes: [UmlClass!]!
  associations: [UmlAssociation!]!
  implementations: [UmlImplementation!]!
}

input UmlClassDiagramInput {
  classes: [UmlClassInput!]!
  associations: [UmlAssociationInput!]!
  implementations: [UmlImplementationInput!]!
}

input UmlClassInput {
  classType: UmlClassType = CLASS
  name: String!
  attributes: [UmlAttributeInput!] = []
  methods: [UmlMethodInput!] = []
}

type UmlClassMatch implements NewMatch {
  matchType: MatchType!
  userArg: UmlClass
  sampleArg: UmlClass
  compAM: Boolean!
  analysisResult: UmlClassMatchAnalysisResult
  userArgDescription: String
  sampleArgDescription: String
}

type UmlClassMatchAnalysisResult {
  classTypeCorrect: Boolean!
  correctClassType: UmlClassType!
  maybeAttributeMatchingResult: UmlAttributeMatchingResult
  maybeMethodMatchingResult: UmlMethodMatchingResult
}

type UmlClassMatchingResult implements MatchingResult {
  allMatches: [UmlClassMatch!]!
  points: Float!
  maxPoints: Float!
}

enum UmlClassType {
  ABSTRACT
  CLASS
  INTERFACE
}

type UmlCorrectionResult {
  solutionSaved: Boolean!
  resultSaved: Boolean!
  proficienciesUpdated: Boolean
  result: UmlAbstractResult!
}

type UmlExerciseContent {
  toIgnore: [String!]!
  sampleSolutions: [UmlSampleSolution!]!
  part(partId: String!): UmlExPart
  mappings: [KeyValueObject!]!
}

type UmlExerciseMutations {
  correct(part: UmlExPart!, solution: UmlClassDiagramInput!): UmlCorrectionResult!
}

enum UmlExPart {
  ClassSelection
  DiagramDrawingHelp
  DiagramDrawing
  MemberAllocation
}

type UmlImplementation {
  subClass: String!
  superClass: String!
}

input UmlImplementationInput {
  subClass: String!
  superClass: String!
}

type UmlImplementationMatch implements NewMatch {
  matchType: MatchType!
  userArg: UmlImplementation
  sampleArg: UmlImplementation
  userArgDescription: String
  sampleArgDescription: String
}

type UmlImplementationMatchingResult implements MatchingResult {
  allMatches: [UmlImplementationMatch!]!
  points: Float!
  maxPoints: Float!
}

type UmlInternalErrorResult implements UmlAbstractResult {
  msg: String!
  points: Float!
  maxPoints: Float!
}

type UmlMethod {
  visibility: UmlVisibility!
  memberName: String!
  memberType: String!
  parameters: String!
  isStatic: Boolean!
  isAbstract: Boolean!
}

type UmlMethodAnalysisResult {
  visibilityComparison: Boolean!
  correctVisibility: UmlVisibility!
  typeComparison: Boolean!
  correctType: String!
  parameterComparison: Boolean!
  correctParameters: String!
  staticCorrect: Boolean!
  correctStatic: Boolean!
  abstractCorrect: Boolean!
  correctAbstract: Boolean!
}

input UmlMethodInput {
  visibility: UmlVisibility = PUBLIC
  memberName: String!
  memberType: String!
  parameters: String!
  isStatic: Boolean = false
  isAbstract: Boolean = false
}

type UmlMethodMatch implements NewMatch {
  matchType: MatchType!
  userArg: UmlMethod
  sampleArg: UmlMethod
  maybeAnalysisResult: UmlMethodAnalysisResult
  userArgDescription: String
  sampleArgDescription: String
}

type UmlMethodMatchingResult implements MatchingResult {
  allMatches: [UmlMethodMatch!]!
  points: Float!
  maxPoints: Float!
}

enum UmlMultiplicity {
  SINGLE
  UNBOUND
}

type UmlResult implements UmlAbstractResult {
  classResult: UmlClassMatchingResult
  assocResult: UmlAssociationMatchingResult
  implResult: UmlImplementationMatchingResult
  points: Float!
  maxPoints: Float!
}

type UmlSampleSolution {
  id: Int!
  sample: UmlClassDiagram!
}

enum UmlVisibility {
  PUBLIC
  PACKAGE
  PROTECTED
  PRIVATE
}

type UnitTestCorrectionResult {
  testId: Int!
  description: String!
  successful: Boolean!
  stdout: [String!]!
  stderr: [String!]!
}

union UnitTestPart = SimplifiedUnitTestPart | NormalUnitTestPart

type UnitTestTestConfig {
  id: Int!
  shouldFail: Boolean!
  description: String!
  file: ExerciseFile!
}

type User {
  tools: [CollectionTool!]!
  tool(toolId: String!): CollectionTool
}

input UserCredentials {
  username: String!
  password: String!
}

type UserMutations {
  programmingExercise(collId: Int!, exId: Int!): ProgrammingExerciseMutations
  regexExercise(collId: Int!, exId: Int!): RegexExerciseMutations
  sqlExercise(collId: Int!, exId: Int!): SqlExerciseMutations
  umlExercise(collId: Int!, exId: Int!): UmlExerciseMutations
  webExercise(collId: Int!, exId: Int!): WebExerciseMutations
  xmlExercise(collId: Int!, exId: Int!): XmlExerciseMutations
}

type UserProficiency {
  username: String!
  topic: Topic!
  points: Int!
  pointsForNextLevel: Int!
  level: Level!
}

interface WebAbstractResult {
  points: Float!
  maxPoints: Float!
}

type WebCorrectionResult {
  solutionSaved: Boolean!
  resultSaved: Boolean!
  proficienciesUpdated: Boolean
  result: WebAbstractResult!
}

type WebExerciseContent {
  htmlText: String
  jsText: String
  siteSpec: SiteSpec!
  files: [ExerciseFile!]!
  sampleSolutions: [WebSampleSolution!]!
  part(partId: String!): WebExPart
}

type WebExerciseMutations {
  correct(part: WebExPart!, solution: WebSolutionInput!): WebCorrectionResult!
}

enum WebExPart {
  HtmlPart
  JsPart
}

type WebInternalErrorResult implements WebAbstractResult & AbstractCorrectionResult {
  msg: String!
  points: Float!
  maxPoints: Float!
}

type WebResult implements WebAbstractResult & AbstractCorrectionResult {
  gradedHtmlTaskResults: [GradedHtmlTaskResult!]!
  gradedJsTaskResults: [GradedJsTaskResult!]!
  points: Float!
  maxPoints: Float!
}

type WebSampleSolution {
  id: Int!
  sample: WebSolution!
}

type WebSolution {
  files: [ExerciseFile!]!
}

input WebSolutionInput {
  files: [ExerciseFileInput!]!
}

interface XmlAbstractResult {
  points: Float!
  maxPoints: Float!
}

type XmlCorrectionResult {
  solutionSaved: Boolean!
  resultSaved: Boolean!
  proficienciesUpdated: Boolean
  result: XmlAbstractResult!
}

type XmlDocumentResult {
  errors: [XmlError!]!
}

type XmlElementLineComparisonMatchingResult implements MatchingResult {
  allMatches: [ElementLineMatch!]!
  points: Float!
  maxPoints: Float!
}

type XmlError {
  errorType: XmlErrorType!
  errorMessage: String!
  line: Int!
  success: SuccessType!
}

enum XmlErrorType {
  ERROR
  FATAL
  WARNING
}

type XmlExerciseContent {
  grammarDescription: String!
  rootNode: String!
  sampleSolutions: [XmlSampleSolution!]!
  part(partId: String!): XmlExPart
}

type XmlExerciseMutations {
  correct(part: XmlExPart!, solution: XmlSolutionInput!): XmlCorrectionResult!
}

enum XmlExPart {
  GrammarCreationXmlPart
  DocumentCreationXmlPart
}

type XmlGrammarResult {
  parseErrors: [DTDParseException!]!
  results: XmlElementLineComparisonMatchingResult!
}

type XmlInternalErrorResult implements XmlAbstractResult & AbstractCorrectionResult {
  msg: String!
  points: Float!
  maxPoints: Float!
}

type XmlResult implements XmlAbstractResult & AbstractCorrectionResult {
  successType: SuccessType!
  documentResult: XmlDocumentResult
  grammarResult: XmlGrammarResult
  points: Float!
  maxPoints: Float!
}

type XmlSampleSolution {
  id: Int!
  sample: XmlSolution!
}

type XmlSolution {
  document: String!
  grammar: String!
}

input XmlSolutionInput {
  document: String!
  grammar: String!
}
