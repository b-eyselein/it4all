{"version":3,"sources":["node_modules/jquery/dist/jquery.min.js","node_modules/lodash/lodash.js","node_modules/backbone/backbone-min.js","node_modules/jointjs/dist/joint.js"],"names":[],"mappings":"AAAA;AACA,eAAe,aAAa,uGAAuG,2EAA2E,YAAY,MAAM,sDAAsD,aAAa,gEAAgE,sBAAsB,aAAa,4BAA4B,0BAA0B,mEAAmE,eAAe,wDAAwD,eAAe,6BAA6B,iBAAiB,qCAAqC,kBAAkB,2CAA2C,0FAA0F,gDAAgD,cAAc,6FAA6F,8BAA8B,2BAA2B,cAAc,yCAAyC,4EAA4E,kBAAkB,mDAAmD,oBAAoB,iBAAiB,4DAA4D,uBAAuB,oCAAoC,2BAA2B,kBAAkB,sBAAsB,iBAAiB,+CAA+C,qBAAqB,GAAG,kBAAkB,+CAA+C,kBAAkB,kBAAkB,iBAAiB,mBAAmB,iBAAiB,gDAAgD,cAAc,GAAG,gBAAgB,gDAAgD,WAAW,GAAG,gBAAgB,iCAAiC,8CAA8C,gBAAgB,2CAA2C,oCAAoC,iCAAiC,kCAAkC,6BAA6B,gDAAgD,qCAAqC,sBAAsB,IAAI,sLAAsL,kDAAkD,SAAS,WAAW,kFAAkF,mBAAmB,kBAAkB,2BAA2B,QAAQ,qIAAqI,2BAA2B,MAAM,oBAAoB,SAAS,4BAA4B,KAAK,iBAAiB,IAAI,oBAAoB,UAAU,SAAS,eAAe,IAAI,sCAAsC,kDAAkD,SAAS,yBAAyB,YAAY,iFAAiF,yBAAyB,gCAAgC,qBAAqB,mCAAmC,IAAI,gBAAgB,oBAAoB,sBAAsB,iCAAiC,IAAI,iCAAiC,SAAS,qBAAqB,iBAAiB,uBAAuB,IAAI,qCAAqC,iDAAiD,YAAY,kBAAkB,+KAA+K,oCAAoC,EAAE,kBAAkB,iIAAiI,uBAAuB,KAAK,yEAAyE,uBAAuB,IAAI,yBAAyB,SAAS,8KAA8K,IAAI,wfAAwf,ucAAuc,sEAAsE,IAAI,8FAA8F,IAAI,iDAAiD,4BAA4B,2FAA2F,2EAA2E,+FAA+F,eAAe,IAAI,mBAAmB,6DAA6D,EAAE,+BAA+B,EAAE,IAAI,6EAA6E,SAAS,GAAG,6BAA6B,qBAAqB,eAAe,mBAAmB,qBAAqB,eAAe,qBAAqB,wDAAwD,iEAAiE,wBAAwB,oCAAoC,UAAU,qCAAqC,+BAA+B,wEAAwE,KAAK,sDAAsD,gHAAgH,qFAAqF,0CAA0C,2IAA2I,+CAA+C,cAAc,IAAI,0CAA0C,SAAS,QAAQ,QAAQ,iCAAiC,kCAAkC,cAAc,SAAS,uBAAuB,oEAAoE,eAAe,iBAAiB,eAAe,kCAAkC,IAAI,aAAa,SAAS,SAAS,QAAQ,kDAAkD,iBAAiB,8BAA8B,+BAA+B,iBAAiB,4EAA4E,cAAc,6CAA6C,cAAc,eAAe,mBAAmB,sDAAsD,eAAe,mBAAmB,+BAA+B,+CAA+C,eAAe,mBAAmB,sNAAsN,eAAe,sBAAsB,6BAA6B,oCAAoC,yCAAyC,EAAE,EAAE,eAAe,wDAAwD,wBAAwB,wBAAwB,4DAA4D,wCAAwC,8BAA8B,iCAAiC,gPAAgP,sJAAsJ,8BAA8B,oDAAoD,wCAAwC,8EAA8E,qFAAqF,kFAAkF,qCAAqC,uBAAuB,mBAAmB,iCAAiC,yBAAyB,4CAA4C,0BAA0B,iBAAiB,2BAA2B,uBAAuB,mBAAmB,uEAAuE,uBAAuB,yBAAyB,4CAA4C,gCAAgC,MAAM,uDAAuD,6BAA6B,sEAAsE,UAAU,kDAAkD,8GAA8G,eAAe,2CAA2C,YAAY,yCAAyC,SAAS,SAAS,sDAAsD,sFAAsF,+DAA+D,MAAM,6pBAA6pB,iBAAiB,gGAAgG,+BAA+B,4WAA4W,mJAAmJ,uEAAuE,oJAAoJ,2DAA2D,4HAA4H,eAAe,4CAA4C,SAAS,mBAAmB,uBAAuB,4DAA4D,iPAAiP,eAAe,uBAAuB,oDAAoD,2DAA2D,wBAAwB,IAAI,kCAAkC,IAAI,kCAAkC,sBAAsB,8CAA8C,IAAI,0BAA0B,yBAAyB,kCAAkC,gFAAgF,kBAAkB,yEAAyE,SAAS,QAAQ,iCAAiC,2BAA2B,2CAA2C,uBAAuB,8BAA8B,+FAA+F,2GAA2G,uBAAuB,4BAA4B,sBAAsB,6DAA6D,2BAA2B,mBAAmB,kEAAkE,uCAAuC,2BAA2B,gBAAgB,0BAA0B,4BAA4B,MAAM,yBAAyB,uDAAuD,mBAAmB,EAAE,wBAAwB,wCAAwC,4BAA4B,SAAS,kBAAkB,oDAAoD,QAAQ,WAAW,KAAK,0BAA0B,MAAM,iBAAiB,MAAM,+BAA+B,MAAM,uBAAuB,YAAY,iBAAiB,yHAAyH,mBAAmB,iMAAiM,oBAAoB,oBAAoB,oLAAoL,SAAS,gBAAgB,qCAAqC,yBAAyB,SAAS,aAAa,iDAAiD,mBAAmB,eAAe,qEAAqE,0HAA0H,EAAE,sBAAsB,mBAAmB,mBAAmB,iQAAiQ,2BAA2B,kEAAkE,gCAAgC,qBAAqB,iBAAiB,mHAAmH,MAAM,MAAM,SAAS,IAAI,uEAAuE,kCAAkC,SAAS,wCAAwC,gCAAgC,iCAAiC,oDAAoD,sEAAsE,aAAa,OAAO,2CAA2C,iCAAiC,yJAAyJ,iCAAiC,0BAA0B,mCAAmC,sBAAsB,wFAAwF,wGAAwG,0BAA0B,sCAAsC,cAAc,gBAAgB,KAAK,UAAU,mBAAmB,qCAAqC,iCAAiC,kCAAkC,qCAAqC,kBAAkB,gDAAgD,qBAAqB,mBAAmB,yBAAyB,0BAA0B,sCAAsC,2CAA2C,sBAAsB,oGAAoG,MAAM,GAAG,qHAAqH,wCAAwC,UAAU,qBAAqB,kCAAkC,4BAA4B,kBAAkB,aAAa,mBAAmB,yFAAyF,oDAAoD,+BAA+B,2DAA2D,sBAAsB,gEAAgE,mBAAmB,mBAAmB,EAAE,yCAAyC,SAAS,oBAAoB,0BAA0B,oBAAoB,0BAA0B,mBAAmB,0BAA0B,oBAAoB,+BAA+B,mDAAmD,kBAAkB,MAAM,wHAAwH,qBAAqB,UAAU,wBAAwB,YAAY,wBAAwB,kBAAkB,wBAAwB,YAAY,IAAI,eAAe,SAAS,uBAAuB,YAAY,IAAI,eAAe,SAAS,wBAAwB,0BAA0B,OAAO,WAAW,SAAS,wBAAwB,oBAAoB,MAAM,WAAW,SAAS,GAAG,4BAA4B,kDAAkD,oBAAoB,SAAS,mBAAmB,oBAAoB,eAAe,eAAe,4BAA4B,IAAI,kBAAkB,SAAS,mBAAmB,wDAAwD,+BAA+B,kDAAkD,SAAS,iBAAiB,kBAAkB,MAAM,uDAAuD,6DAA6D,iCAAiC,4CAA4C,KAAK,iDAAiD,iCAAiC,UAAU,eAAe,kCAAkC,eAAe,mCAAmC,SAAS,MAAM,uBAAuB,wCAAwC,IAAI,uDAAuD,SAAS,yBAAyB,sEAAsE,oDAAoD,uBAAuB,IAAI,iBAAiB,SAAS,kFAAkF,oBAAoB,iCAAiC,2CAA2C,MAAM,SAAS,MAAM,gBAAgB,mCAAmC,iBAAiB,WAAW,4DAA4D,qEAAqE,EAAE,eAAe,+FAA+F,aAAa,wBAAwB,gBAAgB,0BAA0B,yDAAyD,gBAAgB,EAAE,IAAI,+CAA+C,KAAK,wDAAwD,UAAU,IAAI,mCAAmC,oDAAoD,+BAA+B,6EAA6E,UAAU,aAAa,wFAAwF,6BAA6B,2BAA2B,uBAAuB,SAAS,mHAAmH,iCAAiC,4FAA4F,yBAAyB,uBAAuB,YAAY,gDAAgD,4BAA4B,qCAAqC,OAAO,uBAAuB,8CAA8C,gEAAgE,2GAA2G,sBAAsB,sBAAsB,KAAK,SAAS,uCAAuC,+BAA+B,UAAU,MAAM,SAAS,iCAAiC,kBAAkB,IAAI,0BAA0B,MAAM,8CAA8C,QAAQ,+DAA+D,sBAAsB,yBAAyB,SAAS,+BAA+B,iEAAiE,yBAAyB,oGAAoG,mEAAmE,sDAAsD,oCAAoC,WAAW,qCAAqC,8FAA8F,4DAA4D,QAAQ,kEAAkE,wGAAwG,gEAAgE,iBAAiB,8EAA8E,+CAA+C,4DAA4D,+BAA+B,4GAA4G,8BAA8B,gEAAgE,iBAAiB,wCAAwC,wBAAwB,MAAM,0FAA0F,KAAK,IAAI,8KAA8K,sBAAsB,sBAAsB,kDAAkD,uBAAuB,UAAU,SAAS,iBAAiB,aAAa,EAAE,iDAAiD,SAAS,6BAA6B,gBAAgB,8DAA8D,wEAAwE,kBAAkB,mCAAmC,0BAA0B,kCAAkC,iBAAiB,0CAA0C,yBAAyB,kBAAkB,yBAAyB,WAAW,kIAAkI,sBAAsB,GAAG,cAAc,iBAAiB,6BAA6B,mEAAmE,QAAQ,IAAI,sCAAsC,GAAG,6BAA6B,IAAI,qBAAqB,6BAA6B,oBAAoB,wCAAwC,iBAAiB,wCAAwC,gBAAgB,oEAAoE,EAAE,8CAA8C,2BAA2B,QAAQ,kBAAkB,8BAA8B,qJAAqJ,SAAS,wLAAwL,YAAY,iEAAiE,2GAA2G,wBAAwB,0CAA0C,yCAAyC,gBAAgB,gCAAgC,SAAS,aAAa,gBAAgB,2BAA2B,8BAA8B,YAAY,IAAI,sCAAsC,EAAE,uBAAuB,wDAAwD,mBAAmB,IAAI,kBAAkB,SAAS,gGAAgG,UAAU,MAAM,oDAAoD,mBAAmB,2IAA2I,mBAAmB,gEAAgE,qBAAqB,oEAAoE,UAAU,mBAAmB,mBAAmB,iCAAiC,qBAAqB,yBAAyB,8BAA8B,2BAA2B,kBAAkB,0BAA0B,kBAAkB,8BAA8B,qBAAqB,0BAA0B,qBAAqB,8BAA8B,2BAA2B,4BAA4B,2BAA2B,gCAAgC,sBAAsB,0BAA0B,gBAAgB,sBAAsB,uBAAuB,sBAAsB,qIAAqI,eAAe,sBAAsB,sBAAsB,6JAA6J,EAAE,0BAA0B,cAAc,SAAS,cAAc,QAAQ,oBAAoB,MAAM,IAAI,sGAAsG,SAAS,qBAAqB,wBAAwB,QAAQ,8BAA8B,qCAAqC,QAAQ,gBAAgB,IAAI,wCAAwC,uBAAuB,SAAS,MAAM,YAAY,gFAAgF,qCAAqC,IAAI,eAAe,yDAAyD,uBAAuB,sEAAsE,EAAE,6BAA6B,mBAAmB,sCAAsC,MAAM,sDAAsD,OAAO,iBAAiB,sCAAsC,kBAAkB,sBAAsB,oBAAoB,0BAA0B,qBAAqB,SAAS,iBAAiB,kCAAkC,mBAAmB,UAAU,wBAAwB,oEAAoE,iBAAiB,uCAAuC,kBAAkB,YAAY,SAAS,WAAW,qBAAqB,sQAAsQ,iBAAiB,SAAS,mBAAmB,8CAA8C,qBAAqB,sBAAsB,iBAAiB,gBAAgB,8BAA8B,uBAAuB,0BAA0B,mBAAmB,iCAAiC,mHAAmH,EAAE,SAAS,YAAY,sBAAsB,QAAQ,oBAAoB,kBAAkB,oCAAoC,QAAQ,WAAW,kFAAkF,8MAA8M,kBAAkB,IAAI,IAAI,SAAS,yHAAyH,2FAA2F,8BAA8B,oGAAoG,YAAY,qBAAqB,gCAAgC,MAAM,8BAA8B,kBAAkB,kCAAkC,IAAI,oGAAoG,2DAA2D,2BAA2B,gCAAgC,kBAAkB,uFAAuF,mBAAmB,gFAAgF,2GAA2G,gCAAgC,oBAAoB,EAAE,+DAA+D,uCAAuC,gHAAgH,8BAA8B,wBAAwB,QAAQ,GAAG,mBAAmB,aAAa,sFAAsF,uBAAuB,sCAAsC,oBAAoB,OAAO,WAAW,yCAAyC,6FAA6F,qMAAqM,8BAA8B,6BAA6B,wDAAwD,yFAAyF,sBAAsB,WAAW,IAAI,2CAA2C,qCAAqC,yBAAyB,gBAAgB,uBAAuB,cAAc,uCAAuC,kBAAkB,qDAAqD,aAAa,+BAA+B,qBAAqB,kBAAkB,sBAAsB,eAAe,2EAA2E,wBAAwB,MAAM,qBAAqB,sBAAsB,gCAAgC,6BAA6B,SAAS,mBAAmB,uEAAuE,wBAAwB,oGAAoG,sBAAsB,wBAAwB,eAAe,eAAe,uEAAuE,yBAAyB,8FAA8F,qBAAqB,sBAAsB,yCAAyC,6BAA6B,SAAS,2BAA2B,kBAAkB,QAAQ,mHAAmH,IAAI,wFAAwF,UAAU,aAAa,cAAc,SAAS,UAAU,oBAAoB,kCAAkC,sBAAsB,uBAAuB,0BAA0B,cAAc,uBAAuB,uBAAuB,2BAA2B,eAAe,eAAe,mBAAmB,sCAAsC,eAAe,uEAAuE,WAAW,kFAAkF,2BAA2B,SAAS,8CAA8C,cAAc,qBAAqB,MAAM,+EAA+E,qBAAqB,gBAAgB,EAAE,oCAAoC,wBAAwB,4BAA4B,iBAAiB,GAAG,YAAY,sBAAsB,MAAM,sHAAsH,uBAAuB,UAAU,+DAA+D,4GAA4G,eAAe,2BAA2B,2BAA2B,qBAAqB,iCAAiC,gDAAgD,0BAA0B,EAAE,GAAG,eAAe,oBAAoB,QAAQ,sHAAsH,wBAAwB,uEAAuE,EAAE,qBAAqB,4BAA4B,kBAAkB,EAAE,wBAAwB,8BAA8B,uBAAuB,2DAA2D,2BAA2B,6CAA6C,wEAAwE,yBAAyB,EAAE,gLAAgL,qCAAqC,KAAK,aAAa,gCAAgC,0EAA0E,EAAE,qBAAqB,iGAAiG,qBAAqB,4BAA4B,eAAe,YAAY,qBAAqB,6GAA6G,gBAAgB,uBAAuB,kEAAkE,8BAA8B,uFAAuF,UAAU,iBAAiB,0CAA0C,IAAI,+XAA+X,QAAQ,IAAI,0CAA0C,SAAS,aAAa,gBAAgB,mBAAmB,iBAAiB,gBAAgB,oBAAoB,yEAAyE,uCAAuC,GAAG,EAAE,iHAAiH,yaAAya,QAAQ,oMAAoM,iBAAiB,MAAM,+LAA+L,iBAAiB,uBAAuB,IAAI,0DAA0D,+IAA+I,iBAAiB,EAAE,uBAAuB,qEAAqE,IAAI,sEAAsE,oBAAoB,yJAAyJ,wBAAwB,wDAAwD,iCAAiC,qBAAqB,oDAAoD,4DAA4D,IAAI,8CAA8C,SAAS,2FAA2F,cAAc,SAAS,cAAc,SAAS,iBAAiB,sBAAsB,IAAI,uBAAuB,WAAW,kBAAkB,yBAAyB,QAAQ,uBAAuB,mEAAmE,SAAS,iHAAiH,oBAAoB,kCAAkC,0CAA0C,oDAAoD,0BAA0B,EAAE,mBAAmB,kCAAkC,iCAAiC,wBAAwB,2BAA2B,mCAAmC,oCAAoC,gHAAgH,sEAAsE,8BAA8B,wEAAwE,iCAAiC,4CAA4C,SAAS,SAAS,yBAAyB,qCAAqC,SAAS,yLAAyL,mGAAmG,sCAAsC,kGAAkG,4DAA4D,aAAa,kIAAkI,iQAAiQ,4BAA4B,mDAAmD,oBAAoB,oCAAoC,4EAA4E,wBAAwB,0HAA0H,yMAAyM,wGAAwG,gDAAgD,iDAAiD,sBAAsB,uJAAuJ,eAAe,mBAAmB,sBAAsB,0EAA0E,sCAAsC,6CAA6C,2BAA2B,yMAAyM,oGAAoG,6DAA6D,wBAAwB,gDAAgD,wDAAwD,SAAS,6EAA6E,aAAa,KAAK,IAAI,oIAAoI,kBAAkB,kBAAkB,EAAE,kCAAkC,2BAA2B,IAAI,uBAAuB,2CAA2C,kDAAkD,mDAAmD,YAAY,mDAAmD,iBAAiB,8BAA8B,kDAAkD,GAAG,EAAE,iBAAiB,qCAAqC,UAAU,MAAM,YAAY,QAAQ,kBAAkB,cAAc,mEAAmE,qBAAqB,cAAc,gEAAgE,sBAAsB,eAAe,2EAA2E,eAAe,yBAAyB,8EAA8E,+BAA+B,kDAAkD,uBAAuB,sDAAsD,gYAAgY,oBAAoB,4IAA4I,yBAAyB,oEAAoE,4BAA4B,yBAAyB,uEAAuE,qCAAqC,yBAAyB,iHAAiH,SAAS,uWAAuW,eAAe,+IAA+I,0BAA0B,gCAAgC,eAAe,oBAAoB,iBAAiB,wBAAwB,oBAAoB,qBAAqB,iBAAiB,UAAU,kGAAkG,eAAe,oBAAoB,6CAA6C,sCAAsC,6GAA6G,eAAe,qBAAqB,wBAAwB,uBAAuB,0BAA0B,qBAAqB,QAAQ,8JAA8J,uBAAuB,8BAA8B,YAAY,uFAAuF,2BAA2B,GAAG,EAAE,oHAAoH,iBAAiB,0FAA0F,eAAe,2DAA2D,eAAe,2FAA2F,iBAAiB,gBAAgB,mBAAmB,kGAAkG,IAAI,6BAA6B,0CAA0C,iBAAiB,qBAAqB,OAAO,mDAAmD,mFAAmF,cAAc,8CAA8C,EAAE,8FAA8F,0CAA0C,IAAI,kFAAkF,uDAAuD,IAAI,qKAAqK,uCAAuC,yCAAyC,SAAS,mBAAmB,kCAAkC,eAAe,mHAAmH,SAAS,UAAU,0BAA0B,SAAS,uBAAuB,4CAA4C,0GAA0G,IAAI,kKAAkK,mDAAmD,IAAI,kBAAkB,aAAa,+DAA+D,uBAAuB,oCAAoC,kBAAkB,aAAa,mBAAmB,mFAAmF,oBAAoB,sCAAsC,eAAe,mBAAmB,qBAAqB,oBAAoB,kBAAkB,kBAAkB,0BAA0B,4DAA4D,+EAA+E,EAAE,0BAA0B,mBAAmB,qCAAqC,oFAAoF,EAAE,oBAAoB,qCAAqC,6DAA6D,iBAAiB,gCAAgC,EAAE,mBAAmB,qCAAqC,sDAAsD,EAAE,kBAAkB,qCAAqC,kEAAkE,EAAE,kBAAkB,cAAc,kBAAkB,6DAA6D,YAAY,qBAAqB,sDAAsD,yBAAyB,EAAE,kBAAkB,0BAA0B,iBAAiB,mBAAmB,iDAAiD,iFAAiF,qBAAqB,IAAI,KAAK,IAAI,sBAAsB,kDAAkD,IAAI,WAAW,0BAA0B,0BAA0B,wBAAwB,SAAS,qCAAqC,sBAAsB,uEAAuE,KAAK,UAAU,yGAAyG,eAAe,oBAAoB,uCAAuC,KAAK,iEAAiE,0BAA0B,EAAE,gEAAgE,kCAAkC,gDAAgD,oBAAoB,aAAa,2CAA2C,uCAAuC,SAAS,iCAAiC,mBAAmB,sBAAsB,uQAAuQ,iBAAiB,OAAO,eAAe,iDAAiD,kBAAkB,YAAY,aAAa,MAAM,mCAAmC,cAAc,WAAW,eAAe,UAAU,6CAA6C,cAAc,sBAAsB,gBAAgB,YAAY,WAAW,YAAY,UAAU,yCAAyC,4BAA4B,8KAA8K,cAAc,iCAAiC,kEAAkE,4JAA4J,6BAA6B,aAAa,2BAA2B,aAAa,0BAA0B,aAAa,+BAA+B,aAAa,0BAA0B,aAAa,iCAAiC,YAAY,gIAAgI,8KAA8K,GAAG,GAAG,mEAAmE,eAAe,2BAA2B,uCAAuC,gDAAgD,uCAAuC,QAAQ,gDAAgD,wDAAwD,KAAK,oCAAoC,mBAAmB,iBAAiB,gDAAgD,yBAAyB,8BAA8B,uCAAuC,KAAK,IAAI,6RAA6R,oGAAoG,mBAAmB,6IAA6I,eAAe,eAAe,SAAS,wSAAwS,uBAAuB,wCAAwC,UAAU,UAAU,SAAS,kBAAkB,MAAM,sBAAsB,sBAAsB,YAAY,iRAAiR,YAAY,yBAAyB,+CAA+C,wCAAwC,iHAAiH,kSAAkS,uBAAuB,iBAAiB,iNAAiN,0CAA0C,eAAe,oBAAoB,iIAAiI,iBAAiB,EAAE,qBAAqB,mIAAmI,iMAAiM,8DAA8D,iFAAiF,aAAa,YAAY,sCAAsC,QAAQ,UAAU,oCAAoC,eAAe,iBAAiB,mBAAmB,gBAAgB,uCAAuC,IAAI,oCAAoC,UAAU,wCAAwC,eAAe,kBAAkB,8BAA8B,YAAY,KAAK,qBAAqB,uBAAuB,IAAI,+BAA+B,SAAS,4CAA4C,0BAA0B,2BAA2B,0CAA0C,wJAAwJ,gBAAgB,8BAA8B,4DAA4D,iBAAiB,gCAAgC,0SAA0S,6CAA6C,UAAU,gBAAgB,MAAM,wIAAwI,iBAAiB,2KAA2K,qCAAqC,gBAAgB,4DAA4D,WAAW,mBAAmB,SAAS,mBAAmB,+BAA+B,kBAAkB,qCAAqC,6DAA6D,cAAc,oHAAoH,cAAc,+BAA+B,UAAU,gBAAgB,iBAAiB,aAAa,UAAU,YAAY,IAAI,8CAA8C,kCAAkC,mBAAmB,yEAAyE,IAAI,mCAAmC,mBAAmB,oEAAoE,cAAc,eAAe,cAAc,sGAAsG,IAAI,uBAAuB,6FAA6F,cAAc,wBAAwB,sBAAsB,gBAAgB,0BAA0B,sHAAsH,mEAAmE,0BAA0B,kBAAkB,8BAA8B,iBAAiB,SAAS,IAAI,uBAAuB,sFAAsF,YAAY,mBAAmB,cAAc,oMAAoM,YAAY,yBAAyB,IAAI,0HAA0H,0LAA0L,iCAAiC,KAAK,yBAAyB,UAAU,mBAAmB,4BAA4B,mCAAmC,EAAE,uBAAuB,gCAAgC,yBAAyB,IAAI,uEAAuE,6BAA6B,2DAA2D,mDAAmD,kHAAkH,gBAAgB,mCAAmC,oBAAoB,oDAAoD,EAAE,2BAA2B,wDAAwD,0CAA0C,KAAK,2BAA2B,mXAAmX,YAAY,4HAA4H,6EAA6E,kEAAkE,UAAU,mDAAmD,6DAA6D,0EAA0E,0BAA0B,kDAAkD,0BAA0B,uCAAuC,KAAK,gEAAgE,4OAA4O,4DAA4D,GAAG,cAAc,yBAAyB,8DAA8D,UAAU,QAAQ,2BAA2B,uDAAuD,yBAAyB,OAAO,uCAAuC,qEAAqE,sBAAsB,kBAAkB,aAAa,oBAAoB,4FAA4F,4DAA4D,8BAA8B,qDAAqD,eAAe,IAAI,mFAAmF,yBAAyB,EAAE,oBAAoB,+CAA+C,iFAAiF,8EAA8E,IAAI,sEAAsE,QAAQ,IAAI,8CAA8C,gBAAgB,GAAG,gDAAgD,cAAc,wBAAwB,0FAA0F,UAAU,yEAAyE,eAAe,UAAU,eAAe,aAAa,kBAAkB,eAAe,wBAAwB,8BAA8B,mCAAmC,qBAAqB,kBAAkB,WAAW,0CAA0C,gCAAgC,wBAAwB,8BAA8B,wCAAwC,iBAAiB,sBAAsB,QAAQ,cAAc,+BAA+B,0BAA0B,sEAAsE,wBAAwB,kBAAkB,mBAAmB,EAAE,0PAA0P,4BAA4B,aAAa,mBAAmB,6CAA6C,wBAAwB,4BAA4B,qBAAqB,GAAG,YAAY,qBAAqB,qBAAqB,wWAAwW,YAAY,MAAM,kBAAkB,6CAA6C,cAAc,oDAAoD,0BAA0B,0BAA0B,0DAA0D,MAAM,oBAAoB,sDAAsD,6DAA6D,yBAAyB,sBAAsB,0BAA0B,+DAA+D,EAAE,gEAAgE,eAAe,iCAAiC,eAAe,mDAAmD,eAAe,6DAA6D,aAAa,mBAAmB,6CAA6C,wBAAwB,4BAA4B,6BAA6B,GAAG,YAAY,qBAAqB,qBAAqB,gMAAgM,YAAY,UAAU,gBAAgB,gCAAgC,gFAAgF,UAAU,qCAAqC,wCAAwC,gBAAgB,mBAAmB,wDAAwD,iBAAiB,mBAAmB,+DAA+D,iJAAiJ,mCAAmC,eAAe,qBAAqB,sBAAsB,qCAAqC,0CAA0C,EAAE,kFAAkF,IAAI,kDAAkD,yCAAyC,YAAY,yBAAyB,sBAAsB,qCAAqC,6CAA6C,EAAE,kDAAkD,kFAAkF,IAAI,wEAAwE,yCAAyC,YAAY,2BAA2B,gDAAgD,+FAA+F,iDAAiD,uBAAuB,YAAY,MAAM,sBAAsB,4DAA4D,yKAAyK,EAAE,sBAAsB,YAAY,YAAY,gFAAgF,UAAU,EAAE,aAAa,aAAa,gBAAgB,oBAAoB,sDAAsD,MAAM,sIAAsI,uBAAuB,kIAAkI,gLAAgL,YAAY,UAAU,QAAQ,gBAAgB,6BAA6B,gCAAgC,SAAS,gBAAgB,6FAA6F,kBAAkB,IAAI,uGAAuG,2BAA2B,UAAU,SAAS,mBAAmB,gDAAgD,+EAA+E,oCAAoC,yCAAyC,kBAAkB,kBAAkB,iEAAiE,8CAA8C,mDAAmD,EAAE,4BAA4B,wDAAwD,qBAAqB,kBAAkB,0BAA0B,2GAA2G,0bAA0b,4CAA4C,2BAA2B,uDAAuD,EAAE,6BAA6B,mEAAmE,IAAI,uPAAuP,8TAA8T,0BAA0B,8BAA8B,sBAAsB,EAAE,2BAA2B,eAAe,sBAAsB,4BAA4B,0BAA0B,EAAE,8BAA8B,cAAc,uCAAuC,qBAAqB,gCAAgC,eAAe,kBAAkB,6CAA6C,oBAAoB,iBAAiB,8DAA8D,qDAAqD,qBAAqB,gEAAgE,kEAAkE,EAAE,sBAAsB,gBAAgB,SAAS,uBAAuB,MAAM,sCAAsC,IAAI,kDAAkD,SAAS,SAAS,uFAAuF,8GAA8G,qBAAqB,MAAM,2CAA2C,4EAA4E,EAAE,kCAAkC,yCAAyC,sBAAsB,2BAA2B,iBAAiB,wEAAwE,oBAAoB,uEAAuE,wBAAwB,EAAE,+BAA+B,mBAAmB,cAAc,qBAAqB,sCAAsC,2BAA2B,2BAA2B,8BAA8B,6BAA6B,oBAAoB,gBAAgB,6GAA6G,oBAAoB,oBAAoB,yDAAyD,OAAO,wCAAwC,GAAG,wCAAwC,SAAS,EAAE,+GAA+G,MAAM,6CAA6C,eAAe,qBAAqB,gCAAgC,yCAAyC,0GAA0G,qBAAqB,QAAQ,UAAU,cAAc,MAAM,6CAA6C,eAAe,mFAAmF,IAAI,0CAA0C,iBAAiB,yCAAyC,2CAA2C,YAAY,6BAA6B,0BAA0B,wBAAwB,QAAQ,eAAe,8LAA8L,yBAAyB,mHAAmH,WAAW,4CAA4C,iBAAiB,0DAA0D,aAAa,4EAA4E,cAAc,mBAAmB,yBAAyB,yDAAyD,8DAA8D,2CAA2C,wCAAwC,kIAAkI,KAAK,KAAK,iBAAiB,2CAA2C,MAAM,MAAM,OAAO,KAAK,0FAA0F,yBAAyB,iCAAiC,kCAAkC,gBAAgB,gCAAgC,yEAAyE,8BAA8B,oCAAoC,wBAAwB,MAAM,gCAAgC,iCAAiC,YAAY,mBAAmB,WAAW,mCAAmC,sMAAsM,uBAAuB,IAAI,0FAA0F,SAAS,kBAAkB,kHAAkH,03BAA03B,0EAA0E,qEAAqE,iFAAiF,4DAA4D,iDAAiD,mBAAmB,aAAa,IAAI,iBAAiB,SAAS,aAAa,SAAS,0BAA0B,oBAAoB,kBAAkB,mHAAmH,uCAAuC,2FAA2F,uCAAuC,aAAa,MAAM,mBAAmB,KAAK,YAAY,oCAAoC,IAAI,MAAM,SAAS,OAAO,wCAAwC,0FAA0F,sBAAsB,kBAAkB,uBAAuB,iEAAiE,YAAY,8IAA8I,wBAAwB,sGAAsG,kDAAkD,MAAM,mCAAmC,SAAS,OAAO,SAAS,OAAO,iEAAiE,OAAO,wBAAwB,0hBAA0hB,SAAS,yBAAyB,2BAA2B,yBAAyB,mCAAmC,sCAAsC,uBAAuB,oDAAoD,yCAAyC,0BAA0B,8BAA8B,MAAM,sFAAsF,6BAA6B,eAAe,2EAA2E,2BAA2B,wBAAwB,qBAAqB,EAAE,cAAc,oBAAoB,MAAM,qJAAqJ,WAAW,gDAAgD,SAAS,qBAAqB,uBAAuB,kCAAkC,kCAAkC,uBAAuB,6BAA6B,kCAAkC,EAAE,kBAAkB,WAAW,6BAA6B,oCAAoC,EAAE,oBAAoB,kDAAkD,qCAAqC,QAAQ,oCAAoC,iCAAiC,oCAAoC,mEAAmE,+BAA+B,IAAI,4BAA4B,YAAY,QAAQ,eAAe,yBAAyB,+EAA+E,QAAQ,qCAAqC,mBAAmB,gBAAgB,2GAA2G,oLAAoL,cAAc,kBAAkB,uRAAuR,kBAAkB,EAAE,oBAAoB,8BAA8B,gHAAgH,0CAA0C,OAAO,EAAE,cAAc,IAAI,mCAAmC,SAAS,cAAc,kBAAkB,SAAS,8BAA8B,sCAAsC,eAAe,SAAS,mGAAmG,WAAW,iCAAiC,aAAa,0BAA0B,2BAA2B,uCAAuC,6DAA6D,uCAAuC,QAAQ,uCAAuC,mBAAmB,sCAAsC,QAAQ,kCAAkC,gCAAgC,wDAAwD,2BAA2B,kBAAkB,SAAS,EAAE,oCAAoC,aAAa,0CAA0C,wCAAwC,qBAAqB,+CAA+C,wKAAwK,iPAAiP,4CAA4C,8CAA8C,YAAY,qBAAqB,oHAAoH,WAAW,uKAAuK,kUAAkU,UAAU,2BAA2B,kCAAkC,wHAAwH,2CAA2C,mBAAmB,kEAAkE,0BAA0B,kBAAkB,sCAAsC,EAAE,OAAO,qCAAqC,mCAAmC,kBAAkB,SAAS,WAAW,0BAA0B,kDAAkD,6PAA6P,wMAAwM,cAAc,mBAAmB,iEAAiE,6BAA6B,EAAE,kBAAkB,+FAA+F,kDAAkD,GAAG,aAAa,QAAQ,qBAAqB,YAAY,uBAAuB,cAAc,6DAA6D,KAAK,sEAAsE,4FAA4F,sHAAsH,OAAO,sFAAsF,yBAAyB,2BAA2B,wBAAwB,yDAAyD,aAAa,GAAG,UAAU,iDAAiD,eAAe,wBAAwB,oBAAoB,8BAA8B,MAAM,4EAA4E,yDAAyD,wBAAwB,sCAAsC,+CAA+C,2DAA2D,EAAE,UAAU,8BAA8B,eAAe,QAAQ,yCAAyC,eAAe,sBAAsB,yFAAyF,8BAA8B,MAAM,+PAA+P,kBAAkB,EAAE,oGAAoG,oBAAoB,qBAAqB,eAAe,qBAAqB,2BAA2B,sBAAsB,0BAA0B,4BAA4B,wBAAwB,4BAA4B,mEAAmE,qBAAqB,4CAA4C,0NAA0N,sBAAsB,+DAA+D,EAAE,4CAA4C,sBAAsB,UAAU,wFAAwF,oDAAoD,iCAAiC,yBAAyB,4BAA4B,uJAAuJ,gBAAgB,4DAA4D,oBAAoB,wCAAwC,sEAAsE,SAAS,EAAE,uBAAuB,gCAAgC,0DAA0D,2CAA2C;;CCD5yuF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA,2DAA2D;;AAE3D;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,MAAM,aAAa,OAAO;;AAEpD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C,EAAE;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,eAAe;AACf;;AAEA;AACA;AACA,UAAU;AACV,SAAS;AACT,SAAS;AACT,WAAW;AACX,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,EAAE;AACf,aAAa,MAAM;AACnB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,aAAa,SAAS;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA,cAAc,2BAA2B;AACzC;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,QAAQ;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,iBAAiB,EAAE;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,6BAA6B;AAC5C,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB,OAAO;;AAEP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,mBAAmB;AAClC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,eAAe,OAAO,WAAW;AACjC,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO,WAAW;AACjC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO,WAAW;AACjC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAA+C;AACpF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,oEAAoE;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,eAAe,MAAM;AACrB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,wCAAwC;AACxC,+DAA+D;AAC/D,iEAAiE;AACjE;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,GAAG,SAAS,KAAK,SAAS;AAC3D,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA,uBAAuB,iBAAiB,GAAG,iBAAiB;AAC5D;AACA,mCAAmC,iBAAiB;AACpD,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA,UAAU,oCAAoC;AAC9C,UAAU,qCAAqC;AAC/C,UAAU;AACV;AACA;AACA,4CAA4C,kBAAkB,EAAE;AAChE;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA,UAAU,qCAAqC;AAC/C,UAAU,qCAAqC;AAC/C,UAAU;AACV;AACA;AACA,uCAAuC,kBAAkB,EAAE;AAC3D;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,UAAU,qCAAqC;AAC/C,UAAU,qCAAqC;AAC/C,UAAU;AACV;AACA;AACA,uCAAuC,2BAA2B,EAAE;AACpE;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,UAAU,oCAAoC;AAC9C,UAAU,qCAAqC;AAC/C,UAAU;AACV;AACA;AACA,2CAA2C,4BAA4B,EAAE;AACzE;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS,KAAK,SAAS,GAAG,SAAS;AAC7D,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA,uBAAuB,iBAAiB,GAAG,iBAAiB;AAC5D,sBAAsB,iBAAiB,GAAG,iBAAiB;AAC3D;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA,qBAAqB,SAAS,GAAG,SAAS,GAAG,SAAS,GAAG,SAAS;AAClE;AACA,4BAA4B,SAAS,GAAG,SAAS;AACjD;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA,qBAAqB,iBAAiB,GAAG,iBAAiB,GAAG,iBAAiB;AAC9E;AACA,8BAA8B,iBAAiB;AAC/C;AACA,eAAe,iBAAiB,GAAG,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,qBAAqB;AACpC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C;AACA,iCAAiC,SAAS,eAAe,YAAY,EAAE;AACvE;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C;AACA,qCAAqC,SAAS,eAAe,YAAY,EAAE;AAC3E;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA,UAAU,oCAAoC;AAC9C,UAAU,qCAAqC;AAC/C,UAAU;AACV;AACA;AACA,4CAA4C,kBAAkB,EAAE;AAChE;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA,UAAU,qCAAqC;AAC/C,UAAU,qCAAqC;AAC/C,UAAU;AACV;AACA;AACA,uCAAuC,kBAAkB,EAAE;AAC3D;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS,KAAK,SAAS,GAAG,SAAS;AACtD,eAAe,SAAS,GAAG,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA,uBAAuB,iBAAiB,GAAG,iBAAiB;AAC5D,sBAAsB,iBAAiB,GAAG,iBAAiB;AAC3D;AACA;AACA,eAAe,iBAAiB,GAAG,iBAAiB,GAAG,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,GAAG,SAAS,GAAG,SAAS;AACnD,eAAe,SAAS,GAAG,SAAS;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA,uBAAuB,iBAAiB,GAAG,iBAAiB,GAAG,iBAAiB;AAChF;AACA;AACA,eAAe,iBAAiB,GAAG,iBAAiB;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,KAAK,SAAS,GAAG,SAAS;AACpD,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA,uBAAuB,iBAAiB,GAAG,iBAAiB;AAC5D,sBAAsB,iBAAiB,GAAG,iBAAiB;AAC3D;AACA;AACA,eAAe,iBAAiB,GAAG,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,cAAc,OAAO,QAAQ,SAAS,GAAG,SAAS,GAAG;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,UAAU,+BAA+B;AACzC,UAAU,+BAA+B;AACzC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB,QAAQ,OAAO,SAAS,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8BAA8B;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,UAAU,8BAA8B;AACxC,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,+CAA+C;AACzD,UAAU;AACV;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA,UAAU,8CAA8C;AACxD,UAAU;AACV;AACA;AACA,oCAAoC,kBAAkB,EAAE;AACxD;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA,UAAU,+CAA+C;AACzD,UAAU,gDAAgD;AAC1D,UAAU;AACV;AACA;AACA,kCAAkC,mBAAmB,EAAE;AACvD;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,sBAAsB;AACrC;AACA,eAAe,KAAK;AACpB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,UAAU,4BAA4B;AACtC,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR,cAAc,OAAO,4BAA4B,QAAQ,8BAA8B;AACvF;AACA;AACA,cAAc,UAAU,4BAA4B,YAAY,8BAA8B;AAC9F;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,qCAAqC;AACpD;AACA,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA,UAAU,8BAA8B;AACxC,UAAU,8BAA8B;AACxC,UAAU,8BAA8B;AACxC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA,UAAU,gDAAgD;AAC1D,UAAU,+CAA+C;AACzD,UAAU;AACV;AACA;AACA,uCAAuC,iBAAiB,EAAE;AAC1D;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,cAAc,iBAAiB,EAAE;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA,QAAQ,IAAI;AACZ,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA,UAAU,+CAA+C;AACzD,UAAU;AACV;AACA;AACA,oCAAoC,kBAAkB,EAAE;AACxD;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mCAAmC;AAC7C,UAAU;AACV;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,yBAAyB;AACxC;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA,UAAU,8BAA8B;AACxC,UAAU,8BAA8B;AACxC,UAAU,8BAA8B;AACxC,UAAU;AACV;AACA;AACA,qCAAqC,eAAe,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,oBAAoB,iCAAiC;AACrD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,EAAE;AACjB,eAAe,KAAK;AACpB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,OAAO,YAAY;AAClC,eAAe,QAAQ;AACvB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,yBAAyB;AACxC;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,KAAK;AACpB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,KAAK;AACpB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,qBAAqB;AACpC,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,OAAO,YAAY;AAClC,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA,qBAAqB;AACrB;AACA,6BAA6B,mBAAmB,cAAc,EAAE,EAAE;AAClE;AACA;AACA,6BAA6B,mBAAmB,cAAc,EAAE,EAAE;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,iCAAiC,kBAAkB,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB,EAAE;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA,qBAAqB;AACrB;AACA,0BAA0B,SAAS;AACnC;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,MAAM;AACvB;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,cAAc;AACd;AACA,iBAAiB,SAAS;AAC1B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,GAAG,SAAS,GAAG,SAAS;AAClD,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,GAAG,SAAS,GAAG,SAAS;AAClD,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,qBAAqB;AACpC,iBAAiB,MAAM;AACvB;AACA;AACA,qBAAqB,QAAQ,OAAO,SAAS,EAAE;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,mBAAmB,SAAS,GAAG,SAAS,GAAG,SAAS;AACpD,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,uBAAuB,OAAO,SAAS,EAAE,GAAG,OAAO,iBAAiB,EAAE;AACtE,cAAc,OAAO,iBAAiB;AACtC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD,qBAAqB,6BAA6B;AAClD,qBAAqB;AACrB;AACA;AACA,qCAAqC,mBAAmB,EAAE;AAC1D;AACA;AACA;AACA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD,qBAAqB,6BAA6B;AAClD,qBAAqB;AACrB;AACA;AACA,yCAAyC,mBAAmB,EAAE;AAC9D;AACA;AACA;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA,qBAAqB,QAAQ,OAAO,SAAS,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,iBAAiB,QAAQ;AACzB;AACA;AACA,qBAAqB,OAAO,SAAS;AACrC,6BAA6B,gBAAgB,SAAS,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,iBAAiB,QAAQ;AACzB;AACA;AACA,8BAA8B,gBAAgB,SAAS,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,QAAQ;AACR,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,KAAK;AACpB,iBAAiB,EAAE;AACnB;AACA;AACA,qBAAqB,QAAQ,OAAO,oBAAoB,EAAE;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA,QAAQ;AACR,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD,qBAAqB;AACrB;AACA;AACA,uCAAuC,cAAc,EAAE;AACvD,cAAc,2BAA2B;AACzC;AACA;AACA;AACA,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,gBAAgB,SAAS,GAAG,SAAS;AACrC;AACA;AACA;AACA,gBAAgB,SAAS,GAAG,SAAS;AACrC;AACA;AACA;AACA,cAAc,QAAQ,iBAAiB,GAAG,iBAAiB;AAC3D;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,qBAAqB;AACpC,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,qBAAqB;AACpC,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA,gCAAgC;AAChC,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA,qBAAqB,QAAQ,OAAO,+BAA+B,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,EAAE;AACjB,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB,QAAQ,OAAO,SAAS,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,EAAE;AACjB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA,QAAQ,IAAI;AACZ,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,iBAAiB,QAAQ;AACzB;AACA;AACA,qBAAqB,QAAQ,OAAO,SAAS,EAAE;AAC/C;AACA;AACA;AACA;AACA,cAAc,QAAQ,QAAQ,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ,QAAQ,EAAE;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA,qBAAqB,QAAQ,OAAO,SAAS,EAAE;AAC/C;AACA,iDAAiD,cAAc,EAAE;AACjE;AACA;AACA;AACA,iDAAiD,sBAAsB,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B,eAAe,gBAAgB;AAC/B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO,YAAY;AAClC,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC,qBAAqB,UAAU;AAC/B;AACA;AACA,sEAAsE,2BAA2B,EAAE;AACnG,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA,4DAA4D;AAC5D,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,qDAAqD,2BAA2B,EAAE;AAClF,wCAAwC,aAAa,eAAe,EAAE;AACtE,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA,wDAAwD,qCAAqC;AAC7F;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD,0CAA0C,QAAQ;AAClD,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA,uDAAuD;AACvD;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,+BAA+B,iCAAiC;AAChE,cAAc;AACd;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO,YAAY;AAClC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,aAAa,QAAQ,QAAQ,UAAU,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B,gBAAgB,OAAO;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,KAAK;AACpB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,qBAAqB;AACpC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU;AACV;AACA;AACA,qCAAqC,mBAAmB,cAAc,EAAE,EAAE;AAC1E,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,eAAe,SAAS,GAAG,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,EAAE;AACnB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,UAAU,8CAA8C;AACxD,UAAU;AACV;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE,eAAe,8CAA8C;AAC7D;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,UAAU,yBAAyB;AACnC,UAAU;AACV;AACA;AACA,oCAAoC,iBAAiB;AACrD,eAAe,yBAAyB;AACxC;AACA;AACA,gDAAgD,SAAS,cAAc,SAAS;AAChF,eAAe,yBAAyB,GAAG,yBAAyB;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,EAAE;AACjB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,UAAU,yBAAyB;AACnC,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe,yBAAyB,GAAG,yBAAyB;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,KAAK;AACpB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,UAAU,OAAO,qBAAqB,EAAE;AACxC,UAAU,OAAO,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO,YAAY;AAClC,eAAe,QAAQ;AACvB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB,GAAG,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,qDAAqD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS,GAAG,SAAS;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,UAAU,OAAO,SAAS,EAAE;AAC5B,UAAU,OAAO,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C;AACA,qCAAqC,YAAY,EAAE;AACnD,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS,GAAG,SAAS,GAAG,SAAS;AACpE;AACA,sCAAsC,YAAY,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,EAAE;AACnB;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C;AACA,qCAAqC,YAAY,EAAE;AACnD,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS,GAAG,SAAS,GAAG,SAAS;AACpE;AACA,qCAAqC,YAAY,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK,MAAM,iBAAiB;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,4DAA4D;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAyC;AACtE;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;CCxwhBD,aAAa,6GAA6G,2CAA2C,yDAAyD,sBAAsB,EAAE,sCAAsC,8BAA8B,IAAI,oBAAoB,UAAU,iBAAiB,KAAK,iBAAiB,uCAAuC,oBAAoB,iBAAiB,4BAA4B,kBAAkB,MAAM,wBAAwB,aAAa,aAAa,oBAAoB,oBAAoB,kBAAkB,YAAY,MAAM,0BAA0B,UAAU,2BAA2B,6DAA6D,gBAAgB,WAAW,KAAK,yBAAyB,sBAAsB,iBAAiB,WAAW,KAAK,iBAAiB,KAAK,aAAa,UAAU,qBAAqB,iCAAiC,MAAM,+BAA+B,EAAE,MAAM,0CAA0C,EAAE,UAAU,gBAAgB,aAAa,2BAA2B,kBAAkB,iDAAiD,8CAA8C,EAAE,aAAa,OAAO,iDAAiD,uBAAuB,oBAAoB,SAAS,aAAa,uBAAuB,aAAa,wBAAwB,MAAM,sBAAsB,sCAAsC,eAAe,QAAQ,0CAA0C,EAAE,UAAU,wBAAwB,IAAI,YAAY,SAAS,WAAW,sBAAsB,6BAA6B,mCAAmC,oCAAoC,EAAE,aAAa,gCAAgC,wBAAwB,kBAAkB,gCAAgC,YAAY,WAAW,KAAK,cAAc,YAAY,oBAAoB,wBAAwB,yCAAyC,aAAa,wBAAwB,aAAa,8BAA8B,UAAU,eAAe,gBAAgB,WAAW,KAAK,kBAAkB,OAAO,kBAAkB,KAAK,WAAW,KAAK,OAAO,WAAW,YAAY,SAAS,YAAY,WAAW,KAAK,WAAW,kEAAkE,UAAU,KAAK,kBAAkB,iBAAiB,aAAa,OAAO,KAAK,aAAa,UAAU,uBAAuB,YAAY,0BAA0B,yCAAyC,uBAAuB,+BAA+B,YAAY,sCAAsC,2BAA2B,wBAAwB,MAAM,6BAA6B,OAAO,wBAAwB,EAAE,cAAc,UAAU,sBAAsB,6BAA6B,qCAAqC,eAAe,YAAY,IAAI,wBAAwB,6BAA6B,aAAa,wBAAwB,MAAM,WAAW,YAAY,oBAAoB,YAAY,wBAAwB,UAAU,oBAAoB,2CAA2C,iBAAiB,iDAAiD,OAAO,mDAAmD,OAAO,qDAAqD,OAAO,uDAAuD,OAAO,qDAAqD,SAAS,oBAAoB,oBAAoB,gBAAgB,WAAW,kBAAkB,aAAa,qBAAqB,oBAAoB,8BAA8B,MAAM,iBAAiB,mCAAmC,gCAAgC,EAAE,gBAAgB,KAAK,aAAa,iBAAiB,qBAAqB,+BAA+B,sDAAsD,sDAAsD,YAAY,eAAe,cAAc,4BAA4B,YAAY,QAAQ,EAAE,yCAAyC,oCAAoC,mBAAmB,6CAA6C,iCAAiC,gCAAgC,wBAAwB,SAAS,cAAc,gBAAgB,uCAAuC,wBAAwB,2FAA2F,wBAAwB,oBAAoB,gCAAgC,iBAAiB,oCAAoC,iBAAiB,0BAA0B,oBAAoB,6BAA6B,iBAAiB,yBAAyB,qBAAqB,4CAA4C,qBAAqB,uBAAuB,MAAM,wBAAwB,IAAI,IAAI,KAAK,KAAK,OAAO,QAAQ,EAAE,qCAAqC,cAAc,eAAe,SAAS,qBAAqB,oBAAoB,OAAO,kDAAkD,gBAAgB,sBAAsB,mBAAmB,+BAA+B,gBAAgB,OAAO,gCAAgC,uBAAuB,OAAO,KAAK,YAAY,qBAAqB,4DAA4D,OAAO,4BAA4B,YAAY,WAAW,KAAK,6CAA6C,iBAAiB,OAAO,qBAAqB,gBAAgB,oBAAoB,+BAA+B,oBAAoB,qBAAqB,YAAY,qBAAqB,oCAAoC,IAAI,WAAW,GAAG,mBAAmB,SAAS,yCAAyC,6BAA6B,IAAI,WAAW,GAAG,wBAAwB,0CAA0C,6BAA6B,+BAA+B,2DAA2D,8DAA8D,SAAS,MAAM,gBAAgB,WAAW,8BAA8B,OAAO,OAAO,iBAAiB,sBAAsB,kDAAkD,mCAAmC,+BAA+B,yCAAyC,mBAAmB,YAAY,WAAW,IAAI,WAAW,gBAAgB,sBAAsB,6BAA6B,4BAA4B,6BAA6B,yBAAyB,UAAU,gCAAgC,sBAAsB,MAAM,iCAAiC,IAAI,IAAI,KAAK,KAAK,OAAO,YAAY,yBAAyB,IAAI,aAAa,UAAU,+BAA+B,8BAA8B,aAAa,WAAW,gBAAgB,sBAAsB,sBAAsB,eAAe,6BAA6B,kBAAkB,MAAM,+BAA+B,6BAA6B,yBAAyB,UAAU,mCAAmC,MAAM,qDAAqD,mCAAmC,0BAA0B,kBAAkB,SAAS,qBAAqB,kBAAkB,WAAW,gBAAgB,aAAa,iBAAiB,kBAAkB,uCAAuC,sBAAsB,SAAS,6BAA6B,uCAAuC,YAAY,iBAAiB,mBAAmB,KAAK,UAAU,6BAA6B,UAAU,SAAS,gBAAgB,qEAAqE,yBAAyB,iCAAiC,uDAAuD,qBAAqB,SAAS,kBAAkB,6CAA6C,kBAAkB,kCAAkC,qBAAqB,wBAAwB,YAAY,IAAI,cAAc,GAAG,yBAAyB,2CAA2C,aAAa,oBAAoB,oDAAoD,kBAAkB,0CAA0C,kBAAkB,GAAG,cAAc,EAAE,iCAAiC,QAAQ,EAAE,yCAAyC,8BAA8B,sDAAsD,cAAc,sCAAsC,4BAA4B,YAAY,MAAM,OAAO,iCAAiC,OAAO,uBAAuB,sBAAsB,mCAAmC,wBAAwB,eAAe,MAAM,QAAQ,WAAW,gBAAgB,QAAQ,IAAI,gBAAgB,QAAQ,WAAW,mBAAmB,wBAAwB,kCAAkC,wBAAwB,oBAAoB,4BAA4B,mBAAmB,EAAE,iBAAiB,oCAAoC,mBAAmB,4BAA4B,YAAY,OAAO,sBAAsB,aAAa,IAAI,oBAAoB,kBAAkB,8BAA8B,wBAAwB,WAAW,8BAA8B,8BAA8B,gBAAgB,mBAAmB,kBAAkB,aAAa,MAAM,+BAA+B,sBAAsB,oBAAoB,kBAAkB,WAAW,gBAAgB,+BAA+B,wBAAwB,SAAS,SAAS,SAAS,SAAS,SAAS,YAAY,cAAc,eAAe,YAAY,+CAA+C,uDAAuD,QAAQ,QAAQ,WAAW,KAAK,OAAO,kBAAkB,MAAM,aAAa,sCAAsC,0BAA0B,WAAW,UAAU,2BAA2B,cAAc,cAAc,UAAU,OAAO,WAAW,+BAA+B,MAAM,UAAU,wBAAwB,cAAc,YAAY,MAAM,QAAQ,cAAc,KAAK,iBAAiB,uBAAuB,oCAAoC,YAAY,eAAe,gBAAgB,2DAA2D,gBAAgB,EAAE,qBAAqB,mBAAmB,+BAA+B,kBAAkB,YAAY,uCAAuC,+BAA+B,gBAAgB,YAAY,EAAE,cAAc,QAAQ,WAAW,KAAK,uBAAuB,OAAO,0BAA0B,oCAAoC,iCAAiC,WAAW,4BAA4B,+BAA+B,gBAAgB,qBAAqB,kBAAkB,YAAY,qBAAqB,KAAK,wCAAwC,6BAA6B,cAAc,uBAAuB,YAAY,KAAK,0CAA0C,SAAS,oBAAoB,4BAA4B,eAAe,KAAK,iBAAiB,6BAA6B,wBAAwB,uBAAuB,4BAA4B,KAAK,KAAK,mBAAmB,iBAAiB,wBAAwB,kBAAkB,sCAAsC,iBAAiB,yBAAyB,0GAA0G,iBAAiB,yBAAyB,gBAAgB,sBAAsB,sBAAsB,qBAAqB,kCAAkC,uBAAuB,0BAA0B,kBAAkB,sBAAsB,gEAAgE,QAAQ,EAAE,eAAe,kCAAkC,yBAAyB,2BAA2B,KAAK,oBAAoB,yCAAyC,YAAY,mBAAmB,sBAAsB,mBAAmB,YAAY,WAAW,IAAI,gBAAgB,WAAW,sBAAsB,4BAA4B,UAAU,6BAA6B,yBAAyB,UAAU,gCAAgC,sBAAsB,kBAAkB,aAAa,0BAA0B,mBAAmB,oBAAoB,WAAW,gBAAgB,0BAA0B,gBAAgB,8BAA8B,eAAe,SAAS,qBAAqB,SAAS,kBAAkB,yCAAyC,4CAA4C,EAAE,qBAAqB,iDAAiD,mBAAmB,qBAAqB,iBAAiB,qBAAqB,oBAAoB,qBAAqB,mBAAmB,cAAc,eAAe,cAAc,6BAA6B,qBAAqB,mCAAmC,SAAS,kBAAkB,kBAAkB,0BAA0B,+BAA+B,iDAAiD,aAAa,6BAA6B,SAAS,YAAY,WAAW,KAAK,qBAAqB,eAAe,sBAAsB,wBAAwB,cAAc,yBAAyB,iCAAiC,gCAAgC,cAAc,UAAU,6BAA6B,UAAU,2BAA2B,SAAS,sBAAsB,sBAAsB,6BAA6B,oBAAoB,iCAAiC,2BAA2B,oCAAoC,gCAAgC,yBAAyB,iCAAiC,gCAAgC,2CAA2C,qCAAqC,iCAAiC,MAAM,8CAA8C,kCAAkC,iBAAiB,2CAA2C,iCAAiC,UAAU,gCAAgC,6BAA6B,oCAAoC,EAAE,kDAAkD,MAAM,kCAAkC,oBAAoB,mBAAmB,aAAa,eAAe,QAAQ,QAAQ,QAAQ,MAAM,0BAA0B,aAAa,4BAA4B,qBAAqB,wCAAwC,uCAAuC,cAAc,MAAM,mBAAmB,IAAI,KAAK,6CAA6C,mBAAmB,IAAI,KAAK,SAAS,OAAO,oBAAoB,wBAAwB,OAAO,yBAAyB,yBAAyB,4BAA4B,yCAAyC,2BAA2B,sBAAsB,uCAAuC,uBAAuB,mFAAmF,wBAAwB,4BAA4B,wBAAwB,2BAA2B,wBAAwB,mBAAmB,YAAY,mBAAmB,sBAAsB,qBAAqB,YAAY,2BAA2B,kBAAkB,wBAAwB,wBAAwB,oBAAoB,sBAAsB,YAAY,yBAAyB,mCAAmC,oBAAoB,4BAA4B,+BAA+B,kBAAkB,wBAAwB,gBAAgB,WAAW,8BAA8B,eAAe,iBAAiB,sCAAsC,YAAY,0BAA0B,8CAA8C,YAAY,6BAA6B,qDAAqD,YAAY,4BAA4B,+CAA+C,YAAY,4BAA4B,iCAAiC,2BAA2B,aAAa,iBAAiB,8BAA8B,oCAAoC,wDAAwD,+DAA+D,uBAAuB,KAAK,sCAAsC,4BAA4B,kBAAkB,EAAE,wBAAwB,UAAU,yBAAyB,sBAAsB,0BAA0B,wBAAwB,4BAA4B,kCAAkC,8BAA8B,oCAAoC,0BAA0B,wBAAwB,mBAAmB,0BAA0B,wBAAwB,uBAAuB,kCAAkC,GAAG,oBAAoB,4BAA4B,6CAA6C,oCAAoC,iBAAiB,UAAU,kBAAkB,mBAAmB,mBAAmB,yBAAyB,OAAO,6bAA6b,OAAO,kEAAkE,uDAAuD,yBAAyB,oBAAoB,4CAA4C,OAAO,SAAS,GAAG,EAAE,YAAY,WAAW,EAAE,uBAAuB,WAAW,mBAAmB,GAAG,oDAAoD,EAAE,OAAO,wBAAwB,WAAW,6BAA6B,+DAA+D,iCAAiC,4CAA4C,kBAAkB,kDAAkD,eAAe,aAAa,IAAI,0DAA0D,cAAc,kCAAkC,mBAAmB,yBAAyB,+CAA+C,qCAAqC,mCAAmC,oBAAoB,cAAc,wBAAwB,eAAe,gBAAgB,8BAA8B,kCAAkC,2BAA2B,UAAU,OAAO,uEAAuE,kBAAkB,sCAAsC,2BAA2B,QAAQ,EAAE,yCAAyC,iCAAiC,mBAAmB,uCAAuC,mBAAmB,qBAAqB,eAAe,YAAY,qBAAqB,wBAAwB,0BAA0B,wBAAwB,uBAAuB,2CAA2C,oBAAoB,IAAI,KAAK,gBAAgB,WAAW,8BAA8B,gCAAgC,6BAA6B,0CAA0C,uBAAuB,kCAAkC,EAAE,YAAY,yBAAyB,qBAAqB,wBAAwB,wBAAwB,YAAY,wBAAwB,uBAAuB,oCAAoC,4BAA4B,yBAAyB,8BAA8B,4BAA4B,mEAAmE,sBAAsB,wBAAwB,gDAAgD,kCAAkC,yBAAyB,6BAA6B,iCAAiC,oCAAoC,GAAG,EAAE,2BAA2B,iBAAiB,uCAAuC,gCAAgC,8BAA8B,8BAA8B,qBAAqB,mBAAmB,aAAa,gBAAgB,wBAAwB,8BAA8B,qDAAqD,wCAAwC,sBAAsB,kDAAkD,wCAAwC,qBAAqB,4BAA4B,4CAA4C,sBAAsB,yDAAyD,iBAAiB,qBAAqB,8CAA8C,iBAAiB,oBAAoB,6FAA6F,sCAAsC,yBAAyB,YAAY,+CAA+C,iBAAiB,KAAK,kBAAkB,uBAAuB,mBAAmB,0EAA0E,eAAe,uBAAuB,SAAS,iBAAiB,4BAA4B,sDAAsD,uGAAuG,+DAA+D,8CAA8C,4DAA4D,4DAA4D,iCAAiC,6CAA6C,gDAAgD,wCAAwC,iCAAiC,4CAA4C,YAAY,2CAA2C,8BAA8B,aAAa,GAAG,qEAAqE,6CAA6C,+BAA+B,iCAAiC,wBAAwB,oBAAoB,6DAA6D,kBAAkB,mBAAmB,kCAAkC,6CAA6C,8BAA8B,uBAAuB,kCAAkC,2CAA2C,oCAAoC,+BAA+B,gEAAgE,8CAA8C,iBAAiB,gDAAgD,8BAA8B,uBAAuB,kCAAkC,2CAA2C,oCAAoC,gBAAgB,uCAAuC,iBAAiB,gEAAgE,gBAAgB,qBAAqB,uBAAuB,mBAAmB,EAAE,sBAAsB,yBAAyB,mCAAmC,0CAA0C,kCAAkC,gCAAgC,eAAe,qBAAqB,kCAAkC,oCAAoC,wCAAwC,oBAAoB,cAAc,aAAa,EAAE,wBAAwB,2BAA2B,mBAAmB,aAAa,0BAA0B,gBAAgB,8BAA8B,qBAAqB,UAAU,kBAAkB,6BAA6B,4BAA4B,gBAAgB,uBAAuB,qDAAqD,mBAAmB,+BAA+B,4CAA4C,6DAA6D,gCAAgC,eAAe,kBAAkB,mBAAmB,0CAA0C,KAAK,+BAA+B,oCAAoC,6BAA6B,MAAM,8CAA8C,mBAAmB,KAAK,eAAe,EAAE,gBAAgB,oBAAoB,WAAW,MAAM,8BAA8B,gBAAgB,KAAK,aAAa,gCAAgC,gBAAgB,oCAAoC,0BAA0B,wBAAwB,UAAU,+CAA+C,iBAAiB,mEAAmE,oBAAoB,cAAc,oBAAoB,6BAA6B,2BAA2B,SAAS;AACt4wB,qC;CCDA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,CAAC,2CAA2C;;AAE5C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,YAAY,EAAE;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa,EAAE;;AAEhC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,MAAM,mBAAmB,UAAU,EAAE,EAAE;AACzE,EAAE;;AAEF;AACA,oCAAoC;AACpC;;AAEA;AACA,iFAAiF,OAAO;;AAExF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA;AACA,yBAAyB,+CAA+C;AACxE;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA,2GAA2G,YAAY;AACvH,sFAAsF,YAAY;AAClG,4GAA4G,YAAY;AACxH;AACA;;AAEA,wBAAwB;;AAExB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,IAAI;AACJ,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,IAAI,gBAAgB,cAAc;AAClC,mBAAmB,iFAAiF;AACpG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,IAAI,gBAAgB,cAAc;AAClC,oDAAoD,4CAA4C;AAChG,+BAA+B,yBAAyB;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA,qDAAqD;;AAErD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,kFAAkF;AAClF,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC,WAAW,uBAAuB;AAClC;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,gBAAgB,gBAAgB;AAChC,SAAS,4CAA4C;AACrD;AACA,EAAE;AACF;AACA,EAAE;AACF,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wEAAwE;AACxE;;AAEA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,4BAA4B,aAAa;AACzC;AACA,MAAM,EAAE,OAAO,OAAO,eAAe;AACrC,4DAA4D,kCAAkC;AAC9F,MAAM,EAAE;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAA0D;AAC7E;AACA,6BAA6B;AAC7B;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA,6BAA6B,oEAAoE;AACjG;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,sDAAsD;AACtD,IAAI;AACJ,qCAAqC;AACrC;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,MAAM,OAAO,8BAA8B;AAC3C;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,8CAA8C;AAC7F,WAAW,uEAAuE;AAClF,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAiE;AAC5F;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;AACA;AACA,qBAAqB,wDAAwD;AAC7E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,4BAA4B;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,UAAU;;AAExC;AACA,iCAAiC,2BAA2B;AAC5D,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,aAAa;AAClD,cAAc;;AAEd,qBAAqB,uBAAuB,iCAAiC,EAAE;AAC/E,WAAW,UAAU;;AAErB;AACA,IAAI;AACJ;;AAEA;;AAEA;;;;AAIA,0DAA0D,wBAAwB;;AAElF;AACA;AACA,UAAU,wDAAwD;AAClE;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,eAAe;AAC1F;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,IAAI;AACJ;;AAEA;;AAEA,sBAAsB,gEAAgE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe,WAAW;AACrC;AACA;AACA;AACA,sBAAsB,wBAAwB,EAAE;AAChD,2BAA2B;AAC3B,+BAA+B;AAC/B,gCAAgC;AAChC,gCAAgC;AAChC,4CAA4C;AAC5C,UAAU,EAAE,OAAO;AACnB,gCAAgC;AAChC,4CAA4C;AAC5C,UAAU;AACV;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA,kBAAkB,6BAA6B,qBAAqB,EAAE,EAAE;;AAExE;AACA;AACA,UAAU,yEAAyE;AACnF;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAA2C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,IAAI;AACJ;;AAEA;;;;;;;;AAQA;AACA;;AAEA,+BAA+B,aAAa;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA,kEAAkE,uDAAuD;AACzH;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF,8BAA8B,wBAAwB;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;;AAEA;;AAEA;AACA;;;;;;AAMA,iCAAiC,aAAa;;AAE9C;AACA;AACA,sEAAsE,0CAA0C;AAChH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD,WAAW,qBAAqB;AAChC;AACA;AACA,EAAE;;AAEF;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,aAAa;;AAE9C;AACA;;AAEA;AACA,+CAA+C,wBAAwB;AACvE,kEAAkE,gCAAgC;AAClG;AACA,0CAA0C,4CAA4C;AACtF,8CAA8C,4CAA4C;AAC1F,gDAAgD,4CAA4C;AAC5F,MAAM,qBAAqB,sCAAsC;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA,0CAA0C,kCAAkC;AAC5E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,MAAM,EAAE,OAAO,UAAU,uFAAuF,WAAW;AAC3H;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,gCAAgC,SAAS,gCAAgC;AACzE;AACA;AACA,WAAW;AACX,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA,+BAA+B,iFAAiF;AAChH,SAAS,6BAA6B;AACtC;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iDAAiD,kBAAkB,EAAE;;AAErE;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB;AACzB;AACA,+BAA+B;AAC/B;;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAAuF;AACxG;AACA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS,EAAE;AAC1D,EAAE,gBAAgB;;AAElB;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,UAAU,2DAA2D;AACrE;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA,wBAAwB,mCAAmC,uBAAuB,EAAE,EAAE;;AAEtF;AACA;AACA,UAAU,2EAA2E;AACrF;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2DAA2D;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV,EAAE;AACF,EAAE;;AAEF;AACA;AACA,UAAU,+BAA+B;AACzC;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,+BAA+B,GAAG,2BAA2B;;AAEvE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM,iBAAiB;AACvB,IAAI;AACJ;;AAEA;;;;;;AAMA;AACA;AACA,UAAU,2EAA2E;AACrF;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;AAOA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,UAAU,uFAAuF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAgB,MAAM;AACtB,iBAAiB,MAAM;AACvB;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,WAAW;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,WAAW;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,MAAM;AAClB,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,WAAW;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,WAAW;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wBAAwB,OAAO;;AAE/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC,mCAAmC;AACnC;;AAEA;AACA;AACA;;AAEA,wBAAwB,OAAO;;AAE/B;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC,sCAAsC;AACtC;AACA;;AAEA;AACA,0CAA0C,iBAAiB;;AAE3D;AACA;;AAEA;AACA;;AAEA,4BAA4B,UAAU;;AAEtC;AACA,wCAAwC,kBAAkB;;AAE1D;AACA,wCAAwC,kBAAkB;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;;AAEA,yBAAyB;AACzB,6BAA6B;;AAE7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,qFAAqF,uBAAuB;AAC5G,yBAAyB;;AAEzB;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,qFAAqF,uBAAuB;AAC5G,yBAAyB;;AAEzB;AACA,yBAAyB,UAAU;;AAEnC;AACA,4BAA4B,UAAU;;AAEtC;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,qFAAqF,uBAAuB;AAC5G;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA,2BAA2B;AAC3B,yBAAyB;AACzB,yBAAyB;AACzB,wBAAwB;AACxB;AACA;AACA,wBAAwB,OAAO;;AAE/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gEAAgE;;AAEhE;AACA;;AAEA,cAAc;AACd;;AAEA,kEAAkE;;AAElE;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN,mHAAmH;AACnH;AACA;;AAEA,0BAA0B,0BAA0B;AACpD,0BAA0B,0BAA0B;;AAEpD;;AAEA;AACA,MAAM;;AAEN,8GAA8G;AAC9G;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,qBAAqB;;AAEpD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,qBAAqB;;AAEjD;AACA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,wBAAwB;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,yFAAyF;AACzF;;AAEA;AACA,wFAAwF;AACxF,qFAAqF,uBAAuB;AAC5G;;AAEA;AACA;AACA,wBAAwB,OAAO;;AAE/B;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,sBAAsB,UAAU;;AAEhC;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,uBAAuB;;AAEtE;AACA,MAAM;;AAEN,sGAAsG;AACtG;AACA;AACA;;AAEA,0BAA0B,2BAA2B;AACrD,0BAA0B,yBAAyB;;AAEnD;;AAEA;AACA,MAAM;;AAEN,iGAAiG;AACjG;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,2BAA2B;AACjD,sBAAsB,yBAAyB;;AAE/C;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,yGAAyG;AACzG;;AAEA,wCAAwC,aAAa;;AAErD,yBAAyB,WAAW;AACpC,8BAA8B,WAAW;;AAEzC;;AAEA;AACA,MAAM;;AAEN,0GAA0G;AAC1G;;AAEA,wCAAwC,aAAa;;AAErD;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,wCAAwC,aAAa;;AAErD,qBAAqB,OAAO;AAC5B,0BAA0B,OAAO;;AAEjC;;AAEA;AACA;;AAEA;;AAEA;AACA,6EAA6E;;AAE7E;AACA,MAAM;;AAEN,8FAA8F;AAC9F;;AAEA,0BAA0B,UAAU;AACpC,0BAA0B,UAAU;;AAEpC;AACA;AACA,qFAAqF,uBAAuB;AAC5G,yBAAyB;;AAEzB;AACA;;AAEA;AACA,MAAM;;AAEN,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;;AAEA;AACA;AACA,qFAAqF,uBAAuB;AAC5G,yBAAyB;;AAEzB;AACA;AACA,2CAA2C;AAC3C;AACA,wBAAwB;AACxB,6BAA6B;AAC7B,wCAAwC;AACxC,sCAAsC;AACtC,mBAAmB;AACnB;AACA;AACA,wBAAwB,OAAO;AAC/B;;AAEA;AACA,2DAA2D;;AAE3D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,4BAA4B,EAAE;AACtE;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,sCAAsC;AACjG;AACA,2DAA2D,oCAAoC;;AAE/F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iEAAiE;AACjE;;AAEA,gEAAgE;;AAEhE;AACA;;AAEA,cAAc,OAAO;AACrB;;AAEA,kEAAkE;;AAElE;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN,mGAAmG;AACnG;AACA;;AAEA;AACA,wFAAwF;AACxF,qFAAqF,uBAAuB;AAC5G;;AAEA;AACA;AACA,wBAAwB,OAAO;;AAE/B;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,2FAA2F;AAC3F;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA,gBAAgB,QAAQ;AACxB,kBAAkB;AAClB;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,0CAA0C,qCAAqC;AAC/E,0CAA0C,qCAAqC;AAC/E;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,gBAAgB,OAAO;AACvB;;AAEA;;AAEA,qBAAqB,4CAA4C;;AAEjE;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,yDAAyD;AAClF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,yDAAyD;AAC9E;AACA,MAAM;;AAEN;AACA,gBAAgB,QAAQ;AACxB,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA,mBAAmB;AACnB;AACA;AACA,gCAAgC;AAChC,iCAAiC;AACjC,kCAAkC;AAClC,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,gBAAgB,QAAQ;AACxB,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,cAAc;AAC5B;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN,iBAAiB,MAAM;AACvB;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN,iBAAiB,OAAO;AACxB;;AAEA;AACA;;AAEA;AACA;AACA,yDAAyD,UAAU,EAAE;AACrE;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,yCAAyC,cAAc;AACvD;;AAEA;AACA,sDAAsD,cAAc;AACpE,oDAAoD,cAAc;AAClE;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN,iBAAiB,OAAO;AACxB;;AAEA;AACA,MAAM;;AAEN,iBAAiB,MAAM;AACvB;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,iBAAiB,MAAM;AACvB;;AAEA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C,sBAAsB,oBAAoB;;AAE1C;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;;AAEA;AACA,oCAAoC,kDAAkD;;AAEtF;AACA,MAAM;;AAEN,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN,iBAAiB,OAAO;AACxB;;AAEA;AACA,8BAA8B,aAAa;;AAE3C;AACA;AACA,MAAM;;AAEN,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,wCAAwC,aAAa;;AAErD;AACA;;AAEA,4CAA4C;;AAE5C;AACA,mFAAmF;;AAEnF;AACA,MAAM;;AAEN;;AAEA,wCAAwC,aAAa;;AAErD;AACA;;AAEA;;AAEA;AACA,mFAAmF;;AAEnF;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN,wBAAwB,MAAM;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAM,mDAAmD;AACzD;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,gCAAgC;AAChC,wBAAwB,OAAO;;AAE/B;;AAEA;AACA;;AAEA,UAAU,OAAO;AACjB;AACA,wBAAwB,OAAO;;AAE/B;;AAEA;AACA;AACA;;AAEA,+BAA+B,wDAAwD;;AAEvF;AACA,yEAAyE,wDAAwD;;AAEjI;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA,MAAM,0BAA0B;AAChC;;AAEA,MAAM,gCAAgC;AACtC;AACA;;AAEA,MAAM,iCAAiC;AACvC;AACA;;AAEA,MAAM,oCAAoC;AAC1C,0DAA0D,QAAQ,EAAE;;AAEpE;AACA,oBAAoB,OAAO;;AAE3B;;AAEA,2BAA2B,oDAAoD;AAC/E,mBAAmB,oDAAoD;AACvE;;AAEA,MAAM,OAAO;AACb;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;;AAExC;;AAEA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;;AAErC;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,iBAAiB,2CAA2C;;AAE5D;AACA,+BAA+B,mEAAmE;;AAElG;AACA;AACA,oBAAoB,OAAO,OAAO;AAClC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,wFAAwF;AACxF;;AAEA,mCAAmC;AACnC,0CAA0C,sCAAsC;;AAEhF;AACA;;AAEA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA,cAAc;;AAEd,qCAAqC,uCAAuC;;AAE5E;AACA,4BAA4B,OAAO;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,aAAa;;AAEjC;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,kBAAkB,aAAa;;AAE/B;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,0GAA0G,uBAAuB;AACjI,yBAAyB;;AAEzB;AACA,kBAAkB,UAAU;;AAE5B;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,0GAA0G,uBAAuB;AACjI,yBAAyB;;AAEzB;AACA,8BAA8B,UAAU,EAAE;;AAE1C;AACA,4BAA4B,UAAU,EAAE;;AAExC;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA;AACA,0GAA0G,uBAAuB;AACjI;;AAEA;AACA;AACA,wBAAwB,iBAAiB;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA,6BAA6B,sBAAsB;;AAEnD;AACA,iBAAiB;AACjB,MAAM;;AAEN;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA;AACA,0GAA0G,uBAAuB;AACjI;;AAEA;AACA;AACA,wBAAwB,iBAAiB;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,4BAA4B;;AAE/D;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,cAAc,EAAE;;AAE1C;;AAEA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN,kHAAkH;AAClH;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD,yBAAyB,WAAW;AACpC,yBAAyB,WAAW;;AAEpC;AACA;AACA,0GAA0G,uBAAuB;AACjI,yBAAyB;;AAEzB;AACA;;AAEA;AACA,MAAM;;AAEN,6GAA6G;AAC7G;;AAEA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;;AAEA;AACA;AACA,0GAA0G,uBAAuB;AACjI;;AAEA;AACA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,oBAAoB,iBAAiB;AACrC;;AAEA;AACA;AACA,qCAAqC,mDAAmD;;AAExF,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mCAAmC,8BAA8B;;AAEjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,kBAAkB,cAAc;;AAEhC;AACA;;AAEA;AACA,oDAAoD,cAAc,EAAE;;AAEpE,wBAAwB,iBAAiB;;AAEzC;AACA;;AAEA;AACA,2FAA2F,cAAc;AACzG;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,0CAA0C;;AAE3E,yBAAyB,6BAA6B,EAAE;AACxD,iDAAiD,wCAAwC;;AAEzF;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;;AAEzC;AACA,yDAAyD,uBAAuB;AAChF;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,iCAAiC,EAAE;AAC5D,gDAAgD,wCAAwC;;AAExF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D;;AAE3D,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,sCAAsC;;AAEhF;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;;AAEd,qCAAqC,uCAAuC;;AAE5E;AACA,4BAA4B,OAAO;;AAEnC;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,0BAA0B,aAAa;AACvC,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA,8CAA8C,aAAa;AAC3D;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA,MAAM;;AAEN,yFAAyF;AACzF;AACA;;AAEA;AACA;AACA,iCAAiC,UAAU,EAAE;;AAE7C;AACA,wFAAwF;AACxF,0GAA0G,uBAAuB;AACjI;;AAEA;AACA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA,uCAAuC,6BAA6B;AACpE;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,iCAAiC,UAAU,EAAE;;AAE7C;AACA,gCAAgC,UAAU,EAAE;;AAE5C;AACA;AACA;AACA;AACA,UAAU,uBAAuB,YAAY;AAC7C,+BAA+B,YAAY;;AAE3C;AACA;AACA,0GAA0G,uBAAuB;AACjI;;AAEA;AACA;AACA,wBAAwB,kBAAkB;;AAE1C;AACA;AACA,uCAAuC,oDAAoD;AAC3F;;AAEA;AACA;AACA,8CAA8C,oDAAoD;;AAElG;AACA,MAAM;;AAEN,iHAAiH;AACjH;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD,0BAA0B,2BAA2B;AACrD,0BAA0B,yBAAyB;;AAEnD;AACA;AACA,0GAA0G,uBAAuB;AACjI,yBAAyB;;AAEzB;AACA;;AAEA;AACA,MAAM;;AAEN,kGAAkG;AAClG;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD,4BAA4B,2BAA2B;;AAEvD;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;;AAEA;AACA;AACA,0GAA0G,uBAAuB;AACjI;;AAEA;AACA,mBAAmB;AACnB,wBAAwB,iBAAiB;AACzC;;AAEA;AACA;AACA,qCAAqC,mDAAmD;;AAExF;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC,wEAAwE;;AAE1G;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA,gCAAgC,gCAAgC;AAChE,2CAA2C,8CAA8C;;AAEzF;AACA,0BAA0B,YAAY;AACtC,+BAA+B,YAAY;;AAE3C;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE,2BAA2B,uCAAuC;;AAElE;AACA;AACA,mDAAmD;AACnD,8CAA8C;AAC9C;;AAEA;AACA,kCAAkC,oDAAoD;;AAEtF;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,0CAA0C;;AAE3E,yBAAyB,6BAA6B,EAAE;AACxD,iDAAiD,wCAAwC;;AAEzF;AACA;AACA;;AAEA;AACA,+BAA+B,2CAA2C,EAAE;AAC5E,2BAA2B,+CAA+C,EAAE;;AAE5E;AACA,4DAA4D,6CAA6C;AACzG,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,0CAA0C;;AAE3E,yBAAyB,6BAA6B,EAAE;AACxD,iDAAiD,wCAAwC;;AAEzF;;AAEA;AACA;AACA;;AAEA,iEAAiE;;AAEjE;AACA,0CAA0C,sCAAsC;;AAEhF;AACA,uDAAuD;;AAEvD,uEAAuE,4BAA4B,EAAE;;AAErG,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;;AAEd,qCAAqC,uCAAuC;;AAE5E;;AAEA;AACA,4BAA4B,OAAO;;AAEnC;AACA;AACA,iEAAiE;AACjE;;AAEA,2EAA2E,4BAA4B,EAAE;AACzG;AACA;;AAEA;AACA,iDAAiD,6CAA6C;AAC9F,MAAM;;AAEN;;AAEA;AACA;;AAEA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,sBAAsB,aAAa;;AAEnC;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,sBAAsB,aAAa;;AAEnC;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD,yBAAyB,WAAW;AACpC,yBAAyB,WAAW;;AAEpC;AACA;AACA,0GAA0G,uBAAuB;AACjI,yBAAyB;;AAEzB;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;;AAEA;AACA;AACA,0GAA0G,uBAAuB;AACjI;;AAEA;AACA,mBAAmB;AACnB,wBAAwB,iBAAiB;AACzC;;AAEA;AACA;AACA,qCAAqC,mDAAmD;;AAExF;AACA,yCAAyC,cAAc;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,+BAA+B,2CAA2C;;AAE1E;AACA,MAAM;;AAEN,wHAAwH;AACxH;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD,yBAAyB,WAAW;AACpC,yBAAyB,WAAW;;AAEpC;AACA;AACA,0GAA0G,uBAAuB;AACjI,yBAAyB;;AAEzB;AACA;;AAEA;AACA,MAAM;;AAEN,yGAAyG;AACzG;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;;AAEA;AACA;AACA,0GAA0G,uBAAuB;AACjI;;AAEA,8BAA8B;AAC9B,mBAAmB;AACnB,wBAAwB,iBAAiB;AACzC;;AAEA;AACA;AACA,qCAAqC,mDAAmD;;AAExF;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA,gCAAgC,kCAAkC;AAClE,2CAA2C,gDAAgD;;AAE3F;AACA,0BAA0B,YAAY;AACtC,+BAA+B,YAAY;;AAE3C;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA;AACA,0GAA0G,uBAAuB;;AAEjI;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,uBAAuB,aAAa;AACpC,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,uDAAuD;AACvD;;AAEA;AACA,mCAAmC,mEAAmE,EAAE;AACxG,mBAAmB,oCAAoC,EAAE;;AAEzD;AACA,2CAA2C;AAC3C;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,+BAA+B,sDAAsD;AACrF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,iCAAiC,aAAa;;AAE9C,wBAAwB,iBAAiB;;AAEzC;AACA,qCAAqC,sBAAsB;AAC3D;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,iCAAiC,aAAa;;AAE9C,sCAAsC,QAAQ;;AAE9C;AACA,qCAAqC,oBAAoB;AACzD;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,2BAA2B,aAAa;;AAExC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,mBAAmB;AACnB;AACA;AACA,gCAAgC;AAChC,iCAAiC;AACjC,kCAAkC;AAClC,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B,uBAAuB;;AAEnD;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B,sBAAsB,mCAAmC;AACzD;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,aAAa,EAAE;;AAE9C,wBAAwB,eAAe;;AAEvC;AACA;AACA;;AAEA,0BAA0B,QAAQ;AAClC,0BAA0B,QAAQ;AAClC,0BAA0B,QAAQ;AAClC,0BAA0B,QAAQ;AAClC;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+BAA+B,uBAAuB,EAAE;;AAExD;AACA,wBAAwB,eAAe;;AAEvC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+BAA+B,UAAU,EAAE;AAC3C,+BAA+B,UAAU,EAAE;;AAE3C;AACA;AACA;AACA;AACA,wBAAwB,OAAO;;AAE/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,8BAA8B,UAAU,EAAE;;AAE1C;AACA,4BAA4B,UAAU,EAAE;;AAExC;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,cAAc,EAAE;;AAE/C;AACA;;AAEA;AACA,wCAAwC;AACxC,0BAA0B;AAC1B;AACA,eAAe,sBAAsB;AACrC;AACA;AACA,mCAAmC,aAAa,EAAE;;AAElD,gDAAgD;AAChD,4CAA4C,aAAa,EAAE;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,uBAAuB,EAAE;;AAExD;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;;AAEA,cAAc;AACd;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,eAAe;;AAEnC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD;AACA;AACA,sDAAsD;AACtD;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,4DAA4D;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B,+CAA+C;AAC/C;AACA,oBAAoB,OAAO;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,kBAAkB,cAAc;;AAEhC;AACA;;AAEA;AACA,gDAAgD,cAAc,EAAE;;AAEhE,wBAAwB,eAAe;;AAEvC;AACA;;AAEA;AACA,6CAA6C,cAAc;AAC3D;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+BAA+B,cAAc;;AAE7C;AACA,wBAAwB,OAAO;;AAE/B;AACA;AACA;;AAEA;AACA,2CAA2C,aAAa;AACxD;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+BAA+B,UAAU,EAAE;;AAE3C;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+BAA+B,aAAa,EAAE;AAC9C,+BAA+B,0BAA0B,EAAE;;AAE3D,0BAA0B,0BAA0B;AACpD,0BAA0B,sCAAsC;;AAEhE;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+BAA+B,aAAa,EAAE;AAC9C,+BAA+B,0BAA0B,EAAE;;AAE3D;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;;AAEA;AACA;AACA,wBAAwB,OAAO;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA,wBAAwB,eAAe;AACvC;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA,wBAAwB,eAAe;AACvC;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;;AAGA;AACA,iCAAiC,aAAa,EAAE;;AAEhD;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD;AACzD,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+BAA+B,aAAa,EAAE;AAC9C,+BAA+B,aAAa,EAAE;;AAE9C,yBAAyB,WAAW;AACpC,yBAAyB,WAAW;;AAEpC;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+BAA+B,aAAa,EAAE;AAC9C,+BAA+B,aAAa,EAAE;;AAE9C;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;;AAEA,2BAA2B;AAC3B,mBAAmB;AACnB;AACA,wBAAwB,OAAO;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA,wBAAwB,eAAe;AACvC;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,+BAA+B,WAAW,EAAE;;AAE5C;AACA,wBAAwB,eAAe;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,+BAA+B,aAAa,EAAE;;AAE9C;AACA,MAAM;AACN,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,+BAA+B,aAAa,EAAE;;AAE9C;AACA,MAAM;AACN,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;;AAEA,sBAAsB,qBAAqB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN,iBAAiB,KAAK;AACtB;;AAEA;AACA;AACA,MAAM;;AAEN,iBAAiB,KAAK;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,iBAAiB,KAAK,2BAA2B,KAAK;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;;AAEpD;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;AACA,kBAAkB,UAAU;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA,mBAAmB;AACnB;AACA;AACA,gCAAgC;AAChC,iCAAiC;AACjC,kCAAkC;AAClC,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN,iBAAiB,KAAK;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gGAAgG,IAAI,4CAA4C,IAAI;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa,GAAG,eAAe,GAAG,iBAAiB,WAAW,8BAA8B;AACjH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO,OAAO;AAC9B;AACA;;AAEA,gBAAgB,6CAA6C;AAC7D;;AAEA;AACA,gBAAgB,OAAO;;AAEvB;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC,+EAA+E;AAC/E,sEAAsE;AACtE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,iDAAiD,6CAA6C;;AAE9F;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,6BAA6B,yBAAyB;;AAEtD;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,sBAAsB,UAAU;;AAEhC;;AAEA,sBAAsB,eAAe;;AAErC;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,4BAA4B,wBAAwB;;AAEpD;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,8BAA8B,0BAA0B;;AAExD;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,qCAAqC,gGAAgG,iDAAiD;;AAEtL;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;;AAGA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA;AACA;;AAEA,UAAU;AACV;AACA;;AAEA,MAAM,uEAAuE;AAC7E;AACA;AACA;;AAEA,UAAU;AACV;;AAEA,UAAU,OAAO;AACjB;AACA;AACA,wBAAwB,OAAO,UAAU;;AAEzC,sDAAsD;AACtD;AACA;AACA;AACA;;AAEA,MAAM,OAAO;AACb;AACA;AACA;;AAEA,UAAU,OAAO;AACjB;AACA;AACA,wBAAwB,OAAO;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA,qCAAqC,cAAc;;AAEnD;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,EAAE;;AAEF;;AAEA;AACA;;;AAGA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;;AAEA,MAAM,uEAAuE;AAC7E;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA,UAAU,OAAO;AACjB;AACA;AACA,wBAAwB,OAAO,UAAU;;AAEzC,sDAAsD;AACtD;AACA;AACA;AACA;;AAEA,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA,UAAU,OAAO;AACjB;AACA;AACA,wBAAwB,OAAO,UAAU;;AAEzC,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,qCAAqC,cAAc;;AAEnD;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,EAAE;;AAEF;;AAEA;AACA;;;AAGA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA;AACA;;AAEA,UAAU;AACV;AACA;;AAEA,MAAM,qCAAqC;AAC3C;AACA;AACA;;AAEA,UAAU;AACV;AACA;;AAEA,MAAM,uEAAuE;AAC7E;AACA;AACA;;AAEA,UAAU;AACV;;AAEA,UAAU,OAAO;AACjB;AACA;AACA,wBAAwB,OAAO,UAAU;;AAEzC,sDAAsD;AACtD,+BAA+B,qDAAqD;AACpF,uBAAuB,qDAAqD;AAC5E;AACA;AACA;;AAEA,MAAM,OAAO;AACb;AACA;AACA;;AAEA,UAAU,OAAO;AACjB;AACA;AACA,wBAAwB,OAAO,UAAU;;AAEzC;AACA,+BAA+B,4CAA4C;AAC3E,uBAAuB,4CAA4C;AACnE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA,EAAE;;AAEF,8DAA8D;;AAE9D;AACA;;;AAGA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA,kEAAkE,cAAc;;AAEhF;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,yCAAyC,2GAA2G,iDAAiD;;AAErM;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;;AAE3B;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,cAAc;;AAEd;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gEAAgE,SAAS;;AAEzE;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,cAAc;;AAEd;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA,gBAAgB,YAAY;AAC5B,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,QAAQ;AACxB,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sGAAsG;AACtG,yIAAyI;AACzI;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,uDAAuD;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,2CAA2C;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,4BAA4B,OAAO;AACnC;;AAEA;;AAEA;AACA;AACA,uDAAuD,2CAA2C;AAClG,kBAAkB;AAClB;AACA,uDAAuD,0CAA0C;AACjG;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,iCAAiC,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA,uCAAuC,kCAAkC;AACzE;AACA;AACA;AACA;AACA,gDAAgD,oDAAoD;AACpG;AACA;AACA,8CAA8C,qBAAqB;AACnE,0DAA0D,wBAAwB;AAClF,cAAc;AACd,0CAA0C,mBAAmB;AAC7D;AACA,0DAA0D,wBAAwB;AAClF;AACA;AACA;;AAEA,2BAA2B,uCAAuC;AAClE;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;;AAEA;AACA,4CAA4C,UAAU;AACtD;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sDAAsD,kFAAkF;;AAExI;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA,sDAAsD,6BAA6B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,sDAAsD,kCAAkC;AACxF;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,aAAa,eAAe;AAC5E;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oEAAoE,kBAAkB;AACtF,mCAAmC,4CAA4C;AAC/E,kBAAkB;AAClB,8CAA8C,aAAa;AAC3D;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA,+BAA+B,gCAAgC;AAC/D,yBAAyB,iCAAiC;AAC1D;AACA,qCAAqC,+BAA+B;AACpE;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd,wBAAwB;AACxB;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,+CAA+C,uCAAuC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD,qDAAqD;AACrD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kCAAkC,qBAAqB;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,2CAA2C;;AAEhE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iCAAiC,yBAAyB;;AAE1D;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,kCAAkC;;AAErE;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAA+C;AAC1E;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,eAAe;;AAEpD;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe;;AAEpD;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,wBAAwB;AACjE;;AAEA;AACA;AACA,gDAAgD,4BAA4B;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe,GAAG,eAAe;AACnE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,iBAAiB;AACnD;;AAEA,gEAAgE,kBAAkB;;AAElF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,oBAAoB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,2CAA2C;AACnF,kBAAkB;AAClB,0CAA0C,2CAA2C;AACrF;AACA;;AAEA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,mBAAmB,gCAAgC;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,OAAO;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;;AAEA;AACA,iDAAiD,aAAa;AAC9D,iDAAiD,aAAa;;AAE9D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oCAAoC,eAAe;AACnD;AACA,6CAA6C,OAAO,OAAO,sDAAsD;AACjH;AACA;;AAEA,kEAAkE;AAClE,qBAAqB,8BAA8B;AACnD;AACA;AACA,0CAA0C;AAC1C,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;;AAEtC;;AAEA,4BAA4B,wBAAwB;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,sBAAsB;AACtB,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mCAAmC,aAAa;;AAEhD;AACA;;AAEA;;AAEA;AACA,mCAAmC,aAAa;;AAEhD;AACA;;AAEA;;AAEA,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA,UAAU,4IAA4I;AACtJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8BAA8B,oBAAoB;AAClD,8BAA8B,oBAAoB;;AAElD,+CAA+C,oBAAoB;AACnE,gDAAgD,oBAAoB;;AAEpE,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B,aAAa;;AAE5C,gCAAgC;AAChC;;AAEA;;AAEA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA,cAAc;;AAEd;AACA;;AAEA;;AAEA,0FAA0F;AAC1F;AACA;;AAEA;AACA,mDAAmD,sBAAsB;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,QAAQ;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,0BAA0B;;AAE1B;;AAEA;;AAEA,6BAA6B,4CAA4C;;AAEzE,mCAAmC,aAAa;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D,mDAAmD;AACnD,mDAAmD;AACnD,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D,qDAAqD;AACrD,qDAAqD;AACrD,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,6BAA6B;AAC7B,2BAA2B;;AAE3B;AACA,4BAA4B,QAAQ;AACpC,4BAA4B,kBAAkB,EAAE;;AAEhD,sCAAsC;AACtC,uCAAuC;AACvC,iCAAiC,qBAAqB,EAAE;AACxD;;AAEA,uDAAuD;;AAEvD,0DAA0D,gBAAgB,EAAE;AAC5E;AACA;;AAEA,8BAA8B;;AAE9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,kBAAkB;;AAExC;;AAEA;AACA;AACA;;AAEA;;AAEA,MAAM;AACN;;AAEA;;AAEA,sBAAsB,kBAAkB;;AAExC;;AAEA;AACA;AACA;;AAEA;;AAEA,MAAM;AACN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,sDAAsD,qDAAqD;AAC3G;AACA;AACA,0DAA0D,2BAA2B;AACrF;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6DAA6D;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,2BAA2B;AAC7E,uDAAuD,OAAO;AAC9D;AACA;AACA,kCAAkC,wCAAwC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mCAAmC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,aAAa;AACzC,oBAAoB,gBAAgB;AACpC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA,sCAAsC,YAAY;AAClD;AACA,sBAAsB,YAAY;AAClC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,UAAU;;AAElD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,2DAA2D,UAAU;AACrE;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,qCAAqC;AAC/D;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,+BAA+B;AACtE;;AAEA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,aAAa;AACrC;AACA;;AAEA;;AAEA;AACA,gCAAgC,aAAa;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA,0CAA0C,aAAa;;AAEvD;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,aAAa;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;;AAE1C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;;AAE5D;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;;AAExD;;AAEA,qBAAqB,UAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA,6FAA6F,oBAAoB,EAAE;AACnH;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc;;AAEd;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,oCAAoC;AACpC,kBAAkB;AAClB,kFAAkF;AAClF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,0CAA0C,OAAO;AACjD,gDAAgD,qBAAqB;;AAErE;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+DAA+D;;AAE/D;AACA;;AAEA,uCAAuC;AACvC;;AAEA,oDAAoD;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;;AAEA,MAAM,OAAO;AACb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD;;AAEhD,4DAA4D,0BAA0B;AACtF,2DAA2D,MAAM;;AAEjE;AACA;AACA,iDAAiD;AACjD,oCAAoC;AACpC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA,4BAA4B,mBAAmB,EAAE;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,oBAAoB;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;AACN;;AAEA;AACA,qBAAqB,eAAe,SAAS,gBAAgB,QAAQ,OAAO,OAAO,WAAW;AAC9F;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,oBAAoB,gBAAgB,OAAO;AAC3C,oBAAoB,UAAU,OAAO;AACrC,oBAAoB,0BAA0B,OAAO;AACrD,oBAAoB,yBAAyB,OAAO;AACpD;;AAEA,+BAA+B;AAC/B,qBAAqB;AACrB,6BAA6B,YAAY,EAAE;;AAE3C,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA,kCAAkC,8BAA8B;AAChE,oCAAoC,gCAAgC;;AAEpE,6BAA6B,gBAAgB,EAAE;AAC/C,+BAA+B,oBAAoB,EAAE;AACrD,gCAAgC,sBAAsB,EAAE;AACxD,8BAA8B,kBAAkB,EAAE;;AAElD,aAAa;AACb;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,sBAAsB,UAAU;AAChC,sBAAsB,UAAU;AAChC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA,MAAM;;AAEN;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,MAAM,mBAAmB,QAAQ,qGAAqG,YAAY,qFAAqF,YAAY;;AAEvS;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,MAAM,mBAAmB,QAAQ,kGAAkG,MAAM,0IAA0I,KAAK;;AAE5U;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA,kEAAkE,aAAa;AAC/E;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,KAAK,QAAQ,GAAG,QAAQ,GAAG,iBAAiB,MAAM,mBAAmB,QAAQ;AACnI,yEAAyE,KAAK,mBAAmB,GAAG,QAAQ,GAAG,+CAA+C,MAAM,qGAAqG,QAAQ;;AAEjR;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;;AAEA,yEAAyE,EAAE,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,GAAG,EAAE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;;AAEA,yEAAyE,EAAE,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,GAAG,EAAE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;;AAEA,2EAA2E,OAAO;AAClF;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA,4EAA4E,MAAM;AAClF;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;;AAEA,4FAA4F,OAAO,GAAG,QAAQ,wCAAwC,OAAO,GAAG,QAAQ,wCAAwC,OAAO,GAAG,QAAQ;AAClO;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA,uFAAuF,OAAO,mCAAmC,OAAO,mCAAmC,OAAO;AAClL;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;;AAEA,uFAAuF,OAAO,eAAe,QAAQ,mCAAmC,OAAO,eAAe,QAAQ,mCAAmC,OAAO,eAAe,QAAQ;AACvP;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,qCAAqC;;AAE9D;AACA;AACA;AACA,yBAAyB,sCAAsC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mCAAmC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,YAAY;;AAErD;AACA;AACA,+BAA+B,kDAAkD;AACjF,mDAAmD,kDAAkD;AACrG;;AAEA;;AAEA;AACA,sCAAsC,WAAW;;AAEjD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,wCAAwC;;AAE9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,sBAAsB;AACtD,sBAAsB,2DAA2D;;AAEjF;AACA,sBAAsB,sEAAsE;AAC5F;;AAEA;;AAEA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA,UAAU;;AAEV;AACA;AACA,6BAA6B,aAAa;AAC1C,6BAA6B,6DAA6D;AAC1F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,OAAO,QAAQ,GAAG,EAAE,KAAK,MAAM,EAAE;;AAEtE;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD;AACzD,MAAM;AACN;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,IAAI;;AAEV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,2BAA2B,SAAS,mDAAmD;AACvF,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2CAA2C;AAClF,uCAAuC,iCAAiC;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,MAAM;;AAEN;AACA;AACA;AACA,oDAAoD,6BAA6B;AACjF,qBAAqB;AACrB;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,kCAAkC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qEAAqE,iCAAiC;AACtG,uBAAuB,8CAA8C;AACrE;;AAEA,qBAAqB;AACrB;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;;AAEA,MAAM;;AAEN;AACA,wBAAwB,oBAAoB;AAC5C,MAAM;;AAEN;AACA,wBAAwB,qBAAqB;AAC7C,MAAM;;AAEN;AACA,6BAA6B,oBAAoB;AACjD,MAAM;;AAEN;AACA,6BAA6B,qBAAqB;AAClD,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA,MAAM;;AAEN;AACA;AACA,yDAAyD,eAAe;AACxE,MAAM;;AAEN;AACA;AACA,yDAAyD,gBAAgB;AACzE,MAAM;;AAEN;AACA;AACA,wDAAwD,eAAe;AACvE,MAAM;;AAEN;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,sCAAsC;AACnF,wCAAwC,0CAA0C;AAClF;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,4FAA4F;AAC5F;AACA,sBAAsB;;AAEtB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA,gDAAgD,eAAe;AAC/D;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,0CAA0C;AAC1C;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,8BAA8B,yBAAyB;AACvD,UAAU;;AAEV;AACA;;AAEA,oEAAoE,gBAAgB;AACpF;;AAEA,6DAA6D,eAAe;AAC5E,cAAc;;AAEd,qEAAqE,iBAAiB;AACtF;;AAEA,6DAA6D,eAAe;AAC5E,cAAc;AACd;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8BAA8B;AAC5D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,gDAAgD,iCAAiC;AACjF;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,gDAAgD,iCAAiC;AACjF;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA,yBAAyB,aAAa;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN,sFAAsF,aAAa;AACnG;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,UAAU;AACV;;AAEA;AACA,4EAA4E,aAAa;AACzF;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ,gBAAgB,EAAE;AAC9C;AACA;AACA,oBAAoB,YAAY,UAAU,aAAa,IAAI,IAAI;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;;AAEA,iCAAiC;AACjC,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,UAAU;;AAEV,wBAAwB;AACxB;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,uBAAuB,4CAA4C;;AAEnE,UAAU;;AAEV;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA,0BAA0B,sCAAsC,QAAQ,aAAa,GAAG;AACxF;AACA,MAAM;;AAEN;;AAEA,0BAA0B,qCAAqC,QAAQ,aAAa,GAAG;AACvF;AACA,MAAM;;AAEN;;AAEA;AACA,2BAA2B,aAAa;AACxC;AACA,4EAA4E,UAAU;AACtF;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,qCAAqC,aAAa;AAClD,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA,sBAAsB,QAAQ,aAAa;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,sBAAsB,QAAQ,aAAa;;AAE3C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA,sBAAsB,QAAQ,aAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,iBAAiB,OAAO,oCAAoC;AAC9F;;AAEA;AACA,kCAAkC,gBAAgB,OAAO,sCAAsC;AAC/F;;AAEA;AACA,kCAAkC,iBAAiB,OAAO,4BAA4B;AACtF;;AAEA;AACA,kCAAkC,gBAAgB,OAAO,uCAAuC;AAChG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,mBAAmB;AACnB;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,sBAAsB,aAAa;AACnC,sBAAsB;AACtB,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,sBAAsB,EAAE;AAC9E;AACA;AACA,8CAA8C,sBAAsB;AACpE,2BAA2B;AAC3B;;AAEA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,SAAS,kBAAkB,EAAE;AACvE;AACA;AACA,iDAAiD,yBAAyB;AAC1E,8BAA8B;AAC9B;;AAEA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;AACA,uBAAuB,2BAA2B;;AAElD;AACA,qCAAqC,mCAAmC;AACxE;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA,MAAM;;AAEN;;AAEA,sBAAsB,gDAAgD;;AAEtE;AACA;AACA;AACA,uBAAuB,mBAAmB;;AAE1C;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA,uBAAuB,6BAA6B;;AAEpD;AACA,qCAAqC,qCAAqC;;AAE1E;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;;AAEA;AACA,wCAAwC,eAAe;AACvD;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,uBAAuB,iDAAiD;;AAExE;AACA;AACA;AACA,uBAAuB,mBAAmB;;AAE1C;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,+BAA+B,SAAS,4BAA4B;;AAEpE;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA,MAAM;;AAEN;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA,UAAU;AACV;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA,UAAU;AACV;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA,kCAAkC;;AAElC;;AAEA;AACA,mCAAmC;AACnC;AACA,mCAAmC;AACnC;AACA,mCAAmC;;AAEnC;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,UAAU,mBAAmB,kBAAkB;AAC/C,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA,wDAAwD,eAAe;AACvE,cAAc;;AAEd,gEAAgE,iBAAiB;AACjF;;AAEA,wDAAwD,eAAe;AACvE,cAAc;AACd;AACA,MAAM;;AAEN;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,kBAAkB;AAClB;AACA;AACA,wFAAwF,iCAAiC,EAAE;AAC3H;AACA,MAAM;;AAEN;AACA,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA,gBAAgB,OAAO;AACvB,kBAAkB,gBAAgB,oCAAoC;AACtE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI;AACd,MAAM;;AAEN;AACA,gBAAgB,YAAY;AAC5B,kBAAkB,OAAO;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,gBAAgB,OAAO;AACvB,gBAAgB,eAAe;AAC/B,gBAAgB,GAAG;AACnB,gBAAgB,QAAQ;AACxB,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,gBAAgB,gBAAgB,sDAAsD,EAAE;AACxF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,kBAAkB,OAAO;AACzB;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6DAA6D,WAAW;AACxE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,gBAAgB,YAAY;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,gBAAgB,KAAK;AACrB,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mEAAmE,uEAAuE;AAC1I;AACA,+CAA+C;AAC/C,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;AACA,gBAAgB,WAAW;AAC3B,iBAAiB,wEAAwE;AACzF,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,iBAAiB;AACrD,MAAM;;AAEN;AACA,gBAAgB,KAAK;AACrB,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,gBAAgB,OAAO;AACvB,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oBAAoB,aAAa;AACjC,gBAAgB,sBAAsB;AACtC;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,qDAAqD;;AAEpF;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,uCAAuC,aAAa;AACpD;;AAEA;;AAEA,UAAU,OAAO;;AAEjB;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,+CAA+C,qBAAqB;;AAEpE,sEAAsE;AACtE;AACA,cAAc;;AAEd;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,+BAA+B;;AAE9D;AACA;;AAEA,UAAU;;AAEV;AACA,+BAA+B,+BAA+B;AAC9D;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;;AAGA;AACA;AACA;AACA;AACA,sBAAsB,qDAAqD;;AAE3E,6EAA6E,yBAAyB,EAAE;AACxG,0CAA0C,aAAa;;AAEvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,aAAa;AACrC,oBAAoB;AACpB,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mDAAmD;AAC3F;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA,mDAAmD,iCAAiC;AACpF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,kEAAkE;AAClE;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA,UAAU;AACV,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA,wBAAwB,QAAQ,cAAc;;AAE9C;;AAEA,uCAAuC,aAAa;;AAEpD;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;;AAEA,sEAAsE;;AAEtE;AACA,MAAM;;AAEN;;AAEA,kCAAkC,aAAa;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;;AAExD;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D,oCAAoC,2BAA2B;AAC/D;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D,oCAAoC,2BAA2B;AAC/D;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAyD,aAAa;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,eAAe;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW,QAAQ,iBAAiB;AAC9C;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW,QAAQ,gBAAgB;AAC7C;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA,0EAA0E,UAAU;AACpF;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA,0EAA0E,UAAU;AACpF;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,GAAG,iBAAiB;AAC9B;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,GAAG,gBAAgB;AAC7B;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,uFAAuF,aAAa;AACpG,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA,iCAAiC,GAAG,gBAAgB;;AAEpD;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA,iCAAiC,GAAG,mBAAmB;;AAEvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,MAAM;;;AAGN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB,aAAa;AACtC;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA,qDAAqD,SAAS,kBAAkB;AAChF,MAAM;;AAEN;;AAEA;AACA;;AAEA,oDAAoD,SAAS,kBAAkB;AAC/E,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA,6CAA6C,2BAA2B,EAAE;AAC1E;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,gFAAgF,iBAAiB;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC;;AAEjC;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD,MAAM;;AAEN;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA,uBAAuB,aAAa;AACpC,2BAA2B;AAC3B;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE,2BAA2B,UAAU;AACrC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,oBAAoB,wDAAwD;AAC5E;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA,oDAAoD;AACpD,mDAAmD;AACnD;AACA;AACA,MAAM;;AAEN;AACA,8BAA8B,2BAA2B;AACzD;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA,8CAA8C;AAC9C,+CAA+C;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA,gBAAgB,WAAW;AAC3B,8BAA8B,YAAY;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,6EAA6E,QAAQ;AACrF;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,EAAE;;AAEF,eAAe;;AAEf;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,yBAAyB,aAAa;AACtC;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,mBAAmB,yDAAyD;AAC5E;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,kBAAkB,iBAAiB;AACnC,8BAA8B,QAAQ;AACtC;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,2CAA2C,eAAe;AAC1D,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA,kCAAkC,kBAAkB;AACpD,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,UAAU;AAC/E;AACA,0CAA0C,mBAAmB;AAC7D,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D,yCAAyC,OAAO;AAChD;AACA,iCAAiC,6BAA6B;AAC9D;;AAEA;AACA;AACA,0BAA0B,oEAAoE;;AAE9F;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA,8CAA8C,OAAO,OAAO,yBAAyB;AACrF,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,0CAA0C,QAAQ;AAClD,yDAAyD,gCAAgC;AACzF;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,2DAA2D;AAC/F;AACA;AACA;AACA;AACA,2CAA2C,2DAA2D;AACtG;AACA;AACA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,yCAAyC;;AAE/E;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oDAAoD,gCAAgC;AACpF;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA,MAAM;;AAEN;;AAEA;AACA,6BAA6B,mBAAmB;AAChD;AACA,MAAM;;AAEN;;AAEA;AACA,kDAAkD,4CAA4C;AAC9F;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,mDAAmD,qDAAqD;AACxG;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA,6CAA6C,UAAU,EAAE;AACzD;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+BAA+B;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,2EAA2E;AACnH;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA,uDAAuD;AACvD,iEAAiE;AACjE,6DAA6D;;AAE7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,0BAA0B,cAAc;AACxC,qBAAqB,aAAa;AAClC;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,yBAAyB,uBAAuB;AAChD;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,yBAAyB,kBAAkB;AAC3C;AACA,MAAM;;AAEN;;AAEA;AACA,yBAAyB,kBAAkB;AAC3C;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,wBAAwB;AACxB,4BAA4B,QAAQ;AACpC,yCAAyC,SAAS;AAClD,yCAAyC,SAAS;AAClD,wDAAwD,0BAA0B;AAClF,UAAU;AACV;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA,+BAA+B,qBAAqB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,qDAAqD;AAC5E,qCAAqC,sCAAsC;AAC3E,0CAA0C,wCAAwC;AAClF;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA,MAAM;;AAEN;;AAEA,iCAAiC,2BAA2B;AAC5D,2CAA2C,eAAe;AAC1D;AACA,MAAM;;AAEN;;AAEA,kCAAkC,2BAA2B;AAC7D;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,4BAA4B,sCAAsC;AAClE;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;;AAErE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,2BAA2B;;AAE9E;AACA,oCAAoC,yCAAyC,UAAU,sBAAsB;AAC7G;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB,uBAAuB;;AAE/C;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,8DAA8D,oCAAoC;AAClG;AACA,6CAA6C,0BAA0B,WAAW,EAAE;AACpF,UAAU;;AAEV;;AAEA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA,MAAM;;AAEN;;AAEA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV,qEAAqE,sCAAsC;AAC3G;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,QAAQ;;AAEpD;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;;AAEA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,sDAAsD,aAAa,gBAAgB,WAAW;AAC9F,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,OAAO;AACzC,qEAAqE,aAAa;AAClF;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D,cAAc;AACd;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA,8CAA8C,QAAQ;;AAEtD;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,4CAA4C;;AAElE;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,iDAAiD,QAAQ;;AAEzD;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA,8CAA8C,QAAQ;;AAEtD;AACA;AACA,8BAA8B,uBAAuB;AACrD;;AAEA;;AAEA;AACA;AACA;;AAEA,kCAAkC,mBAAmB;AACrD;;AAEA,UAAU;;AAEV;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;;AAEA,wEAAwE,2BAA2B;AACnG,8BAA8B,qBAAqB;AACnD,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,UAAU;AACV;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,uDAAuD;;AAE5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,QAAQ;AACzG,cAAc;AACd;AACA,0EAA0E,QAAQ;AAClF;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,8BAA8B,8BAA8B;AAC5D,MAAM;;AAEN;;AAEA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,MAAM;;AAEN;AACA;AACA,8EAA8E,QAAQ;AACtF;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,2BAA2B;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,oCAAoC;AAC/D,2BAA2B,oCAAoC;AAC/D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iCAAiC,8BAA8B;;AAE/D;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,8BAA8B;;AAE/D;AACA;AACA,gCAAgC;AAChC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;;AAEA;;AAEA;;AAEA,aAAa;AACb;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;;AAEjB,iCAAiC;AACjC,+CAA+C,SAAS;;AAExD;;AAEA;AACA;;AAEA;;AAEA,uBAAuB;;AAEvB,iCAAiC;;AAEjC;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA,cAAc,OAAO;;AAErB;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA,UAAU,0BAA0B;;AAEpC;AACA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;;AAEA,UAAU,0BAA0B;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,aAAa;AAC9B,kBAAkB,aAAa;AAC/B,gBAAgB;AAChB,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc,wCAAwC;AACtD,cAAc,yCAAyC;AACvD,cAAc,wCAAwC;AACtD,cAAc;AACd;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C;AAC9C,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB,MAAM;;AAEN;AACA,sCAAsC,WAAW;AACjD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,eAAe;AAClD,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iCAAiC,kEAAkE;;AAEnG;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,kEAAkE;;AAEnG;AACA;;AAEA;AACA;;AAEA,iCAAiC,8BAA8B;;AAE/D;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,8BAA8B;;AAE/D;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,aAAa;;AAE9B;AACA;;AAEA;AACA,qBAAqB,gBAAgB;;AAErC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,4CAA4C,SAAS;AACrD;AACA,0BAA0B,YAAY;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,gCAAgC;AAChC;AACA,MAAM;AACN;AACA;;AAEA,8BAA8B;AAC9B;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;;AAEA,oBAAoB;AACpB,gCAAgC;;AAEhC;AACA,gCAAgC;AAChC;AACA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAsE;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE;AAClE,sDAAsD;;AAEtD;AACA,qCAAqC,mGAAmG,EAAE;AAC1I,yCAAyC,sDAAsD,EAAE;AACjG,iCAAiC,2FAA2F,EAAE;AAC9H,mBAAmB,+BAA+B,EAAE;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA,wGAAwG,UAAU;;AAElH;AACA;;AAEA;AACA,6FAA6F,UAAU;;AAEvG;AACA,+DAA+D;;AAE/D,mEAAmE;;AAEnE;AACA;AACA;;AAEA,kFAAkF,UAAU;AAC5F;AACA;;AAEA;;AAEA;AACA,oFAAoF;AACpF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;;AAEA,8CAA8C,UAAU;;AAExD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC;AACrC;AACA;;AAEA;;AAEA;AACA,wDAAwD,sBAAsB;;AAE9E;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,wCAAwC;AACtD,cAAc,mDAAmD;AACjE,cAAc,wCAAwC;AACtD,cAAc,oDAAoD;AAClE,cAAc,yCAAyC;AACvD,cAAc,qDAAqD;AACnE,cAAc,yCAAyC;AACvD,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB;AAClB,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,2BAA2B;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC;AACzC;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,UAAU;AACtB,YAAY,OAAO;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;;AAEjD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;;AAEA,cAAc,iCAAiC;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,YAAY,OAAO;AACnB,eAAe,OAAO;AACtB,aAAa,OAAO;AACpB;AACA,gEAAgE;;AAEhE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,WAAW;;AAErD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA,yBAAyB;;AAEzB;AACA,uDAAuD,cAAc;AACrE;AACA;;AAEA;AACA,uDAAuD,cAAc;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;;AAGA;AACA,+BAA+B,aAAa;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,uBAAuB,kDAAkD;AACzE,qCAAqC,sCAAsC;AAC3E,0CAA0C,wCAAwC;AAClF;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA,6BAA6B;AAC7B,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,4BAA4B,kBAAkB;;AAE9C,0CAA0C,6CAA6C;AACvF,+CAA+C,gDAAgD;AAC/F;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;;AAEA,UAAU;AACV,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;;AAEA,iBAAiB,oCAAoC;AACrD,MAAM;;AAEN;AACA;AACA;;AAEA,uBAAuB,kBAAkB;;AAEzC;AACA,kGAAkG,wDAAwD;;AAE1J;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA,uCAAuC;;AAEvC;AACA,2CAA2C,iEAAiE;AAC5G;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,2BAA2B;AAC3B;AACA,MAAM;;;AAGN;AACA,8CAA8C;AAC9C;;AAEA,mCAAmC,aAAa;AAChD;;AAEA,8CAA8C,aAAa;AAC3D;;AAEA,uCAAuC,kBAAkB;AACzD;AACA;;AAEA,mCAAmC,0BAA0B;AAC7D,4BAA4B;AAC5B;;AAEA,+BAA+B,gBAAgB,iCAAiC;AAChF,wBAAwB;AACxB,MAAM;;AAEN;;AAEA,+BAA+B,aAAa;;AAE5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,OAAO;;AAElD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;;AAEA,kCAAkC,aAAa;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA,uCAAuC,aAAa;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,WAAW;AACxE,UAAU;;AAEV;AACA,MAAM;;AAEN;;AAEA;AACA,yCAAyC,aAAa;;AAEtD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD,gBAAgB;AACrE,qDAAqD,gBAAgB;;AAErE;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,yBAAyB;;AAEzB;;AAEA;AACA;;AAEA;AACA,sEAAsE,4BAA4B;;AAElG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,gCAAgC;AAC5D,oEAAoE,yBAAyB,EAAE,EAAE;AACjG,uDAAuD;;AAEvD;AACA,oDAAoD,UAAU;;AAE9D;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,0BAA0B,qCAAqC;AAC/D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,kDAAkD,kDAAkD;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA,MAAM;;;AAGN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;;AAEA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,2DAA2D,qEAAqE;AAChI;AACA,yGAAyG;AACzG,gCAAgC,eAAe;AAC/C;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,iDAAiD,SAAS,+DAA+D;AACzH;AACA,MAAM;;AAEN;;AAEA,+BAA+B,aAAa;;AAE5C;AACA,qBAAqB,aAAa;;AAElC;AACA;;AAEA;AACA;AACA,8BAA8B,aAAa;;AAE3C;AACA;;AAEA;AACA;;AAEA,uCAAuC;;AAEvC,6CAA6C,SAAS;AACtD;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA,yCAAyC,iCAAiC;AAC1E;AACA,MAAM;;AAEN;;AAEA,kCAAkC,aAAa;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA,yCAAyC,aAAa;;AAEtD;AACA,0EAA0E,aAAa;;AAEvF;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,4DAA4D;;AAErF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,kDAAkD,wBAAwB;AAC1E;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA,8CAA8C;AAC9C;;AAEA,0CAA0C,aAAa;AACvD;;AAEA,qDAAqD,aAAa;AAClE;AACA;;AAEA,wBAAwB;AACxB,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA,MAAM;;AAEN;AACA,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,wBAAwB;AACzD,mBAAmB,4BAA4B,EAAE;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,4BAA4B;AAClD;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA,qBAAqB,aAAa;;AAElC;AACA,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;;AAElC;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;;AAElC;AACA,6DAA6D,oCAAoC;AACjG;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,qBAAqB,UAAU;;AAE/B;AACA,gDAAgD,uBAAuB;AACvE,mCAAmC,wDAAwD;AAC3F;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;;AAElC,4CAA4C,wDAAwD;AACpG,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;AAClC,mCAAmC,iCAAiC;AACpE,qCAAqC,wDAAwD;AAC7F,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;;AAElC,8CAA8C,wDAAwD;AACtG,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;;AAElC,uCAAuC,wDAAwD;AAC/F,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;;AAElC,0CAA0C,wDAAwD;AAClG,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;;AAElC,gDAAgD,wDAAwD;AACxG,MAAM;;AAEN;;AAEA;AACA,qBAAqB,aAAa;;AAElC,0DAA0D,wDAAwD;AAClH,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,wBAAwB,0BAA0B;;AAElD;AACA,2EAA2E;AAC3E,6GAA6G;AAC7G,oEAAoE;;AAEpE;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA,kCAAkC,mEAAmE,EAAE;AACvG,yCAAyC,0EAA0E,EAAE;AACrH;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA,sDAAsD,8BAA8B;AACpF,oCAAoC,6CAA6C;AACjF,oCAAoC,6CAA6C;AACjF;;AAEA;;AAEA;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,oCAAoC,4CAA4C;AAChF;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA,sDAAsD,OAAO;AAC7D;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,wBAAwB,+BAA+B;;AAEvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,uCAAuC;;AAE/D;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA,+BAA+B,uBAAuB;AACtD,MAAM;;AAEN;;AAEA;;AAEA,sCAAsC,QAAQ;;AAE9C;AACA;AACA,yCAAyC,aAAa,GAAG,WAAW;AACpE;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,UAAU;;AAEV;AACA;AACA,kCAAkC,wBAAwB;AAC1D;;AAEA;AACA,MAAM;;AAEN;;AAEA,uCAAuC,QAAQ;;AAE/C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA,yCAAyC,QAAQ;;AAEjD;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,0CAA0C,QAAQ;;AAElD;AACA;AACA,4DAA4D,qCAAqC;;AAEjG;AACA,MAAM;;AAEN;;AAEA,qCAAqC,QAAQ;;AAE7C;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA,sBAAsB;AACtB,6CAA6C,8BAA8B;AAC3E;AACA,MAAM;;AAEN;;AAEA;AACA,4CAA4C,aAAa,GAAG,WAAW;AACvE,MAAM;;AAEN;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,oCAAoC,WAAW;AAC/C;;AAEA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA,uDAAuD,kDAAkD;;AAEzG;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA,qCAAqC,QAAQ;;AAE7C;AACA;AACA;AACA,cAAc;AACd;;AAEA,UAAU;;AAEV,oBAAoB;AACpB;;AAEA,yCAAyC,aAAa,GAAG,WAAW;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,mCAAmC;AAC3F;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,gBAAgB;AAC7G;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oCAAoC,aAAa,GAAG,WAAW;AAC/D,MAAM;;AAEN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,wEAAwE,QAAQ;;AAEhF,oDAAoD,mBAAmB;;AAEvE;AACA;AACA,oCAAoC,WAAW;AAC/C,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,0CAA0C,WAAW;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sCAAsC,oBAAoB;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,OAAO;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6DAA6D,OAAO;AACpE,0DAA0D,2BAA2B;AACrF;AACA;AACA,uCAAuC,4BAA4B;;AAEnE;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA,+CAA+C,OAAO;AACtD;AACA;;AAEA;AACA;AACA,0DAA0D,OAAO;AACjE,yDAAyD,2BAA2B;AACpF;AACA,yCAAyC,4BAA4B;AACrE;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,QAAQ;AAClF;AACA,UAAU;AACV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA,+DAA+D,uDAAuD,EAAE;AACxH,UAAU;AACV,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2CAA2C;AAC1G,mEAAmE,2CAA2C;AAC9G;AACA,iCAAiC,kEAAkE;AACnG,mCAAmC,oEAAoE;AACvG,oCAAoC,8CAA8C;AAClF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA,sCAAsC,WAAW;AACjD;AACA;;AAEA;;AAEA;AACA,2BAA2B,UAAU;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;;AAEA;;AAEA;AACA,sBAAsB,oCAAoC;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,8CAA8C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU,OAAO,OAAO;AACxB,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA,kEAAkE,eAAe;AACjF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,2CAA2C;AACjF;AACA,iDAAiD,eAAe;AAChE;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,8DAA8D,uBAAuB,EAAE;AAC/H;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,0BAA0B;;AAE9D;AACA;AACA;AACA,uCAAuC,qDAAqD;AAC5F,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gCAAgC;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,aAAa;;AAE3C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,6BAA6B,uBAAuB;;AAEpD,kBAAkB,gCAAgC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,kBAAkB,aAAa;AAC/B;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;;AAEA;AACA,kBAAkB,yBAAyB,aAAa;AACxD,4BAA4B,iBAAiB;;AAE7C;AACA,kBAAkB,yBAAyB,eAAe;AAC1D,yBAAyB,iBAAiB;;AAE1C,yBAAyB,iBAAiB;;AAE1C,6BAA6B,0BAA0B;;AAEvD,kCAAkC,eAAe;;AAEjD;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA,gFAAgF;AAChF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV,sDAAsD,EAAE;;AAExD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yBAAyB;AAC3E,MAAM;;AAEN;AACA;AACA;AACA,4BAA4B,IAAI,IAAI;AACpC;AACA;AACA,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV,gDAAgD,cAAc,kBAAkB,EAAE;AAClF;AACA,kCAAkC,gBAAgB,kBAAkB,EAAE;AACtE;AACA,MAAM;;AAEN;AACA;AACA,oBAAoB,2EAA2E;AAC/F,MAAM;;AAEN;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA,wBAAwB,2EAA2E;AACnG;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA,qEAAqE,QAAQ;AAC7E;AACA,MAAM;;AAEN;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,mDAAmD;AACnD;AACA,mCAAmC;AACnC,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA,MAAM;;AAEN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;;AAExC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA,sDAAsD,2BAA2B;AACjF,sDAAsD,2BAA2B;AACjF;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,oDAAoD,cAAc;AAClE;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,yBAAyB;AACzB;AACA;AACA,mEAAmE,QAAQ;AAC3E,uEAAuE,QAAQ;AAC/E;AACA,uBAAuB,oCAAoC;AAC3D,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAqD;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA,6EAA6E,UAAU;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,kDAAkD,wDAAwD,QAAQ;AAClH,MAAM;;AAEN;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA,MAAM;;AAEN;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,kDAAkD;AAClD,MAAM;;AAEN;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA,MAAM;;AAEN;AACA,qCAAqC,QAAQ,iBAAiB;AAC9D;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,sBAAsB;AACtB;AACA;AACA,MAAM;;AAEN;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,+DAA+D,aAAa;AAC5E;AACA;AACA,MAAM;;AAEN;AACA,yBAAyB;AACzB,0BAA0B,uCAAuC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA,oDAAoD,uBAAuB;AAC3E,uDAAuD;AACvD,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,wBAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,MAAM;;AAEN;AACA,0BAA0B;AAC1B;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA,uEAAuE,OAAO;AAC9E;AACA,uCAAuC,UAAU;AACjD;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAA4D,iBAAiB,EAAE;AACvG;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,yBAAyB;AACzB;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA;AACA,qEAAqE,OAAO;AAC5E;AACA,qCAAqC,UAAU;AAC/C;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,qCAAqC;AACrC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD,MAAM;;AAEN;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD,4BAA4B,0BAA0B;AACtD,iBAAiB;AACjB,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;;AAEA,kDAAkD,iBAAiB;AACnE,MAAM;;AAEN;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA,kEAAkE;;AAElE;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,yDAAyD,QAAQ;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC,0CAA0C,OAAO;AACjD;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;;AAE1C;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;AACA,8CAA8C,qBAAqB;AACnE,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA,iCAAiC,GAAG,gBAAgB;AACpD;;AAEA;AACA;;AAEA;AACA,2DAA2D,qBAAqB;AAChF,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA,MAAM;;;AAGN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,4DAA4D,iCAAiC;AAC7F;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,cAAc;AACxE;;AAEA;AACA;AACA,2DAA2D,cAAc;AACzE;;AAEA;AACA,sEAAsE,cAAc;AACpF;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,MAAM;;AAEN;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,qCAAqC,QAAQ;;AAE7C;;AAEA;AACA;;AAEA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yCAAyC,QAAQ;;AAEjD;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,+CAA+C,sBAAsB;;AAErE;;AAEA;AACA,qCAAqC,QAAQ;;AAE7C;;AAEA;AACA;;AAEA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC,QAAQ;;AAE7C;;AAEA;;AAEA;AACA;;AAEA,UAAU;;AAEV,0DAA0D,sBAAsB;;AAEhF;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA,wDAAwD,QAAQ;;AAEhE;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,6CAA6C,gCAAgC;AAC7E;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,qCAAqC,QAAQ;;AAE7C;AACA;;AAEA,UAAU;AACV,0CAA0C,QAAQ,EAAE;AACpD;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,qCAAqC,QAAQ;;AAE7C;AACA;;AAEA,UAAU;AACV,0CAA0C,QAAQ,EAAE;AACpD;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA,UAAU;AACV,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA,UAAU;AACV,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,qCAAqC,QAAQ;;AAE7C;AACA;AACA;;AAEA;AACA;;AAEA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,QAAQ;;AAErD;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;;AAGN;;AAEA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA,+CAA+C,sBAAsB;AACrE;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,QAAQ;;AAEjD;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,2BAA2B;AAC3B,yBAAyB,aAAa,GAAG,0CAA0C;AACnF;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,iCAAiC,gCAAgC;AACjE,6BAA6B;AAC7B;AACA;AACA;AACA,iDAAiD,0DAA0D;AAC3G,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA,+EAA+E;AAC/E;AACA;AACA,UAAU;AACV;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC,cAAc;AACd;;AAEA,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC,cAAc;;AAEd,wFAAwF;;AAExF;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA,4CAA4C,yCAAyC;AACrF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,oBAAoB;;AAE7C;AACA,yBAAyB,qBAAqB;;AAE9C;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA,8CAA8C;;AAE9C;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yFAAyF;AACzF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;;AAEd;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,OAAO,gBAAgB,MAAM,kBAAkB,QAAQ;AACjH;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,iBAAiB;;AAE1D;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAA6C;AAC1E;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,6BAA6B,2DAA2D;AACxF;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,6BAA6B,2DAA2D;AACxF;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,6BAA6B,2DAA2D;AACxF;AACA,UAAU;AACV;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,uCAAuC;AAC3D,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,kBAAkB,wDAAwD;AAC1E,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,iCAAiC,iCAAiC;AAClE;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,qCAAqC,aAAa;AAClD;AACA,kDAAkD,aAAa;AAC/D;AACA,0CAA0C,OAAO;AACjD;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA,yBAAyB;AACzB;AACA,sBAAsB,aAAa;AACnC;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,sBAAsB,aAAa;AACnC,0CAA0C,OAAO;AACjD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,sBAAsB,aAAa;AACnC,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,sBAAsB,aAAa;AACnC,0CAA0C,OAAO;AACjD;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,oCAAoC,gCAAgC;AACpE,4EAA4E,yBAAyB,EAAE,EAAE;AACzG,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,6DAA6D,yBAAyB;AACtF;;AAEA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA,uCAAuC,uEAAuE;;AAE9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA,yBAAyB,2BAA2B;AACpD;AACA,2BAA2B,+BAA+B;AAC1D;AACA,2BAA2B,+BAA+B;AAC1D;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA,0BAA0B,6BAA6B;AACvD;AACA,uBAAuB,2BAA2B;AAClD;AACA,uBAAuB,2BAA2B;;AAElD;AACA;;AAEA;AACA,oCAAoC,iCAAiC;;AAErE;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uCAAuC,EAAE;AAC/E;AACA;AACA;AACA,kBAAkB;;AAElB,4CAA4C,8BAA8B;AAC1E;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,0CAA0C,0EAA0E;;AAEpH;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,OAAO;;AAEtD;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD,OAAO;;AAEvD;AACA;AACA;;AAEA,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB;;AAEjB;;AAEA;AACA;AACA,4CAA4C;AAC5C;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,iCAAiC;AACjC;AACA,UAAU;AACV,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,iCAAiC;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV,uEAAuE,QAAQ;AAC/E,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;AACA;AACA,+BAA+B,sCAAsC;;AAErE;AACA;;AAEA,0BAA0B;AAC1B;AACA,gBAAgB;AAChB,gBAAgB;;AAEhB,2BAA2B,iCAAiC;AAC5D;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;;AAEnE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sCAAsC;AACtC,6CAA6C,+BAA+B;AAC5E;AACA,6BAA6B;AAC7B;AACA,cAAc;AACd;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4EAA4E,gBAAgB;AAC5F,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA,2FAA2F;AAC3F,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA,eAAe,gBAAgB;AAC/B,mBAAmB,yBAAyB;AAC5C,kBAAkB;AAClB;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA,mBAAmB,oDAAoD;AACvE,mBAAmB,6CAA6C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA,mBAAmB,iCAAiC;AACpD,kBAAkB,yFAAyF;AAC3G,gBAAgB;AAChB;AACA,EAAE;;AAEF;AACA;AACA,mBAAmB,iCAAiC;AACpD,kBAAkB,4FAA4F;AAC9G,gBAAgB;AAChB;AACA,EAAE;;AAEF;AACA;AACA,oBAAoB,yEAAyE;AAC7F,qBAAqB;AACrB;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA,qBAAqB,0EAA0E;AAC/F,qBAAqB,0EAA0E;AAC/F,qBAAqB;AACrB;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,aAAa,SAAS,mCAAmC;AACzD,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA,aAAa,SAAS,mCAAmC;AACzD,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA,aAAa,SAAS,mCAAmC;AACzD,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA,aAAa,SAAS,mCAAmC;;AAEzD,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA,aAAa,SAAS,mCAAmC;AACzD,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA,aAAa,SAAS,mCAAmC;AACzD,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA,aAAa,SAAS,mCAAmC;AACzD,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA,aAAa,SAAS,mCAAmC;AACzD,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,yBAAyB,oBAAoB;AAC7C,4BAA4B;AAC5B,MAAM;;AAEN,cAAc,qBAAqB;AACnC,iBAAiB,yBAAyB;AAC1C,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,sBAAsB,oBAAoB,uBAAuB,kBAAkB,6DAA6D,gBAAgB,uBAAuB,2DAA2D,gBAAgB,uBAAuB,0KAA0K,gBAAgB,qBAAqB,uBAAuB,gPAAgP,gBAAgB,6EAA6E,gBAAgB,qFAAqF,gBAAgB,6EAA6E,gBAAgB;AACpsC,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,sBAAsB,oBAAoB,uBAAuB,kBAAkB,mEAAmE,gBAAgB,uBAAuB,gMAAgM,eAAe,qBAAqB,uBAAuB,kPAAkP,gBAAgB,6DAA6D,gBAAgB,uBAAuB,6MAA6M,gBAAgB,uJAAuJ,gBAAgB;AACx0C,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,cAAc,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,sBAAsB,oBAAoB,uBAAuB,kBAAkB,6qBAA6qB,wUAAwU,6EAA6E,iFAAiF;AAC15C,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,cAAc,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,sBAAsB,oBAAoB,uBAAuB,kBAAkB,6BAA6B,aAAa,iaAAia,gBAAgB,yUAAyU,+EAA+E,gBAAgB,qBAAqB,2EAA2E,gBAAgB,uEAAuE,gBAAgB,mFAAmF,gBAAgB,mFAAmF,gBAAgB;AACvhD,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,cAAc,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,sBAAsB,oBAAoB,uBAAuB,kBAAkB,6FAA6F,kGAAkG,iJAAiJ,gJAAgJ,uBAAuB,0HAA0H,gBAAgB,uBAAuB;AAC/5B,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,cAAc,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,sBAAsB,oBAAoB,uBAAuB,kBAAkB,6FAA6F,4GAA4G,kGAAkG,4GAA4G,sBAAsB,wGAAwG,4JAA4J,2EAA2E,gBAAgB,gBAAgB,uBAAuB,iEAAiE,gBAAgB,gBAAgB,uBAAuB,iEAAiE,gBAAgB,gBAAgB,uBAAuB,iEAAiE,gBAAgB,gBAAgB,uBAAuB,6DAA6D,gBAAgB,gBAAgB,uBAAuB;AACthD,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,WAAW,mBAAmB,gBAAgB,gBAAgB,kBAAkB,sBAAsB,uBAAuB,qBAAqB,uBAAuB,kBAAkB,6BAA6B,gBAAgB,qBAAqB,qsBAAqsB,gBAAgB,uBAAuB;AACpjC,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,WAAW,mBAAmB,gBAAgB,gBAAgB,kBAAkB,sBAAsB,uBAAuB,qBAAqB,uBAAuB,kBAAkB,6BAA6B,gBAAgB,qBAAqB,usBAAusB,gBAAgB,uBAAuB;AACtjC,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,WAAW,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,sBAAsB,oBAAoB,uBAAuB,kBAAkB,4GAA4G,gBAAgB,kWAAkW,gBAAgB,+GAA+G,gBAAgB,yKAAyK,gBAAgB;AAC1iC,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,2EAA2E,WAAW,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,sBAAsB,oBAAoB,uBAAuB,kBAAkB,4GAA4G,gBAAgB,kWAAkW,gBAAgB,+GAA+G,gBAAgB,yKAAyK,gBAAgB,oRAAoR,aAAa;AAC30C,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,4aAA4a,cAAc,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,uBAAuB,qBAAqB,uBAAuB,kBAAkB;AAC1mB,EAAE;;AAEF;AACA,YAAY;AACZ,EAAE;AACF,4aAA4a,cAAc,gBAAgB,mBAAmB,gBAAgB,kBAAkB,sBAAsB,uBAAuB,qBAAqB,uBAAuB,kBAAkB;AAC1mB,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA,oBAAoB,kBAAkB;AACtC,gBAAgB;AAChB;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA,oBAAoB,kBAAkB;AACtC,gBAAgB;AAChB;AACA,EAAE;;AAEF;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA,oBAAoB,mBAAmB;AACvC,gBAAgB;AAChB;AACA,EAAE;;AAEF;AACA;AACA,oBAAoB,4BAA4B;AAChD,gBAAgB;AAChB;AACA,EAAE;;AAEF;AACA;AACA,mBAAmB,oBAAoB;AACvC,gBAAgB;AAChB;AACA,EAAE;;AAEF;AACA,aAAa,QAAQ;AACrB,EAAE;;AAEF;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF,wCAAwC;AACxC;AACA,8BAA8B,wBAAwB,QAAQ,wBAAwB;AACtF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,kBAAkB,oBAAoB;AACtC,gBAAgB;AAChB;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,aAAa,oBAAoB,+BAA+B;AAChE;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,YAAY,yBAAyB;AACrC;AACA,gBAAgB,yBAAyB;;AAEzC;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,cAAc,oBAAoB,WAAW,oBAAoB;AACjE,aAAa,iBAAiB,wCAAwC;AACtE;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV,kCAAkC,iCAAiC;;AAEnE,+CAA+C,iCAAiC;AAChF,+CAA+C,iCAAiC;;AAEhF,iDAAiD,iCAAiC;AAClF,iDAAiD,iCAAiC;AAClF,iDAAiD,iCAAiC;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;;AAEA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA,uBAAuB,QAAQ;;AAE/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA,aAAa,oBAAoB;AACjC,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,gBAAgB,eAAe;;AAE/B,kCAAkC,0DAA0D;AAC5F,mCAAmC,0DAA0D;AAC7F,qCAAqC,0DAA0D;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA,cAAc,0CAA0C;AACxD,cAAc,8CAA8C;AAC5D,cAAc;AACd;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,EAAE;;AAEF;AACA;AACA,kCAAkC,kBAAkB;AACpD,mCAAmC,kBAAkB;AACrD,qCAAqC;AACrC;AACA,EAAE;;AAEF;AACA;AACA;;AAEA,EAAE;AACF;;AAEA;AACA;AACA,kCAAkC,kBAAkB;AACpD,mCAAmC,kBAAkB;AACrD,qCAAqC;AACrC;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,aAAa,oBAAoB;AACjC,EAAE;;AAEF;AACA;AACA,4BAA4B,8CAA8C;AAC1E,yBAAyB;AACzB;AACA,EAAE;;AAEF;AACA,aAAa,oBAAoB;AACjC,EAAE;;AAEF;AACA,aAAa,oBAAoB;AACjC,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,MAAM;;AAEN;;AAEA;;AAEA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA,EAAE;;AAEF;AACA;AACA,aAAa,UAAU;AACvB,EAAE;;AAEF;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA,4BAA4B,kEAAkE;AAC9F,yBAAyB;AACzB;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA,qBAAqB,aAAa;AAClC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE,uDAAuD,kBAAkB;AACzE;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,wBAAwB,eAAe;AACvC,MAAM;AACN;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,4CAA4C,OAAO;AACnD;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,MAAM;AACN;AACA;AACA,0BAA0B,0EAA0E;AACpG,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,sDAAsD,2BAA2B;AACjF,wCAAwC,yFAAyF;AACjI,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,+CAA+C,2BAA2B;AAC1E;AACA,wCAAwC,mDAAmD;AAC3F,MAAM;AACN;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD,0CAA0C,QAAQ;AAClD,uEAAuE,2BAA2B;AAClG,+BAA+B,eAAe;AAC9C;AACA,kDAAkD,2BAA2B;AAC7E;AACA,qDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA;AACA,wCAAwC,+CAA+C;AACvF;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D,yCAAyC,mBAAmB;AAC5D;AACA,MAAM;AACN;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,qDAAqD,2BAA2B;AAChF;AACA;AACA,0DAA0D,2BAA2B;AACrF;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,oCAAoC,0BAA0B;AAC9D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,4CAA4C,OAAO;AACnD;AACA;AACA,MAAM;AACN;AACA;AACA,4CAA4C,OAAO,OAAO,mCAAmC;AAC7F,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,2BAA2B;AAC7D;AACA,wCAAwC,oEAAoE;AAC5G,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,4CAA4C,OAAO;AACnD,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,2CAA2C,2BAA2B;AACtE,wCAAwC,uEAAuE;AAC/G,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA;AACA,0CAA0C,2BAA2B;AACrE,wCAAwC,+DAA+D;AACvG;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA,qCAAqC,iBAAiB;AACtD;AACA,MAAM;AACN;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA,yDAAyD,2BAA2B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2BAA2B;AACnF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD,MAAM;AACN;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,qCAAqC;AACrC;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,qCAAqC;AACrC,yCAAyC;AACzC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA,MAAM;AACN;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB;AAC7E,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,yBAAyB,iDAAiD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,2BAA2B;AACtF,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yCAAyC,2BAA2B,EAAE;AACpH,kDAAkD,2BAA2B;AAC7E,MAAM;;AAEN;AACA;AACA,gCAAgC,QAAQ,EAAE;AAC1C,+BAA+B,eAAe,EAAE;AAChD;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,eAAe;AACf;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,cAAc;;AAE7D,CAAC;AACD,mCAAmC,oDAAoD","file":"scripts.js","sourcesContent":["/*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org/license */\n!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.5.1\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:\"jQuery\"+(f+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==o.call(e))&&(!(t=r(e))||\"function\"==typeof(n=v.call(t,\"constructor\")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,\"string\"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),\"function\"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S=\"sizzle\"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",M=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",I=\"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",W=\"\\\\[\"+M+\"*(\"+I+\")(?:\"+M+\"*([*^$|!~]?=)\"+M+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+I+\"))|)\"+M+\"*\\\\]\",F=\":(\"+I+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+W+\")*)|.*)\\\\)|)\",B=new RegExp(M+\"+\",\"g\"),$=new RegExp(\"^\"+M+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+M+\"+$\",\"g\"),_=new RegExp(\"^\"+M+\"*,\"+M+\"*\"),z=new RegExp(\"^\"+M+\"*([>+~]|\"+M+\")\"+M+\"*\"),U=new RegExp(M+\"|>\"),X=new RegExp(F),V=new RegExp(\"^\"+I+\"$\"),G={ID:new RegExp(\"^#(\"+I+\")\"),CLASS:new RegExp(\"^\\\\.(\"+I+\")\"),TAG:new RegExp(\"^(\"+I+\"|[*])\"),ATTR:new RegExp(\"^\"+W),PSEUDO:new RegExp(\"^\"+F),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+M+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+M+\"*(?:([+-]|)\"+M+\"*(\\\\d+)|))\"+M+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+R+\")$\",\"i\"),needsContext:new RegExp(\"^\"+M+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+M+\"*((?:-\\\\d)?\\\\d*)\"+M+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\\d$/i,K=/^[^{]+\\{\\s*\\[native \\w/,Z=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,ee=/[+~]/,te=new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\",\"g\"),ne=function(e,t){var n=\"0x\"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,ie=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&\"fieldset\"===e.nodeName.toLowerCase()},{dir:\"parentNode\",next:\"legend\"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],\"string\"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+\" \"]&&(!v||!v.test(t))&&(1!==p||\"object\"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute(\"id\"))?s=s.replace(re,ie):e.setAttribute(\"id\",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?\"#\"+s:\":scope\")+\" \"+xe(l[o]);c=l.join(\",\")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute(\"id\")}}}return g(t.replace($,\"$1\"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+\" \")>b.cacheLength&&delete e[r.shift()],e[t+\" \"]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split(\"|\"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return\"input\"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return(\"input\"===t||\"button\"===t)&&e.type===n}}function ge(t){return function(e){return\"form\"in e?e.parentNode&&!1===e.disabled?\"label\"in e?\"label\"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:\"label\"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||\"HTML\")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener(\"unload\",oe,!1):n.attachEvent&&n.attachEvent(\"onunload\",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement(\"div\")),\"undefined\"!=typeof e.querySelectorAll&&!e.querySelectorAll(\":scope fieldset div\").length}),d.attributes=ce(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute(\"id\")===t}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return t&&t.value===n}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML=\"<a id='\"+S+\"'></a><select id='\"+S+\"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\",e.querySelectorAll(\"[msallowcapture^='']\").length&&v.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||v.push(\"\\\\[\"+M+\"*(?:value|\"+R+\")\"),e.querySelectorAll(\"[id~=\"+S+\"-]\").length||v.push(\"~=\"),(t=C.createElement(\"input\")).setAttribute(\"name\",\"\"),e.appendChild(t),e.querySelectorAll(\"[name='']\").length||v.push(\"\\\\[\"+M+\"*name\"+M+\"*=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":checked\").length||v.push(\":checked\"),e.querySelectorAll(\"a#\"+S+\"+*\").length||v.push(\".#.+[+~]\"),e.querySelectorAll(\"\\\\\\f\"),v.push(\"[\\\\r\\\\n\\\\f]\")}),ce(function(e){e.innerHTML=\"<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>\";var t=C.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&v.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&v.push(\":enabled\",\":disabled\"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&v.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),v.push(\",.*:\")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,\"*\"),c.call(e,\"[s!='']:x\"),s.push(\"!=\",F)}),v=v.length&&new RegExp(v.join(\"|\")),s=s.length&&new RegExp(s.join(\"|\")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+\" \"]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+\"\").replace(re,ie)},se.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||\"\").replace(te,ne),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&m(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?\"!=\"===r:!r||(t+=\"\",\"=\"===r?t===i:\"!=\"===r?t!==i:\"^=\"===r?i&&0===t.indexOf(i):\"*=\"===r?i&&-1<t.indexOf(i):\"$=\"===r?i&&t.slice(-i.length)===i:\"~=\"===r?-1<(\" \"+t.replace(B,\" \")+\" \").indexOf(i):\"|=\"===r&&(t===i||t.slice(0,i.length+1)===i+\"-\"))}},CHILD:function(h,e,t,g,v){var y=\"nth\"!==h.slice(0,3),m=\"last\"!==h.slice(-4),x=\"of-type\"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?\"nextSibling\":\"previousSibling\",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l=\"only\"===h&&!u&&\"nextSibling\"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error(\"unsupported pseudo: \"+e);return a[S]?a(o):1<a.length?(t=[e,e,\"\",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,\"$1\"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||\"\")||se.error(\"unsupported lang: \"+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute(\"xml:lang\")||e.getAttribute(\"lang\"))return(t=t.toLowerCase())===n||0===t.indexOf(n+\"-\")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&\"parentNode\"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||\"*\",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[\" \"],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:\" \"===e[s-2].type?\"*\":\"\"})).replace($,\"$1\"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+\" \"];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($,\" \")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+\" \"];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l=\"0\",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG(\"*\",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l=\"function\"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&\"ID\"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split(\"\").sort(D).join(\"\")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement(\"fieldset\"))}),ce(function(e){return e.innerHTML=\"<a href='#'></a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||fe(\"type|href|height|width\",function(e,t,n){if(!n)return e.getAttribute(t,\"type\"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML=\"<input/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||fe(\"value\",function(e,t,n){if(!n&&\"input\"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute(\"disabled\")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[\":\"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;function D(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):\"string\"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(D(this,e||[],!1))},not:function(e){return this.pushStack(D(this,e||[],!0))},is:function(e){return!!D(this,\"string\"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var j,q=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||j,\"string\"==typeof e){if(!(r=\"<\"===e[0]&&\">\"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,j=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,\"parentNode\")},parentsUntil:function(e,t,n){return h(e,\"parentNode\",n)},next:function(e){return O(e,\"nextSibling\")},prev:function(e){return O(e,\"previousSibling\")},nextAll:function(e){return h(e,\"nextSibling\")},prevAll:function(e){return h(e,\"previousSibling\")},nextUntil:function(e,t,n){return h(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return h(e,\"previousSibling\",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,\"template\")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return\"Until\"!==r.slice(-5)&&(t=e),t&&\"string\"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\\x20\\t\\r\\n\\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r=\"string\"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:\"\")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&\"string\"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t=\"\",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=\"\"),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[[\"notify\",\"progress\",S.Callbacks(\"memory\"),S.Callbacks(\"memory\"),2],[\"resolve\",\"done\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),1,\"rejected\"]],i=\"pending\",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},\"catch\":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+\"With\"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError(\"Thenable self-resolution\");t=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+\"With\"](this===s?void 0:this,arguments),this},s[t[0]+\"With\"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),\"pending\"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn(\"jQuery.Deferred exception: \"+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener(\"DOMContentLoaded\",B),C.removeEventListener(\"load\",B),S.ready()}S.fn.ready=function(e){return F.then(e)[\"catch\"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,\"complete\"===E.readyState||\"loading\"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener(\"DOMContentLoaded\",B),C.addEventListener(\"load\",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,\"ms-\").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(K,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=\"true\"===(i=n)||\"false\"!==i&&(\"null\"===i?null:i===+i+\"\"?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,\"hasDataAttrs\"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf(\"data-\")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks(\"once memory\").add(function(){Y.remove(e,[t+\"queue\",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return\"string\"!=typeof t&&(n=t,t=\"fx\",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),\"fx\"===t&&\"inprogress\"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=Y.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,te=new RegExp(\"^(?:([+-])=|)(\"+ee+\")([a-z%]*)$\",\"i\"),ne=[\"Top\",\"Right\",\"Bottom\",\"Left\"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&ie(e)&&\"none\"===S.css(e,\"display\")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,\"\")},u=s(),l=n&&n[3]||(S.cssNumber[t]?\"\":\"px\"),c=e.nodeType&&(S.cssNumber[t]||\"px\"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?(\"none\"===n&&(l[c]=Y.get(r,\"display\")||null,l[c]||(r.style.display=\"\")),\"\"===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,\"display\"),o.parentNode.removeChild(o),\"none\"===u&&(u=\"block\"),ue[s]=u)))):\"none\"!==n&&(l[c]=\"none\",Y.set(r,\"display\",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i,he=/^$|^module$|\\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement(\"div\")),(fe=E.createElement(\"input\")).setAttribute(\"type\",\"radio\"),fe.setAttribute(\"checked\",\"checked\"),fe.setAttribute(\"name\",\"t\"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML=\"<textarea>x</textarea>\",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML=\"<option></option>\",y.option=!!ce.lastChild;var ge={thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};function ve(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],\"globalEval\",!t||Y.get(t[n],\"globalEval\"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,\"<select multiple='multiple'>\",\"</select>\"]);var me=/<|&#?\\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(de.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),\"script\"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||\"\")&&n.push(o)}return f}var be=/^key/,we=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Te=/^([^.]*)(?:\\.(.+)|)/;function Ce(){return!0}function Ee(){return!1}function Se(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==(\"focus\"===t)}function ke(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){for(s in\"string\"!=typeof n&&(r=r||n,n=void 0),t)ke(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Ae(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,Ce)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return\"undefined\"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||\"\").match(P)||[\"\"]).length;while(l--)d=g=(s=Te.exec(e[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||\"\").match(P)||[\"\"]).length;while(l--)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,\"handle events\")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,\"events\")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Ae(t,\"click\",Ce),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Ae(t,\"click\"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Y.get(t,\"click\")||A(t,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},S.event.addProp),S.each({focus:\"focusin\",blur:\"focusout\"},function(e,t){S.event.special[e]={setup:function(){return Ae(this,e,Se),!1},trigger:function(){return Ae(this,e),!0},delegateType:t}}),S.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return ke(this,e,t,n,r)},one:function(e,t,n,r){return ke(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){S.event.remove(this,e,n,t)})}});var Ne=/<script|<style|<link/i,De=/checked\\s*(?:[^=]|=\\s*.checked.)/i,je=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function qe(e,t){return A(e,\"table\")&&A(11!==t.nodeType?t:t.firstChild,\"tr\")&&S(e).children(\"tbody\")[0]||e}function Le(e){return e.type=(null!==e.getAttribute(\"type\"))+\"/\"+e.type,e}function He(e){return\"true/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Oe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,\"handle events\"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function Pe(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&\"string\"==typeof d&&!y.checkClone&&De.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Pe(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,\"script\"),Le)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,\"script\"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,He),c=0;c<s;c++)u=a[c],he.test(u.type||\"\")&&!Y.access(u,\"globalEval\")&&S.contains(l,u)&&(u.src&&\"module\"!==(u.type||\"\").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute(\"nonce\")},l):b(u.textContent.replace(je,\"\"),u,l))}return n}function Re(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,\"script\")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,\"input\"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:\"input\"!==l&&\"textarea\"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return 0<(a=ve(c,\"script\")).length&&ye(a,!f&&ve(e,\"script\")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Re(this,e,!0)},remove:function(e){return Re(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!Ne.test(e)&&!ge[(de.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Pe(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Me=new RegExp(\"^(\"+ee+\")(?!px)[a-z%]+$\",\"i\"),Ie=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},We=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Fe=new RegExp(ne.join(\"|\"),\"i\");function Be(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(\"\"!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Me.test(a)&&Fe.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+\"\":a}function $e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",l.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n=\"1%\"!==e.top,s=12===t(e.marginLeft),l.style.right=\"60%\",o=36===t(e.right),r=36===t(e.width),l.style.position=\"absolute\",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement(\"div\"),l=E.createElement(\"div\");l.style&&(l.style.backgroundClip=\"content-box\",l.cloneNode(!0).style.backgroundClip=\"\",y.clearCloneStyle=\"content-box\"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement(\"table\"),t=E.createElement(\"tr\"),n=E.createElement(\"div\"),e.style.cssText=\"position:absolute;left:-11111px\",t.style.height=\"1px\",n.style.height=\"9px\",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=3<parseInt(r.height),re.removeChild(e)),a}}))}();var _e=[\"Webkit\",\"Moz\",\"ms\"],ze=E.createElement(\"div\").style,Ue={};function Xe(e){var t=S.cssProps[e]||Ue[e];return t||(e in ze?e:Ue[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=_e.length;while(n--)if((e=_e[n]+t)in ze)return e}(e)||e)}var Ve=/^(none|table(?!-c[ea]).+)/,Ge=/^--/,Ye={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Qe={letterSpacing:\"0\",fontWeight:\"400\"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function Ke(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?(\"content\"===n&&(u-=S.css(e,\"padding\"+ne[a],!0,i)),\"margin\"!==n&&(u-=S.css(e,\"border\"+ne[a]+\"Width\",!0,i))):(u+=S.css(e,\"padding\"+ne[a],!0,i),\"padding\"!==n?u+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i):s+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Ie(e),i=(!y.boxSizingReliable()||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,r),o=i,a=Be(e,t,r),s=\"offset\"+t[0].toUpperCase()+t.slice(1);if(Me.test(a)){if(!n)return a;a=\"auto\"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,\"tr\")||\"auto\"===a||!parseFloat(a)&&\"inline\"===S.css(e,\"display\",!1,r))&&e.getClientRects().length&&(i=\"border-box\"===S.css(e,\"boxSizing\",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?\"border\":\"content\"),o,r,a)+\"px\"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Ge.test(t),l=e.style;if(u||(t=Xe(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o=\"number\"),null!=n&&n==n&&(\"number\"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?\"\":\"px\")),y.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Ge.test(t)||(t=Xe(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),\"normal\"===i&&t in Qe&&(i=Qe[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each([\"height\",\"width\"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ve.test(S.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):We(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Ie(e),o=!y.scrollboxSize()&&\"absolute\"===i.position,a=(o||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e[\"offset\"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,\"border\",!1,i)-.5)),s&&(r=te.exec(t))&&\"px\"!==(r[3]||\"px\")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=$e(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,\"marginLeft\"))||e.getBoundingClientRect().left-We(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),S.each({margin:\"\",padding:\"\",border:\"Width\"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r=\"string\"==typeof e?e.split(\" \"):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},\"margin\"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?\"\":\"px\")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Xe(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:\"swing\"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=ne[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&\"expand\"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=[\"*\"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,\"fxshow\");for(r in n.queue||(null==(a=S._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,\"fx\").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,\"display\")),\"none\"===(c=S.css(e,\"display\"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,\"display\"),le([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===S.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?\"hidden\"in v&&(g=v.hidden):v=Y.access(e,\"fxshow\",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,\"fxshow\"),d)S.style(e,r,d[r])})),u=ct(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&\"object\"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,\"finish\"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return\"string\"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||\"fx\",[]),this.each(function(){var e=!0,t=null!=i&&i+\"queueHooks\",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||\"fx\"),this.each(function(){var e,t=Y.get(this),n=t[a+\"queue\"],r=t[a+\"queueHooks\"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each([\"toggle\",\"show\",\"hide\"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||\"boolean\"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt(\"show\"),slideUp:lt(\"hide\"),slideToggle:lt(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||\"fx\",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement(\"input\"),it=E.createElement(\"select\").appendChild(E.createElement(\"option\")),rt.type=\"checkbox\",y.checkOn=\"\"!==rt.value,y.optSelected=it.selected,(rt=E.createElement(\"input\")).value=\"t\",rt.type=\"radio\",y.radioValue=\"t\"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&\"radio\"===t&&A(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function vt(e){return(e.match(P)||[]).join(\" \")}function yt(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function mt(e){return Array.isArray(e)?e:\"string\"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,\"tabindex\");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,yt(this)))});if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&\" \"+vt(i)+\" \"){a=0;while(o=e[a++])r.indexOf(\" \"+o+\" \")<0&&(r+=o+\" \");i!==(s=vt(r))&&n.setAttribute(\"class\",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,yt(this)))});if(!arguments.length)return this.attr(\"class\",\"\");if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&\" \"+vt(i)+\" \"){a=0;while(o=e[a++])while(-1<r.indexOf(\" \"+o+\" \"))r=r.replace(\" \"+o+\" \",\" \");i!==(s=vt(r))&&n.setAttribute(\"class\",s)}return this},toggleClass:function(i,t){var o=typeof i,a=\"string\"===o||Array.isArray(i);return\"boolean\"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,yt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=mt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&\"boolean\"!==o||((e=yt(this))&&Y.set(this,\"__className__\",e),this.setAttribute&&this.setAttribute(\"class\",e||!1===i?\"\":Y.get(this,\"__className__\")||\"\"))})},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&-1<(\" \"+vt(yt(n))+\" \").indexOf(t))return!0;return!1}});var xt=/\\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t=\"\":\"number\"==typeof t?t+=\"\":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?\"\":e+\"\"})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&\"set\"in r&&void 0!==r.set(this,t,\"value\")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&\"get\"in r&&void 0!==(e=r.get(t,\"value\"))?e:\"string\"==typeof(e=t.value)?e.replace(xt,\"\"):null==e?\"\":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,\"value\");return null!=t?t:vt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,\"optgroup\"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each([\"radio\",\"checkbox\"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})}),y.focusin=\"onfocusin\"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,\"type\")?e.type:e,h=v.call(e,\"namespace\")?e.namespace.split(\".\"):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(\".\")&&(d=(h=d.split(\".\")).shift(),h.sort()),u=d.indexOf(\":\")<0&&\"on\"+d,(e=e[S.expando]?e:new S.Event(d,\"object\"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join(\".\"),e.rnamespace=e.namespace?new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,\"events\")||Object.create(null))[e.type]&&Y.get(o,\"handle\"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:\"focusin\",blur:\"focusout\"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\\?/;S.parseXML=function(e){var t;if(!e||\"string\"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,\"text/xml\")}catch(e){t=void 0}return t&&!t.getElementsByTagName(\"parsererror\").length||S.error(\"Invalid XML: \"+e),t};var St=/\\[\\]$/,kt=/\\r?\\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function Dt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):Dt(n+\"[\"+(\"object\"==typeof t&&null!=t?e:\"\")+\"]\",t,r,i)});else if(r||\"object\"!==w(e))i(n,e);else for(t in e)Dt(n+\"[\"+t+\"]\",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(null==e)return\"\";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)Dt(n,e[n],t,i);return r.join(\"&\")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,\"elements\");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(\":disabled\")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,\"\\r\\n\")}}):{name:t.name,value:n.replace(kt,\"\\r\\n\")}}).get()}});var jt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \\t]*([^\\r\\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\\/\\//,Rt={},Mt={},It=\"*/\".concat(\"*\"),Wt=E.createElement(\"a\");function Ft(o){return function(e,t){\"string\"!=typeof e&&(t=e,e=\"*\");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])\"+\"===n[0]?(n=n.slice(1)||\"*\",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Bt(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return\"string\"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s[\"*\"]&&l(\"*\")}function $t(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:\"GET\",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":It,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/\\bxml\\b/,html:/\\bhtml/,json:/\\bjson\\b/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?$t($t(e,S.ajaxSettings),t):$t(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){\"object\"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks(\"once memory\"),w=v.statusCode||{},a={},s={},u=\"canceled\",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+\" \"]=(n[t[1].toLowerCase()+\" \"]||[]).concat(t[2])}t=n[e.toLowerCase()+\" \"]}return null==t?null:t.join(\", \")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Tt.href)+\"\").replace(Pt,Tt.protocol+\"//\"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||\"*\").toLowerCase().match(P)||[\"\"],null==v.crossDomain){r=E.createElement(\"a\");try{r.href=v.url,r.href=r.href,v.crossDomain=Wt.protocol+\"//\"+Wt.host!=r.protocol+\"//\"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&\"string\"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Bt(Rt,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger(\"ajaxStart\"),v.type=v.type.toUpperCase(),v.hasContent=!Ot.test(v.type),f=v.url.replace(qt,\"\"),v.hasContent?v.data&&v.processData&&0===(v.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&(v.data=v.data.replace(jt,\"+\")):(o=v.url.slice(f.length),v.data&&(v.processData||\"string\"==typeof v.data)&&(f+=(Et.test(f)?\"&\":\"?\")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Lt,\"$1\"),o=(Et.test(f)?\"&\":\"?\")+\"_=\"+Ct.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader(\"If-Modified-Since\",S.lastModified[f]),S.etag[f]&&T.setRequestHeader(\"If-None-Match\",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader(\"Content-Type\",v.contentType),T.setRequestHeader(\"Accept\",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+(\"*\"!==v.dataTypes[0]?\", \"+It+\"; q=0.01\":\"\"):v.accepts[\"*\"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u=\"abort\",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Bt(Mt,v,t,T)){if(T.readyState=1,g&&m.trigger(\"ajaxSend\",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort(\"timeout\")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,\"No Transport\");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||\"\",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray(\"script\",v.dataTypes)&&(v.converters[\"text script\"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader(\"Last-Modified\"))&&(S.lastModified[f]=u),(u=T.getResponseHeader(\"etag\"))&&(S.etag[f]=u)),204===e||\"HEAD\"===v.type?l=\"nocontent\":304===e?l=\"notmodified\":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l=\"error\",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+\"\",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?\"ajaxSuccess\":\"ajaxError\",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger(\"ajaxComplete\",[T,v]),--S.active||S.event.trigger(\"ajaxStop\")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,\"json\")},getScript:function(e,t){return S.get(e,void 0,t,\"script\")}}),S.each([\"get\",\"post\"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)\"content-type\"===t.toLowerCase()&&(e.contentType=e.headers[t]||\"\")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,converters:{\"text script\":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();y.cors=!!zt&&\"withCredentials\"in zt,y.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(y.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,\"abort\"===e?r.abort():\"error\"===e?\"number\"!=typeof r.status?t(0,\"error\"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,\"text\"!==(r.responseType||\"text\")||\"string\"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o(\"error\"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o(\"abort\");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/\\b(?:java|ecma)script\\b/},converters:{\"text script\":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),S.ajaxTransport(\"script\",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S(\"<script>\").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on(\"load error\",i=function(e){r.remove(),i=null,e&&t(\"error\"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\\?(?=&|$)|\\?\\?/;S.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=Xt.pop()||S.expando+\"_\"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter(\"json jsonp\",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?\"url\":\"string\"==typeof e.data&&0===(e.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Vt.test(e.data)&&\"data\");if(a||\"jsonp\"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,\"$1\"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?\"&\":\"?\")+e.jsonp+\"=\"+r),e.converters[\"script json\"]=function(){return o||S.error(r+\" was not called\"),o[0]},e.dataTypes[0]=\"json\",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),\"script\"}),y.createHTMLDocument=((Ut=E.implementation.createHTMLDocument(\"\").body).innerHTML=\"<form></form><form></form>\",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return\"string\"!=typeof e?[]:(\"boolean\"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return-1<s&&(r=vt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),0<a.length&&S.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?S(\"<div>\").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,\"position\"),c=S(e),f={};\"static\"===l&&(e.style.position=\"relative\"),s=c.offset(),o=S.css(e,\"top\"),u=S.css(e,\"left\"),(\"absolute\"===l||\"fixed\"===l)&&-1<(o+u).indexOf(\"auto\")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),\"using\"in t?t.using.call(e,f):(\"number\"==typeof f.top&&(f.top+=\"px\"),\"number\"==typeof f.left&&(f.left+=\"px\"),c.css(f))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===S.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===S.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,\"borderTopWidth\",!0),i.left+=S.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-S.css(r,\"marginTop\",!0),left:t.left-i.left-S.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===S.css(e,\"position\"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(t,i){var o=\"pageYOffset\"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each([\"top\",\"left\"],function(e,n){S.cssHooks[n]=$e(y.pixelPosition,function(e,t){if(t)return t=Be(e,n),Me.test(t)?S(e).position()[n]+\"px\":t})}),S.each({Height:\"height\",Width:\"width\"},function(a,s){S.each({padding:\"inner\"+a,content:s,\"\":\"outer\"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||\"boolean\"!=typeof e),i=r||(!0===e||!0===t?\"margin\":\"border\");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf(\"outer\")?e[\"inner\"+a]:e.document.documentElement[\"client\"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body[\"scroll\"+a],r[\"scroll\"+a],e.body[\"offset\"+a],r[\"offset\"+a],r[\"client\"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?\"\":(e+\"\").replace(Gt,\"\")},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},\"undefined\"==typeof e&&(C.jQuery=C.$=S),S});\n","/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.20';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('dj vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = _)._ = _;\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n","(function(t){var e=typeof self==\"object\"&&self.self===self&&self||typeof global==\"object\"&&global.global===global&&global;if(typeof define===\"function\"&&define.amd){define([\"underscore\",\"jquery\",\"exports\"],function(i,n,r){e.Backbone=t(e,r,i,n)})}else if(typeof exports!==\"undefined\"){var i=require(\"underscore\"),n;try{n=require(\"jquery\")}catch(r){}t(e,exports,i,n)}else{e.Backbone=t(e,{},e._,e.jQuery||e.Zepto||e.ender||e.$)}})(function(t,e,i,n){var r=t.Backbone;var s=Array.prototype.slice;e.VERSION=\"1.4.0\";e.$=n;e.noConflict=function(){t.Backbone=r;return this};e.emulateHTTP=false;e.emulateJSON=false;var a=e.Events={};var o=/\\s+/;var h;var u=function(t,e,n,r,s){var a=0,h;if(n&&typeof n===\"object\"){if(r!==void 0&&\"context\"in s&&s.context===void 0)s.context=r;for(h=i.keys(n);a<h.length;a++){e=u(t,e,h[a],n[h[a]],s)}}else if(n&&o.test(n)){for(h=n.split(o);a<h.length;a++){e=t(e,h[a],r,s)}}else{e=t(e,n,r,s)}return e};a.on=function(t,e,i){this._events=u(l,this._events||{},t,e,{context:i,ctx:this,listening:h});if(h){var n=this._listeners||(this._listeners={});n[h.id]=h;h.interop=false}return this};a.listenTo=function(t,e,n){if(!t)return this;var r=t._listenId||(t._listenId=i.uniqueId(\"l\"));var s=this._listeningTo||(this._listeningTo={});var a=h=s[r];if(!a){this._listenId||(this._listenId=i.uniqueId(\"l\"));a=h=s[r]=new g(this,t)}var o=c(t,e,n,this);h=void 0;if(o)throw o;if(a.interop)a.on(e,n);return this};var l=function(t,e,i,n){if(i){var r=t[e]||(t[e]=[]);var s=n.context,a=n.ctx,o=n.listening;if(o)o.count++;r.push({callback:i,context:s,ctx:s||a,listening:o})}return t};var c=function(t,e,i,n){try{t.on(e,i,n)}catch(r){return r}};a.off=function(t,e,i){if(!this._events)return this;this._events=u(f,this._events,t,e,{context:i,listeners:this._listeners});return this};a.stopListening=function(t,e,n){var r=this._listeningTo;if(!r)return this;var s=t?[t._listenId]:i.keys(r);for(var a=0;a<s.length;a++){var o=r[s[a]];if(!o)break;o.obj.off(e,n,this);if(o.interop)o.off(e,n)}if(i.isEmpty(r))this._listeningTo=void 0;return this};var f=function(t,e,n,r){if(!t)return;var s=r.context,a=r.listeners;var o=0,h;if(!e&&!s&&!n){for(h=i.keys(a);o<h.length;o++){a[h[o]].cleanup()}return}h=e?[e]:i.keys(t);for(;o<h.length;o++){e=h[o];var u=t[e];if(!u)break;var l=[];for(var c=0;c<u.length;c++){var f=u[c];if(n&&n!==f.callback&&n!==f.callback._callback||s&&s!==f.context){l.push(f)}else{var d=f.listening;if(d)d.off(e,n)}}if(l.length){t[e]=l}else{delete t[e]}}return t};a.once=function(t,e,i){var n=u(d,{},t,e,this.off.bind(this));if(typeof t===\"string\"&&i==null)e=void 0;return this.on(n,e,i)};a.listenToOnce=function(t,e,i){var n=u(d,{},e,i,this.stopListening.bind(this,t));return this.listenTo(t,n)};var d=function(t,e,n,r){if(n){var s=t[e]=i.once(function(){r(e,s);n.apply(this,arguments)});s._callback=n}return t};a.trigger=function(t){if(!this._events)return this;var e=Math.max(0,arguments.length-1);var i=Array(e);for(var n=0;n<e;n++)i[n]=arguments[n+1];u(v,this._events,t,void 0,i);return this};var v=function(t,e,i,n){if(t){var r=t[e];var s=t.all;if(r&&s)s=s.slice();if(r)p(r,n);if(s)p(s,[e].concat(n))}return t};var p=function(t,e){var i,n=-1,r=t.length,s=e[0],a=e[1],o=e[2];switch(e.length){case 0:while(++n<r)(i=t[n]).callback.call(i.ctx);return;case 1:while(++n<r)(i=t[n]).callback.call(i.ctx,s);return;case 2:while(++n<r)(i=t[n]).callback.call(i.ctx,s,a);return;case 3:while(++n<r)(i=t[n]).callback.call(i.ctx,s,a,o);return;default:while(++n<r)(i=t[n]).callback.apply(i.ctx,e);return}};var g=function(t,e){this.id=t._listenId;this.listener=t;this.obj=e;this.interop=true;this.count=0;this._events=void 0};g.prototype.on=a.on;g.prototype.off=function(t,e){var i;if(this.interop){this._events=u(f,this._events,t,e,{context:void 0,listeners:void 0});i=!this._events}else{this.count--;i=this.count===0}if(i)this.cleanup()};g.prototype.cleanup=function(){delete this.listener._listeningTo[this.obj._listenId];if(!this.interop)delete this.obj._listeners[this.id]};a.bind=a.on;a.unbind=a.off;i.extend(e,a);var m=e.Model=function(t,e){var n=t||{};e||(e={});this.preinitialize.apply(this,arguments);this.cid=i.uniqueId(this.cidPrefix);this.attributes={};if(e.collection)this.collection=e.collection;if(e.parse)n=this.parse(n,e)||{};var r=i.result(this,\"defaults\");n=i.defaults(i.extend({},r,n),r);this.set(n,e);this.changed={};this.initialize.apply(this,arguments)};i.extend(m.prototype,a,{changed:null,validationError:null,idAttribute:\"id\",cidPrefix:\"c\",preinitialize:function(){},initialize:function(){},toJSON:function(t){return i.clone(this.attributes)},sync:function(){return e.sync.apply(this,arguments)},get:function(t){return this.attributes[t]},escape:function(t){return i.escape(this.get(t))},has:function(t){return this.get(t)!=null},matches:function(t){return!!i.iteratee(t,this)(this.attributes)},set:function(t,e,n){if(t==null)return this;var r;if(typeof t===\"object\"){r=t;n=e}else{(r={})[t]=e}n||(n={});if(!this._validate(r,n))return false;var s=n.unset;var a=n.silent;var o=[];var h=this._changing;this._changing=true;if(!h){this._previousAttributes=i.clone(this.attributes);this.changed={}}var u=this.attributes;var l=this.changed;var c=this._previousAttributes;for(var f in r){e=r[f];if(!i.isEqual(u[f],e))o.push(f);if(!i.isEqual(c[f],e)){l[f]=e}else{delete l[f]}s?delete u[f]:u[f]=e}if(this.idAttribute in r)this.id=this.get(this.idAttribute);if(!a){if(o.length)this._pending=n;for(var d=0;d<o.length;d++){this.trigger(\"change:\"+o[d],this,u[o[d]],n)}}if(h)return this;if(!a){while(this._pending){n=this._pending;this._pending=false;this.trigger(\"change\",this,n)}}this._pending=false;this._changing=false;return this},unset:function(t,e){return this.set(t,void 0,i.extend({},e,{unset:true}))},clear:function(t){var e={};for(var n in this.attributes)e[n]=void 0;return this.set(e,i.extend({},t,{unset:true}))},hasChanged:function(t){if(t==null)return!i.isEmpty(this.changed);return i.has(this.changed,t)},changedAttributes:function(t){if(!t)return this.hasChanged()?i.clone(this.changed):false;var e=this._changing?this._previousAttributes:this.attributes;var n={};var r;for(var s in t){var a=t[s];if(i.isEqual(e[s],a))continue;n[s]=a;r=true}return r?n:false},previous:function(t){if(t==null||!this._previousAttributes)return null;return this._previousAttributes[t]},previousAttributes:function(){return i.clone(this._previousAttributes)},fetch:function(t){t=i.extend({parse:true},t);var e=this;var n=t.success;t.success=function(i){var r=t.parse?e.parse(i,t):i;if(!e.set(r,t))return false;if(n)n.call(t.context,e,i,t);e.trigger(\"sync\",e,i,t)};G(this,t);return this.sync(\"read\",this,t)},save:function(t,e,n){var r;if(t==null||typeof t===\"object\"){r=t;n=e}else{(r={})[t]=e}n=i.extend({validate:true,parse:true},n);var s=n.wait;if(r&&!s){if(!this.set(r,n))return false}else if(!this._validate(r,n)){return false}var a=this;var o=n.success;var h=this.attributes;n.success=function(t){a.attributes=h;var e=n.parse?a.parse(t,n):t;if(s)e=i.extend({},r,e);if(e&&!a.set(e,n))return false;if(o)o.call(n.context,a,t,n);a.trigger(\"sync\",a,t,n)};G(this,n);if(r&&s)this.attributes=i.extend({},h,r);var u=this.isNew()?\"create\":n.patch?\"patch\":\"update\";if(u===\"patch\"&&!n.attrs)n.attrs=r;var l=this.sync(u,this,n);this.attributes=h;return l},destroy:function(t){t=t?i.clone(t):{};var e=this;var n=t.success;var r=t.wait;var s=function(){e.stopListening();e.trigger(\"destroy\",e,e.collection,t)};t.success=function(i){if(r)s();if(n)n.call(t.context,e,i,t);if(!e.isNew())e.trigger(\"sync\",e,i,t)};var a=false;if(this.isNew()){i.defer(t.success)}else{G(this,t);a=this.sync(\"delete\",this,t)}if(!r)s();return a},url:function(){var t=i.result(this,\"urlRoot\")||i.result(this.collection,\"url\")||V();if(this.isNew())return t;var e=this.get(this.idAttribute);return t.replace(/[^\\/]$/,\"$&/\")+encodeURIComponent(e)},parse:function(t,e){return t},clone:function(){return new this.constructor(this.attributes)},isNew:function(){return!this.has(this.idAttribute)},isValid:function(t){return this._validate({},i.extend({},t,{validate:true}))},_validate:function(t,e){if(!e.validate||!this.validate)return true;t=i.extend({},this.attributes,t);var n=this.validationError=this.validate(t,e)||null;if(!n)return true;this.trigger(\"invalid\",this,n,i.extend(e,{validationError:n}));return false}});var _=e.Collection=function(t,e){e||(e={});this.preinitialize.apply(this,arguments);if(e.model)this.model=e.model;if(e.comparator!==void 0)this.comparator=e.comparator;this._reset();this.initialize.apply(this,arguments);if(t)this.reset(t,i.extend({silent:true},e))};var y={add:true,remove:true,merge:true};var b={add:true,remove:false};var x=function(t,e,i){i=Math.min(Math.max(i,0),t.length);var n=Array(t.length-i);var r=e.length;var s;for(s=0;s<n.length;s++)n[s]=t[s+i];for(s=0;s<r;s++)t[s+i]=e[s];for(s=0;s<n.length;s++)t[s+r+i]=n[s]};i.extend(_.prototype,a,{model:m,preinitialize:function(){},initialize:function(){},toJSON:function(t){return this.map(function(e){return e.toJSON(t)})},sync:function(){return e.sync.apply(this,arguments)},add:function(t,e){return this.set(t,i.extend({merge:false},e,b))},remove:function(t,e){e=i.extend({},e);var n=!i.isArray(t);t=n?[t]:t.slice();var r=this._removeModels(t,e);if(!e.silent&&r.length){e.changes={added:[],merged:[],removed:r};this.trigger(\"update\",this,e)}return n?r[0]:r},set:function(t,e){if(t==null)return;e=i.extend({},y,e);if(e.parse&&!this._isModel(t)){t=this.parse(t,e)||[]}var n=!i.isArray(t);t=n?[t]:t.slice();var r=e.at;if(r!=null)r=+r;if(r>this.length)r=this.length;if(r<0)r+=this.length+1;var s=[];var a=[];var o=[];var h=[];var u={};var l=e.add;var c=e.merge;var f=e.remove;var d=false;var v=this.comparator&&r==null&&e.sort!==false;var p=i.isString(this.comparator)?this.comparator:null;var g,m;for(m=0;m<t.length;m++){g=t[m];var _=this.get(g);if(_){if(c&&g!==_){var b=this._isModel(g)?g.attributes:g;if(e.parse)b=_.parse(b,e);_.set(b,e);o.push(_);if(v&&!d)d=_.hasChanged(p)}if(!u[_.cid]){u[_.cid]=true;s.push(_)}t[m]=_}else if(l){g=t[m]=this._prepareModel(g,e);if(g){a.push(g);this._addReference(g,e);u[g.cid]=true;s.push(g)}}}if(f){for(m=0;m<this.length;m++){g=this.models[m];if(!u[g.cid])h.push(g)}if(h.length)this._removeModels(h,e)}var w=false;var E=!v&&l&&f;if(s.length&&E){w=this.length!==s.length||i.some(this.models,function(t,e){return t!==s[e]});this.models.length=0;x(this.models,s,0);this.length=this.models.length}else if(a.length){if(v)d=true;x(this.models,a,r==null?this.length:r);this.length=this.models.length}if(d)this.sort({silent:true});if(!e.silent){for(m=0;m<a.length;m++){if(r!=null)e.index=r+m;g=a[m];g.trigger(\"add\",g,this,e)}if(d||w)this.trigger(\"sort\",this,e);if(a.length||h.length||o.length){e.changes={added:a,removed:h,merged:o};this.trigger(\"update\",this,e)}}return n?t[0]:t},reset:function(t,e){e=e?i.clone(e):{};for(var n=0;n<this.models.length;n++){this._removeReference(this.models[n],e)}e.previousModels=this.models;this._reset();t=this.add(t,i.extend({silent:true},e));if(!e.silent)this.trigger(\"reset\",this,e);return t},push:function(t,e){return this.add(t,i.extend({at:this.length},e))},pop:function(t){var e=this.at(this.length-1);return this.remove(e,t)},unshift:function(t,e){return this.add(t,i.extend({at:0},e))},shift:function(t){var e=this.at(0);return this.remove(e,t)},slice:function(){return s.apply(this.models,arguments)},get:function(t){if(t==null)return void 0;return this._byId[t]||this._byId[this.modelId(this._isModel(t)?t.attributes:t)]||t.cid&&this._byId[t.cid]},has:function(t){return this.get(t)!=null},at:function(t){if(t<0)t+=this.length;return this.models[t]},where:function(t,e){return this[e?\"find\":\"filter\"](t)},findWhere:function(t){return this.where(t,true)},sort:function(t){var e=this.comparator;if(!e)throw new Error(\"Cannot sort a set without a comparator\");t||(t={});var n=e.length;if(i.isFunction(e))e=e.bind(this);if(n===1||i.isString(e)){this.models=this.sortBy(e)}else{this.models.sort(e)}if(!t.silent)this.trigger(\"sort\",this,t);return this},pluck:function(t){return this.map(t+\"\")},fetch:function(t){t=i.extend({parse:true},t);var e=t.success;var n=this;t.success=function(i){var r=t.reset?\"reset\":\"set\";n[r](i,t);if(e)e.call(t.context,n,i,t);n.trigger(\"sync\",n,i,t)};G(this,t);return this.sync(\"read\",this,t)},create:function(t,e){e=e?i.clone(e):{};var n=e.wait;t=this._prepareModel(t,e);if(!t)return false;if(!n)this.add(t,e);var r=this;var s=e.success;e.success=function(t,e,i){if(n)r.add(t,i);if(s)s.call(i.context,t,e,i)};t.save(null,e);return t},parse:function(t,e){return t},clone:function(){return new this.constructor(this.models,{model:this.model,comparator:this.comparator})},modelId:function(t){return t[this.model.prototype.idAttribute||\"id\"]},values:function(){return new E(this,k)},keys:function(){return new E(this,I)},entries:function(){return new E(this,S)},_reset:function(){this.length=0;this.models=[];this._byId={}},_prepareModel:function(t,e){if(this._isModel(t)){if(!t.collection)t.collection=this;return t}e=e?i.clone(e):{};e.collection=this;var n=new this.model(t,e);if(!n.validationError)return n;this.trigger(\"invalid\",this,n.validationError,e);return false},_removeModels:function(t,e){var i=[];for(var n=0;n<t.length;n++){var r=this.get(t[n]);if(!r)continue;var s=this.indexOf(r);this.models.splice(s,1);this.length--;delete this._byId[r.cid];var a=this.modelId(r.attributes);if(a!=null)delete this._byId[a];if(!e.silent){e.index=s;r.trigger(\"remove\",r,this,e)}i.push(r);this._removeReference(r,e)}return i},_isModel:function(t){return t instanceof m},_addReference:function(t,e){this._byId[t.cid]=t;var i=this.modelId(t.attributes);if(i!=null)this._byId[i]=t;t.on(\"all\",this._onModelEvent,this)},_removeReference:function(t,e){delete this._byId[t.cid];var i=this.modelId(t.attributes);if(i!=null)delete this._byId[i];if(this===t.collection)delete t.collection;t.off(\"all\",this._onModelEvent,this)},_onModelEvent:function(t,e,i,n){if(e){if((t===\"add\"||t===\"remove\")&&i!==this)return;if(t===\"destroy\")this.remove(e,n);if(t===\"change\"){var r=this.modelId(e.previousAttributes());var s=this.modelId(e.attributes);if(r!==s){if(r!=null)delete this._byId[r];if(s!=null)this._byId[s]=e}}}this.trigger.apply(this,arguments)}});var w=typeof Symbol===\"function\"&&Symbol.iterator;if(w){_.prototype[w]=_.prototype.values}var E=function(t,e){this._collection=t;this._kind=e;this._index=0};var k=1;var I=2;var S=3;if(w){E.prototype[w]=function(){return this}}E.prototype.next=function(){if(this._collection){if(this._index<this._collection.length){var t=this._collection.at(this._index);this._index++;var e;if(this._kind===k){e=t}else{var i=this._collection.modelId(t.attributes);if(this._kind===I){e=i}else{e=[i,t]}}return{value:e,done:false}}this._collection=void 0}return{value:void 0,done:true}};var T=e.View=function(t){this.cid=i.uniqueId(\"view\");this.preinitialize.apply(this,arguments);i.extend(this,i.pick(t,H));this._ensureElement();this.initialize.apply(this,arguments)};var P=/^(\\S+)\\s*(.*)$/;var H=[\"model\",\"collection\",\"el\",\"id\",\"attributes\",\"className\",\"tagName\",\"events\"];i.extend(T.prototype,a,{tagName:\"div\",$:function(t){return this.$el.find(t)},preinitialize:function(){},initialize:function(){},render:function(){return this},remove:function(){this._removeElement();this.stopListening();return this},_removeElement:function(){this.$el.remove()},setElement:function(t){this.undelegateEvents();this._setElement(t);this.delegateEvents();return this},_setElement:function(t){this.$el=t instanceof e.$?t:e.$(t);this.el=this.$el[0]},delegateEvents:function(t){t||(t=i.result(this,\"events\"));if(!t)return this;this.undelegateEvents();for(var e in t){var n=t[e];if(!i.isFunction(n))n=this[n];if(!n)continue;var r=e.match(P);this.delegate(r[1],r[2],n.bind(this))}return this},delegate:function(t,e,i){this.$el.on(t+\".delegateEvents\"+this.cid,e,i);return this},undelegateEvents:function(){if(this.$el)this.$el.off(\".delegateEvents\"+this.cid);return this},undelegate:function(t,e,i){this.$el.off(t+\".delegateEvents\"+this.cid,e,i);return this},_createElement:function(t){return document.createElement(t)},_ensureElement:function(){if(!this.el){var t=i.extend({},i.result(this,\"attributes\"));if(this.id)t.id=i.result(this,\"id\");if(this.className)t[\"class\"]=i.result(this,\"className\");this.setElement(this._createElement(i.result(this,\"tagName\")));this._setAttributes(t)}else{this.setElement(i.result(this,\"el\"))}},_setAttributes:function(t){this.$el.attr(t)}});var $=function(t,e,i,n){switch(e){case 1:return function(){return t[i](this[n])};case 2:return function(e){return t[i](this[n],e)};case 3:return function(e,r){return t[i](this[n],C(e,this),r)};case 4:return function(e,r,s){return t[i](this[n],C(e,this),r,s)};default:return function(){var e=s.call(arguments);e.unshift(this[n]);return t[i].apply(t,e)}}};var A=function(t,e,n,r){i.each(n,function(i,n){if(e[n])t.prototype[n]=$(e,i,n,r)})};var C=function(t,e){if(i.isFunction(t))return t;if(i.isObject(t)&&!e._isModel(t))return R(t);if(i.isString(t))return function(e){return e.get(t)};return t};var R=function(t){var e=i.matches(t);return function(t){return e(t.attributes)}};var M={forEach:3,each:3,map:3,collect:3,reduce:0,foldl:0,inject:0,reduceRight:0,foldr:0,find:3,detect:3,filter:3,select:3,reject:3,every:3,all:3,some:3,any:3,include:3,includes:3,contains:3,invoke:0,max:3,min:3,toArray:1,size:1,first:3,head:3,take:3,initial:3,rest:3,tail:3,drop:3,last:3,without:0,difference:0,indexOf:3,shuffle:1,lastIndexOf:3,isEmpty:1,chain:1,sample:3,partition:3,groupBy:3,countBy:3,sortBy:3,indexBy:3,findIndex:3,findLastIndex:3};var N={keys:1,values:1,pairs:1,invert:1,pick:0,omit:0,chain:1,isEmpty:1};i.each([[_,M,\"models\"],[m,N,\"attributes\"]],function(t){var e=t[0],n=t[1],r=t[2];e.mixin=function(t){var n=i.reduce(i.functions(t),function(t,e){t[e]=0;return t},{});A(e,t,n,r)};A(e,i,n,r)});e.sync=function(t,n,r){var s=j[t];i.defaults(r||(r={}),{emulateHTTP:e.emulateHTTP,emulateJSON:e.emulateJSON});var a={type:s,dataType:\"json\"};if(!r.url){a.url=i.result(n,\"url\")||V()}if(r.data==null&&n&&(t===\"create\"||t===\"update\"||t===\"patch\")){a.contentType=\"application/json\";a.data=JSON.stringify(r.attrs||n.toJSON(r))}if(r.emulateJSON){a.contentType=\"application/x-www-form-urlencoded\";a.data=a.data?{model:a.data}:{}}if(r.emulateHTTP&&(s===\"PUT\"||s===\"DELETE\"||s===\"PATCH\")){a.type=\"POST\";if(r.emulateJSON)a.data._method=s;var o=r.beforeSend;r.beforeSend=function(t){t.setRequestHeader(\"X-HTTP-Method-Override\",s);if(o)return o.apply(this,arguments)}}if(a.type!==\"GET\"&&!r.emulateJSON){a.processData=false}var h=r.error;r.error=function(t,e,i){r.textStatus=e;r.errorThrown=i;if(h)h.call(r.context,t,e,i)};var u=r.xhr=e.ajax(i.extend(a,r));n.trigger(\"request\",n,u,r);return u};var j={create:\"POST\",update:\"PUT\",patch:\"PATCH\",\"delete\":\"DELETE\",read:\"GET\"};e.ajax=function(){return e.$.ajax.apply(e.$,arguments)};var O=e.Router=function(t){t||(t={});this.preinitialize.apply(this,arguments);if(t.routes)this.routes=t.routes;this._bindRoutes();this.initialize.apply(this,arguments)};var U=/\\((.*?)\\)/g;var z=/(\\(\\?)?:\\w+/g;var q=/\\*\\w+/g;var F=/[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;i.extend(O.prototype,a,{preinitialize:function(){},initialize:function(){},route:function(t,n,r){if(!i.isRegExp(t))t=this._routeToRegExp(t);if(i.isFunction(n)){r=n;n=\"\"}if(!r)r=this[n];var s=this;e.history.route(t,function(i){var a=s._extractParameters(t,i);if(s.execute(r,a,n)!==false){s.trigger.apply(s,[\"route:\"+n].concat(a));s.trigger(\"route\",n,a);e.history.trigger(\"route\",s,n,a)}});return this},execute:function(t,e,i){if(t)t.apply(this,e)},navigate:function(t,i){e.history.navigate(t,i);return this},_bindRoutes:function(){if(!this.routes)return;this.routes=i.result(this,\"routes\");var t,e=i.keys(this.routes);while((t=e.pop())!=null){this.route(t,this.routes[t])}},_routeToRegExp:function(t){t=t.replace(F,\"\\\\$&\").replace(U,\"(?:$1)?\").replace(z,function(t,e){return e?t:\"([^/?]+)\"}).replace(q,\"([^?]*?)\");return new RegExp(\"^\"+t+\"(?:\\\\?([\\\\s\\\\S]*))?$\")},_extractParameters:function(t,e){var n=t.exec(e).slice(1);return i.map(n,function(t,e){if(e===n.length-1)return t||null;return t?decodeURIComponent(t):null})}});var B=e.History=function(){this.handlers=[];this.checkUrl=this.checkUrl.bind(this);if(typeof window!==\"undefined\"){this.location=window.location;this.history=window.history}};var J=/^[#\\/]|\\s+$/g;var L=/^\\/+|\\/+$/g;var W=/#.*$/;B.started=false;i.extend(B.prototype,a,{interval:50,atRoot:function(){var t=this.location.pathname.replace(/[^\\/]$/,\"$&/\");return t===this.root&&!this.getSearch()},matchRoot:function(){var t=this.decodeFragment(this.location.pathname);var e=t.slice(0,this.root.length-1)+\"/\";return e===this.root},decodeFragment:function(t){return decodeURI(t.replace(/%25/g,\"%2525\"))},getSearch:function(){var t=this.location.href.replace(/#.*/,\"\").match(/\\?.+/);return t?t[0]:\"\"},getHash:function(t){var e=(t||this).location.href.match(/#(.*)$/);return e?e[1]:\"\"},getPath:function(){var t=this.decodeFragment(this.location.pathname+this.getSearch()).slice(this.root.length-1);return t.charAt(0)===\"/\"?t.slice(1):t},getFragment:function(t){if(t==null){if(this._usePushState||!this._wantsHashChange){t=this.getPath()}else{t=this.getHash()}}return t.replace(J,\"\")},start:function(t){if(B.started)throw new Error(\"Backbone.history has already been started\");B.started=true;this.options=i.extend({root:\"/\"},this.options,t);this.root=this.options.root;this._wantsHashChange=this.options.hashChange!==false;this._hasHashChange=\"onhashchange\"in window&&(document.documentMode===void 0||document.documentMode>7);this._useHashChange=this._wantsHashChange&&this._hasHashChange;this._wantsPushState=!!this.options.pushState;this._hasPushState=!!(this.history&&this.history.pushState);this._usePushState=this._wantsPushState&&this._hasPushState;this.fragment=this.getFragment();this.root=(\"/\"+this.root+\"/\").replace(L,\"/\");if(this._wantsHashChange&&this._wantsPushState){if(!this._hasPushState&&!this.atRoot()){var e=this.root.slice(0,-1)||\"/\";this.location.replace(e+\"#\"+this.getPath());return true}else if(this._hasPushState&&this.atRoot()){this.navigate(this.getHash(),{replace:true})}}if(!this._hasHashChange&&this._wantsHashChange&&!this._usePushState){this.iframe=document.createElement(\"iframe\");this.iframe.src=\"javascript:0\";this.iframe.style.display=\"none\";this.iframe.tabIndex=-1;var n=document.body;var r=n.insertBefore(this.iframe,n.firstChild).contentWindow;r.document.open();r.document.close();r.location.hash=\"#\"+this.fragment}var s=window.addEventListener||function(t,e){return attachEvent(\"on\"+t,e)};if(this._usePushState){s(\"popstate\",this.checkUrl,false)}else if(this._useHashChange&&!this.iframe){s(\"hashchange\",this.checkUrl,false)}else if(this._wantsHashChange){this._checkUrlInterval=setInterval(this.checkUrl,this.interval)}if(!this.options.silent)return this.loadUrl()},stop:function(){var t=window.removeEventListener||function(t,e){return detachEvent(\"on\"+t,e)};if(this._usePushState){t(\"popstate\",this.checkUrl,false)}else if(this._useHashChange&&!this.iframe){t(\"hashchange\",this.checkUrl,false)}if(this.iframe){document.body.removeChild(this.iframe);this.iframe=null}if(this._checkUrlInterval)clearInterval(this._checkUrlInterval);B.started=false},route:function(t,e){this.handlers.unshift({route:t,callback:e})},checkUrl:function(t){var e=this.getFragment();if(e===this.fragment&&this.iframe){e=this.getHash(this.iframe.contentWindow)}if(e===this.fragment)return false;if(this.iframe)this.navigate(e);this.loadUrl()},loadUrl:function(t){if(!this.matchRoot())return false;t=this.fragment=this.getFragment(t);return i.some(this.handlers,function(e){if(e.route.test(t)){e.callback(t);return true}})},navigate:function(t,e){if(!B.started)return false;if(!e||e===true)e={trigger:!!e};t=this.getFragment(t||\"\");var i=this.root;if(t===\"\"||t.charAt(0)===\"?\"){i=i.slice(0,-1)||\"/\"}var n=i+t;t=t.replace(W,\"\");var r=this.decodeFragment(t);if(this.fragment===r)return;this.fragment=r;if(this._usePushState){this.history[e.replace?\"replaceState\":\"pushState\"]({},document.title,n)}else if(this._wantsHashChange){this._updateHash(this.location,t,e.replace);if(this.iframe&&t!==this.getHash(this.iframe.contentWindow)){var s=this.iframe.contentWindow;if(!e.replace){s.document.open();s.document.close()}this._updateHash(s.location,t,e.replace)}}else{return this.location.assign(n)}if(e.trigger)return this.loadUrl(t)},_updateHash:function(t,e,i){if(i){var n=t.href.replace(/(javascript:|#).*$/,\"\");t.replace(n+\"#\"+e)}else{t.hash=\"#\"+e}}});e.history=new B;var D=function(t,e){var n=this;var r;if(t&&i.has(t,\"constructor\")){r=t.constructor}else{r=function(){return n.apply(this,arguments)}}i.extend(r,n,e);r.prototype=i.create(n.prototype,t);r.prototype.constructor=r;r.__super__=n.prototype;return r};m.extend=_.extend=O.extend=T.extend=B.extend=D;var V=function(){throw new Error('A \"url\" property or function must be specified')};var G=function(t,e){var i=e.error;e.error=function(n){if(i)i.call(e.context,t,n,e);t.trigger(\"error\",t,n,e)}};return e});\n//# sourceMappingURL=backbone-min.map","/*! JointJS v3.3.1 (2021-02-06) - JavaScript diagramming library\n\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n*/\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('backbone'), require('lodash'), require('jquery')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'backbone', 'lodash', 'jquery'], factory) :\n\t(global = global || self, factory(global.joint = {}, global.Backbone, global._, global.$));\n}(this, function (exports, Backbone, _, $) { 'use strict';\n\n\tBackbone = Backbone && Backbone.hasOwnProperty('default') ? Backbone['default'] : Backbone;\n\t_ = _ && _.hasOwnProperty('default') ? _['default'] : _;\n\t$ = $ && $.hasOwnProperty('default') ? $['default'] : $;\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction commonjsRequire () {\n\t\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n\t}\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n.default || n;\n\t}\n\n\tvar check = function (it) {\n\t  return it && it.Math == Math && it;\n\t};\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global_1 =\n\t  // eslint-disable-next-line no-undef\n\t  check(typeof globalThis == 'object' && globalThis) ||\n\t  check(typeof window == 'object' && window) ||\n\t  check(typeof self == 'object' && self) ||\n\t  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n\t  // eslint-disable-next-line no-new-func\n\t  (function () { return this; })() || Function('return this')();\n\n\tvar fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t};\n\n\t// Detect IE8's incomplete defineProperty implementation\n\tvar descriptors = !fails(function () {\n\t  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n\t});\n\n\t'use strict';\n\tvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n\tvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// Nashorn ~ JDK8 bug\n\tvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n\t// `Object.prototype.propertyIsEnumerable` method implementation\n\t// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n\tvar f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n\t  var descriptor = getOwnPropertyDescriptor(this, V);\n\t  return !!descriptor && descriptor.enumerable;\n\t} : nativePropertyIsEnumerable;\n\n\tvar objectPropertyIsEnumerable = {\n\t\tf: f\n\t};\n\n\tvar createPropertyDescriptor = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar toString = {}.toString;\n\n\tvar classofRaw = function (it) {\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n\tvar split = ''.split;\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar indexedObject = fails(function () {\n\t  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n\t  // eslint-disable-next-line no-prototype-builtins\n\t  return !Object('z').propertyIsEnumerable(0);\n\t}) ? function (it) {\n\t  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n\t} : Object;\n\n\t// `RequireObjectCoercible` abstract operation\n\t// https://tc39.es/ecma262/#sec-requireobjectcoercible\n\tvar requireObjectCoercible = function (it) {\n\t  if (it == undefined) { throw TypeError(\"Can't call method on \" + it); }\n\t  return it;\n\t};\n\n\t// toObject with fallback for non-array-like ES3 strings\n\n\n\n\tvar toIndexedObject = function (it) {\n\t  return indexedObject(requireObjectCoercible(it));\n\t};\n\n\tvar isObject = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\t// `ToPrimitive` abstract operation\n\t// https://tc39.es/ecma262/#sec-toprimitive\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar toPrimitive = function (input, PREFERRED_STRING) {\n\t  if (!isObject(input)) { return input; }\n\t  var fn, val;\n\t  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) { return val; }\n\t  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) { return val; }\n\t  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) { return val; }\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\n\tvar has = function (it, key) {\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n\tvar document$1 = global_1.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar EXISTS = isObject(document$1) && isObject(document$1.createElement);\n\n\tvar documentCreateElement = function (it) {\n\t  return EXISTS ? document$1.createElement(it) : {};\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar ie8DomDefine = !descriptors && !fails(function () {\n\t  return Object.defineProperty(documentCreateElement('div'), 'a', {\n\t    get: function () { return 7; }\n\t  }).a != 7;\n\t});\n\n\tvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// `Object.getOwnPropertyDescriptor` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n\tvar f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n\t  O = toIndexedObject(O);\n\t  P = toPrimitive(P, true);\n\t  if (ie8DomDefine) { try {\n\t    return nativeGetOwnPropertyDescriptor(O, P);\n\t  } catch (error) { /* empty */ } }\n\t  if (has(O, P)) { return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]); }\n\t};\n\n\tvar objectGetOwnPropertyDescriptor = {\n\t\tf: f$1\n\t};\n\n\tvar anObject = function (it) {\n\t  if (!isObject(it)) {\n\t    throw TypeError(String(it) + ' is not an object');\n\t  } return it;\n\t};\n\n\tvar nativeDefineProperty = Object.defineProperty;\n\n\t// `Object.defineProperty` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperty\n\tvar f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (ie8DomDefine) { try {\n\t    return nativeDefineProperty(O, P, Attributes);\n\t  } catch (error) { /* empty */ } }\n\t  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported'); }\n\t  if ('value' in Attributes) { O[P] = Attributes.value; }\n\t  return O;\n\t};\n\n\tvar objectDefineProperty = {\n\t\tf: f$2\n\t};\n\n\tvar createNonEnumerableProperty = descriptors ? function (object, key, value) {\n\t  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar setGlobal = function (key, value) {\n\t  try {\n\t    createNonEnumerableProperty(global_1, key, value);\n\t  } catch (error) {\n\t    global_1[key] = value;\n\t  } return value;\n\t};\n\n\tvar SHARED = '__core-js_shared__';\n\tvar store = global_1[SHARED] || setGlobal(SHARED, {});\n\n\tvar sharedStore = store;\n\n\tvar functionToString = Function.toString;\n\n\t// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\n\tif (typeof sharedStore.inspectSource != 'function') {\n\t  sharedStore.inspectSource = function (it) {\n\t    return functionToString.call(it);\n\t  };\n\t}\n\n\tvar inspectSource = sharedStore.inspectSource;\n\n\tvar WeakMap = global_1.WeakMap;\n\n\tvar nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\n\n\tvar isPure = false;\n\n\tvar shared = createCommonjsModule(function (module) {\n\t(module.exports = function (key, value) {\n\t  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: '3.8.3',\n\t  mode: isPure ? 'pure' : 'global',\n\t  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'\n\t});\n\t});\n\n\tvar id = 0;\n\tvar postfix = Math.random();\n\n\tvar uid = function (key) {\n\t  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n\t};\n\n\tvar keys = shared('keys');\n\n\tvar sharedKey = function (key) {\n\t  return keys[key] || (keys[key] = uid(key));\n\t};\n\n\tvar hiddenKeys = {};\n\n\tvar WeakMap$1 = global_1.WeakMap;\n\tvar set, get, has$1;\n\n\tvar enforce = function (it) {\n\t  return has$1(it) ? get(it) : set(it, {});\n\t};\n\n\tvar getterFor = function (TYPE) {\n\t  return function (it) {\n\t    var state;\n\t    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n\t      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n\t    } return state;\n\t  };\n\t};\n\n\tif (nativeWeakMap) {\n\t  var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());\n\t  var wmget = store$1.get;\n\t  var wmhas = store$1.has;\n\t  var wmset = store$1.set;\n\t  set = function (it, metadata) {\n\t    metadata.facade = it;\n\t    wmset.call(store$1, it, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return wmget.call(store$1, it) || {};\n\t  };\n\t  has$1 = function (it) {\n\t    return wmhas.call(store$1, it);\n\t  };\n\t} else {\n\t  var STATE = sharedKey('state');\n\t  hiddenKeys[STATE] = true;\n\t  set = function (it, metadata) {\n\t    metadata.facade = it;\n\t    createNonEnumerableProperty(it, STATE, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return has(it, STATE) ? it[STATE] : {};\n\t  };\n\t  has$1 = function (it) {\n\t    return has(it, STATE);\n\t  };\n\t}\n\n\tvar internalState = {\n\t  set: set,\n\t  get: get,\n\t  has: has$1,\n\t  enforce: enforce,\n\t  getterFor: getterFor\n\t};\n\tvar internalState_1 = internalState.set;\n\tvar internalState_2 = internalState.get;\n\tvar internalState_3 = internalState.has;\n\tvar internalState_4 = internalState.enforce;\n\tvar internalState_5 = internalState.getterFor;\n\n\tvar redefine = createCommonjsModule(function (module) {\n\tvar getInternalState = internalState.get;\n\tvar enforceInternalState = internalState.enforce;\n\tvar TEMPLATE = String(String).split('String');\n\n\t(module.exports = function (O, key, value, options) {\n\t  var unsafe = options ? !!options.unsafe : false;\n\t  var simple = options ? !!options.enumerable : false;\n\t  var noTargetGet = options ? !!options.noTargetGet : false;\n\t  var state;\n\t  if (typeof value == 'function') {\n\t    if (typeof key == 'string' && !has(value, 'name')) {\n\t      createNonEnumerableProperty(value, 'name', key);\n\t    }\n\t    state = enforceInternalState(value);\n\t    if (!state.source) {\n\t      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n\t    }\n\t  }\n\t  if (O === global_1) {\n\t    if (simple) { O[key] = value; }\n\t    else { setGlobal(key, value); }\n\t    return;\n\t  } else if (!unsafe) {\n\t    delete O[key];\n\t  } else if (!noTargetGet && O[key]) {\n\t    simple = true;\n\t  }\n\t  if (simple) { O[key] = value; }\n\t  else { createNonEnumerableProperty(O, key, value); }\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, 'toString', function toString() {\n\t  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n\t});\n\t});\n\n\tvar path = global_1;\n\n\tvar aFunction = function (variable) {\n\t  return typeof variable == 'function' ? variable : undefined;\n\t};\n\n\tvar getBuiltIn = function (namespace, method) {\n\t  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])\n\t    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n\t};\n\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\n\t// `ToInteger` abstract operation\n\t// https://tc39.es/ecma262/#sec-tointeger\n\tvar toInteger = function (argument) {\n\t  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n\t};\n\n\tvar min = Math.min;\n\n\t// `ToLength` abstract operation\n\t// https://tc39.es/ecma262/#sec-tolength\n\tvar toLength = function (argument) {\n\t  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n\t};\n\n\tvar max = Math.max;\n\tvar min$1 = Math.min;\n\n\t// Helper for a popular repeating case of the spec:\n\t// Let integer be ? ToInteger(index).\n\t// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n\tvar toAbsoluteIndex = function (index, length) {\n\t  var integer = toInteger(index);\n\t  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n\t};\n\n\t// `Array.prototype.{ indexOf, includes }` methods implementation\n\tvar createMethod = function (IS_INCLUDES) {\n\t  return function ($this, el, fromIndex) {\n\t    var O = toIndexedObject($this);\n\t    var length = toLength(O.length);\n\t    var index = toAbsoluteIndex(fromIndex, length);\n\t    var value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    // eslint-disable-next-line no-self-compare\n\t    if (IS_INCLUDES && el != el) { while (length > index) {\n\t      value = O[index++];\n\t      // eslint-disable-next-line no-self-compare\n\t      if (value != value) { return true; }\n\t    // Array#indexOf ignores holes, Array#includes - not\n\t    } } else { for (;length > index; index++) {\n\t      if ((IS_INCLUDES || index in O) && O[index] === el) { return IS_INCLUDES || index || 0; }\n\t    } } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n\tvar arrayIncludes = {\n\t  // `Array.prototype.includes` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.includes\n\t  includes: createMethod(true),\n\t  // `Array.prototype.indexOf` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n\t  indexOf: createMethod(false)\n\t};\n\tvar arrayIncludes_1 = arrayIncludes.includes;\n\tvar arrayIncludes_2 = arrayIncludes.indexOf;\n\n\tvar indexOf = arrayIncludes.indexOf;\n\n\n\tvar objectKeysInternal = function (object, names) {\n\t  var O = toIndexedObject(object);\n\t  var i = 0;\n\t  var result = [];\n\t  var key;\n\t  for (key in O) { !has(hiddenKeys, key) && has(O, key) && result.push(key); }\n\t  // Don't enum bug & hidden keys\n\t  while (names.length > i) { if (has(O, key = names[i++])) {\n\t    ~indexOf(result, key) || result.push(key);\n\t  } }\n\t  return result;\n\t};\n\n\t// IE8- don't enum bug keys\n\tvar enumBugKeys = [\n\t  'constructor',\n\t  'hasOwnProperty',\n\t  'isPrototypeOf',\n\t  'propertyIsEnumerable',\n\t  'toLocaleString',\n\t  'toString',\n\t  'valueOf'\n\t];\n\n\tvar hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');\n\n\t// `Object.getOwnPropertyNames` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertynames\n\tvar f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n\t  return objectKeysInternal(O, hiddenKeys$1);\n\t};\n\n\tvar objectGetOwnPropertyNames = {\n\t\tf: f$3\n\t};\n\n\tvar f$4 = Object.getOwnPropertySymbols;\n\n\tvar objectGetOwnPropertySymbols = {\n\t\tf: f$4\n\t};\n\n\t// all object keys, includes non-enumerable and symbols\n\tvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n\t  var keys = objectGetOwnPropertyNames.f(anObject(it));\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n\t};\n\n\tvar copyConstructorProperties = function (target, source) {\n\t  var keys = ownKeys(source);\n\t  var defineProperty = objectDefineProperty.f;\n\t  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    if (!has(target, key)) { defineProperty(target, key, getOwnPropertyDescriptor(source, key)); }\n\t  }\n\t};\n\n\tvar replacement = /#|\\.prototype\\./;\n\n\tvar isForced = function (feature, detection) {\n\t  var value = data[normalize(feature)];\n\t  return value == POLYFILL ? true\n\t    : value == NATIVE ? false\n\t    : typeof detection == 'function' ? fails(detection)\n\t    : !!detection;\n\t};\n\n\tvar normalize = isForced.normalize = function (string) {\n\t  return String(string).replace(replacement, '.').toLowerCase();\n\t};\n\n\tvar data = isForced.data = {};\n\tvar NATIVE = isForced.NATIVE = 'N';\n\tvar POLYFILL = isForced.POLYFILL = 'P';\n\n\tvar isForced_1 = isForced;\n\n\tvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\t/*\n\t  options.target      - name of the target object\n\t  options.global      - target is the global object\n\t  options.stat        - export as static methods of target\n\t  options.proto       - export as prototype methods of target\n\t  options.real        - real prototype method for the `pure` version\n\t  options.forced      - export even if the native feature is available\n\t  options.bind        - bind methods to the target, required for the `pure` version\n\t  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n\t  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n\t  options.sham        - add a flag to not completely full polyfills\n\t  options.enumerable  - export as enumerable property\n\t  options.noTargetGet - prevent calling a getter on target\n\t*/\n\tvar _export = function (options, source) {\n\t  var TARGET = options.target;\n\t  var GLOBAL = options.global;\n\t  var STATIC = options.stat;\n\t  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\t  if (GLOBAL) {\n\t    target = global_1;\n\t  } else if (STATIC) {\n\t    target = global_1[TARGET] || setGlobal(TARGET, {});\n\t  } else {\n\t    target = (global_1[TARGET] || {}).prototype;\n\t  }\n\t  if (target) { for (key in source) {\n\t    sourceProperty = source[key];\n\t    if (options.noTargetGet) {\n\t      descriptor = getOwnPropertyDescriptor$1(target, key);\n\t      targetProperty = descriptor && descriptor.value;\n\t    } else { targetProperty = target[key]; }\n\t    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n\t    // contained in target\n\t    if (!FORCED && targetProperty !== undefined) {\n\t      if (typeof sourceProperty === typeof targetProperty) { continue; }\n\t      copyConstructorProperties(sourceProperty, targetProperty);\n\t    }\n\t    // add a flag to not completely full polyfills\n\t    if (options.sham || (targetProperty && targetProperty.sham)) {\n\t      createNonEnumerableProperty(sourceProperty, 'sham', true);\n\t    }\n\t    // extend global\n\t    redefine(target, key, sourceProperty, options);\n\t  } }\n\t};\n\n\tvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n\t  // Chrome 38 Symbol has incorrect toString conversion\n\t  // eslint-disable-next-line no-undef\n\t  return !String(Symbol());\n\t});\n\n\tvar useSymbolAsUid = nativeSymbol\n\t  // eslint-disable-next-line no-undef\n\t  && !Symbol.sham\n\t  // eslint-disable-next-line no-undef\n\t  && typeof Symbol.iterator == 'symbol';\n\n\tvar WellKnownSymbolsStore = shared('wks');\n\tvar Symbol$1 = global_1.Symbol;\n\tvar createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;\n\n\tvar wellKnownSymbol = function (name) {\n\t  if (!has(WellKnownSymbolsStore, name)) {\n\t    if (nativeSymbol && has(Symbol$1, name)) { WellKnownSymbolsStore[name] = Symbol$1[name]; }\n\t    else { WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name); }\n\t  } return WellKnownSymbolsStore[name];\n\t};\n\n\t// `Object.keys` method\n\t// https://tc39.es/ecma262/#sec-object.keys\n\tvar objectKeys = Object.keys || function keys(O) {\n\t  return objectKeysInternal(O, enumBugKeys);\n\t};\n\n\t// `Object.defineProperties` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperties\n\tvar objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var keys = objectKeys(Properties);\n\t  var length = keys.length;\n\t  var index = 0;\n\t  var key;\n\t  while (length > index) { objectDefineProperty.f(O, key = keys[index++], Properties[key]); }\n\t  return O;\n\t};\n\n\tvar html = getBuiltIn('document', 'documentElement');\n\n\tvar GT = '>';\n\tvar LT = '<';\n\tvar PROTOTYPE = 'prototype';\n\tvar SCRIPT = 'script';\n\tvar IE_PROTO = sharedKey('IE_PROTO');\n\n\tvar EmptyConstructor = function () { /* empty */ };\n\n\tvar scriptTag = function (content) {\n\t  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n\t};\n\n\t// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n\tvar NullProtoObjectViaActiveX = function (activeXDocument) {\n\t  activeXDocument.write(scriptTag(''));\n\t  activeXDocument.close();\n\t  var temp = activeXDocument.parentWindow.Object;\n\t  activeXDocument = null; // avoid memory leak\n\t  return temp;\n\t};\n\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar NullProtoObjectViaIFrame = function () {\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = documentCreateElement('iframe');\n\t  var JS = 'java' + SCRIPT + ':';\n\t  var iframeDocument;\n\t  iframe.style.display = 'none';\n\t  html.appendChild(iframe);\n\t  // https://github.com/zloirock/core-js/issues/475\n\t  iframe.src = String(JS);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(scriptTag('document.F=Object'));\n\t  iframeDocument.close();\n\t  return iframeDocument.F;\n\t};\n\n\t// Check for document.domain and active x support\n\t// No need to use active x approach when document.domain is not set\n\t// see https://github.com/es-shims/es5-shim/issues/150\n\t// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n\t// avoid IE GC bug\n\tvar activeXDocument;\n\tvar NullProtoObject = function () {\n\t  try {\n\t    /* global ActiveXObject */\n\t    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n\t  } catch (error) { /* ignore */ }\n\t  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n\t  var length = enumBugKeys.length;\n\t  while (length--) { delete NullProtoObject[PROTOTYPE][enumBugKeys[length]]; }\n\t  return NullProtoObject();\n\t};\n\n\thiddenKeys[IE_PROTO] = true;\n\n\t// `Object.create` method\n\t// https://tc39.es/ecma262/#sec-object.create\n\tvar objectCreate = Object.create || function create(O, Properties) {\n\t  var result;\n\t  if (O !== null) {\n\t    EmptyConstructor[PROTOTYPE] = anObject(O);\n\t    result = new EmptyConstructor();\n\t    EmptyConstructor[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else { result = NullProtoObject(); }\n\t  return Properties === undefined ? result : objectDefineProperties(result, Properties);\n\t};\n\n\tvar UNSCOPABLES = wellKnownSymbol('unscopables');\n\tvar ArrayPrototype = Array.prototype;\n\n\t// Array.prototype[@@unscopables]\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\tif (ArrayPrototype[UNSCOPABLES] == undefined) {\n\t  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {\n\t    configurable: true,\n\t    value: objectCreate(null)\n\t  });\n\t}\n\n\t// add a key to Array.prototype[@@unscopables]\n\tvar addToUnscopables = function (key) {\n\t  ArrayPrototype[UNSCOPABLES][key] = true;\n\t};\n\n\tvar defineProperty = Object.defineProperty;\n\tvar cache = {};\n\n\tvar thrower = function (it) { throw it; };\n\n\tvar arrayMethodUsesToLength = function (METHOD_NAME, options) {\n\t  if (has(cache, METHOD_NAME)) { return cache[METHOD_NAME]; }\n\t  if (!options) { options = {}; }\n\t  var method = [][METHOD_NAME];\n\t  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;\n\t  var argument0 = has(options, 0) ? options[0] : thrower;\n\t  var argument1 = has(options, 1) ? options[1] : undefined;\n\n\t  return cache[METHOD_NAME] = !!method && !fails(function () {\n\t    if (ACCESSORS && !descriptors) { return true; }\n\t    var O = { length: -1 };\n\n\t    if (ACCESSORS) { defineProperty(O, 1, { enumerable: true, get: thrower }); }\n\t    else { O[1] = 1; }\n\n\t    method.call(O, argument0, argument1);\n\t  });\n\t};\n\n\t'use strict';\n\n\tvar $includes = arrayIncludes.includes;\n\n\n\n\tvar USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });\n\n\t// `Array.prototype.includes` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.includes\n\t_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {\n\t  includes: function includes(el /* , fromIndex = 0 */) {\n\t    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('includes');\n\n\tvar es_array_includes = {\n\n\t};\n\n\tvar aFunction$1 = function (it) {\n\t  if (typeof it != 'function') {\n\t    throw TypeError(String(it) + ' is not a function');\n\t  } return it;\n\t};\n\n\t// optional / simple context binding\n\tvar functionBindContext = function (fn, that, length) {\n\t  aFunction$1(fn);\n\t  if (that === undefined) { return fn; }\n\t  switch (length) {\n\t    case 0: return function () {\n\t      return fn.call(that);\n\t    };\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar call = Function.call;\n\n\tvar entryUnbind = function (CONSTRUCTOR, METHOD, length) {\n\t  return functionBindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length);\n\t};\n\n\tvar includes = entryUnbind('Array', 'includes');\n\n\tvar includes$1 = includes;\n\n\t// `ToObject` abstract operation\n\t// https://tc39.es/ecma262/#sec-toobject\n\tvar toObject = function (argument) {\n\t  return Object(requireObjectCoercible(argument));\n\t};\n\n\t// `IsArray` abstract operation\n\t// https://tc39.es/ecma262/#sec-isarray\n\tvar isArray = Array.isArray || function isArray(arg) {\n\t  return classofRaw(arg) == 'Array';\n\t};\n\n\tvar SPECIES = wellKnownSymbol('species');\n\n\t// `ArraySpeciesCreate` abstract operation\n\t// https://tc39.es/ecma262/#sec-arrayspeciescreate\n\tvar arraySpeciesCreate = function (originalArray, length) {\n\t  var C;\n\t  if (isArray(originalArray)) {\n\t    C = originalArray.constructor;\n\t    // cross-realm fallback\n\t    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) { C = undefined; }\n\t    else if (isObject(C)) {\n\t      C = C[SPECIES];\n\t      if (C === null) { C = undefined; }\n\t    }\n\t  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n\t};\n\n\tvar push = [].push;\n\n\t// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\n\tvar createMethod$1 = function (TYPE) {\n\t  var IS_MAP = TYPE == 1;\n\t  var IS_FILTER = TYPE == 2;\n\t  var IS_SOME = TYPE == 3;\n\t  var IS_EVERY = TYPE == 4;\n\t  var IS_FIND_INDEX = TYPE == 6;\n\t  var IS_FILTER_OUT = TYPE == 7;\n\t  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n\t  return function ($this, callbackfn, that, specificCreate) {\n\t    var O = toObject($this);\n\t    var self = indexedObject(O);\n\t    var boundFunction = functionBindContext(callbackfn, that, 3);\n\t    var length = toLength(self.length);\n\t    var index = 0;\n\t    var create = specificCreate || arraySpeciesCreate;\n\t    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\n\t    var value, result;\n\t    for (;length > index; index++) { if (NO_HOLES || index in self) {\n\t      value = self[index];\n\t      result = boundFunction(value, index, O);\n\t      if (TYPE) {\n\t        if (IS_MAP) { target[index] = result; } // map\n\t        else if (result) { switch (TYPE) {\n\t          case 3: return true;              // some\n\t          case 5: return value;             // find\n\t          case 6: return index;             // findIndex\n\t          case 2: push.call(target, value); // filter\n\t        } } else { switch (TYPE) {\n\t          case 4: return false;             // every\n\t          case 7: push.call(target, value); // filterOut\n\t        } }\n\t      }\n\t    } }\n\t    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n\t  };\n\t};\n\n\tvar arrayIteration = {\n\t  // `Array.prototype.forEach` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n\t  forEach: createMethod$1(0),\n\t  // `Array.prototype.map` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.map\n\t  map: createMethod$1(1),\n\t  // `Array.prototype.filter` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.filter\n\t  filter: createMethod$1(2),\n\t  // `Array.prototype.some` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.some\n\t  some: createMethod$1(3),\n\t  // `Array.prototype.every` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.every\n\t  every: createMethod$1(4),\n\t  // `Array.prototype.find` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.find\n\t  find: createMethod$1(5),\n\t  // `Array.prototype.findIndex` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n\t  findIndex: createMethod$1(6),\n\t  // `Array.prototype.filterOut` method\n\t  // https://github.com/tc39/proposal-array-filtering\n\t  filterOut: createMethod$1(7)\n\t};\n\tvar arrayIteration_1 = arrayIteration.forEach;\n\tvar arrayIteration_2 = arrayIteration.map;\n\tvar arrayIteration_3 = arrayIteration.filter;\n\tvar arrayIteration_4 = arrayIteration.some;\n\tvar arrayIteration_5 = arrayIteration.every;\n\tvar arrayIteration_6 = arrayIteration.find;\n\tvar arrayIteration_7 = arrayIteration.findIndex;\n\tvar arrayIteration_8 = arrayIteration.filterOut;\n\n\t'use strict';\n\n\tvar $find = arrayIteration.find;\n\n\n\n\tvar FIND = 'find';\n\tvar SKIPS_HOLES = true;\n\n\tvar USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND);\n\n\t// Shouldn't skip holes\n\tif (FIND in []) { Array(1)[FIND](function () { SKIPS_HOLES = false; }); }\n\n\t// `Array.prototype.find` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.find\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$1 }, {\n\t  find: function find(callbackfn /* , that = undefined */) {\n\t    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND);\n\n\tvar es_array_find = {\n\n\t};\n\n\tvar find = entryUnbind('Array', 'find');\n\n\tvar find$1 = find;\n\n\t// `String.prototype.{ codePointAt, at }` methods implementation\n\tvar createMethod$2 = function (CONVERT_TO_STRING) {\n\t  return function ($this, pos) {\n\t    var S = String(requireObjectCoercible($this));\n\t    var position = toInteger(pos);\n\t    var size = S.length;\n\t    var first, second;\n\t    if (position < 0 || position >= size) { return CONVERT_TO_STRING ? '' : undefined; }\n\t    first = S.charCodeAt(position);\n\t    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n\t      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n\t        ? CONVERT_TO_STRING ? S.charAt(position) : first\n\t        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n\t  };\n\t};\n\n\tvar stringMultibyte = {\n\t  // `String.prototype.codePointAt` method\n\t  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n\t  codeAt: createMethod$2(false),\n\t  // `String.prototype.at` method\n\t  // https://github.com/mathiasbynens/String.prototype.at\n\t  charAt: createMethod$2(true)\n\t};\n\tvar stringMultibyte_1 = stringMultibyte.codeAt;\n\tvar stringMultibyte_2 = stringMultibyte.charAt;\n\n\tvar correctPrototypeGetter = !fails(function () {\n\t  function F() { /* empty */ }\n\t  F.prototype.constructor = null;\n\t  return Object.getPrototypeOf(new F()) !== F.prototype;\n\t});\n\n\tvar IE_PROTO$1 = sharedKey('IE_PROTO');\n\tvar ObjectPrototype = Object.prototype;\n\n\t// `Object.getPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.getprototypeof\n\tvar objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n\t  O = toObject(O);\n\t  if (has(O, IE_PROTO$1)) { return O[IE_PROTO$1]; }\n\t  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectPrototype : null;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\n\tvar ITERATOR = wellKnownSymbol('iterator');\n\tvar BUGGY_SAFARI_ITERATORS = false;\n\n\tvar returnThis = function () { return this; };\n\n\t// `%IteratorPrototype%` object\n\t// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n\tvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n\tif ([].keys) {\n\t  arrayIterator = [].keys();\n\t  // Safari 8 has buggy iterators w/o `next`\n\t  if (!('next' in arrayIterator)) { BUGGY_SAFARI_ITERATORS = true; }\n\t  else {\n\t    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n\t    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) { IteratorPrototype = PrototypeOfArrayIteratorPrototype; }\n\t  }\n\t}\n\n\tvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {\n\t  var test = {};\n\t  // FF44- legacy iterators case\n\t  return IteratorPrototype[ITERATOR].call(test) !== test;\n\t});\n\n\tif (NEW_ITERATOR_PROTOTYPE) { IteratorPrototype = {}; }\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\tif ((!isPure || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\n\t  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n\t}\n\n\tvar iteratorsCore = {\n\t  IteratorPrototype: IteratorPrototype,\n\t  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n\t};\n\tvar iteratorsCore_1 = iteratorsCore.IteratorPrototype;\n\tvar iteratorsCore_2 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\n\tvar defineProperty$1 = objectDefineProperty.f;\n\n\n\n\tvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\n\tvar setToStringTag = function (it, TAG, STATIC) {\n\t  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n\t    defineProperty$1(it, TO_STRING_TAG, { configurable: true, value: TAG });\n\t  }\n\t};\n\n\tvar iterators = {};\n\n\t'use strict';\n\tvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\n\n\n\n\n\tvar returnThis$1 = function () { return this; };\n\n\tvar createIteratorConstructor = function (IteratorConstructor, NAME, next) {\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });\n\t  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n\t  iterators[TO_STRING_TAG] = returnThis$1;\n\t  return IteratorConstructor;\n\t};\n\n\tvar aPossiblePrototype = function (it) {\n\t  if (!isObject(it) && it !== null) {\n\t    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n\t  } return it;\n\t};\n\n\t// `Object.setPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.setprototypeof\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n\t  var CORRECT_SETTER = false;\n\t  var test = {};\n\t  var setter;\n\t  try {\n\t    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n\t    setter.call(test, []);\n\t    CORRECT_SETTER = test instanceof Array;\n\t  } catch (error) { /* empty */ }\n\t  return function setPrototypeOf(O, proto) {\n\t    anObject(O);\n\t    aPossiblePrototype(proto);\n\t    if (CORRECT_SETTER) { setter.call(O, proto); }\n\t    else { O.__proto__ = proto; }\n\t    return O;\n\t  };\n\t}() : undefined);\n\n\t'use strict';\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\n\tvar BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\tvar ITERATOR$1 = wellKnownSymbol('iterator');\n\tvar KEYS = 'keys';\n\tvar VALUES = 'values';\n\tvar ENTRIES = 'entries';\n\n\tvar returnThis$2 = function () { return this; };\n\n\tvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n\t  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n\t  var getIterationMethod = function (KIND) {\n\t    if (KIND === DEFAULT && defaultIterator) { return defaultIterator; }\n\t    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) { return IterablePrototype[KIND]; }\n\t    switch (KIND) {\n\t      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n\t      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n\t      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n\t    } return function () { return new IteratorConstructor(this); };\n\t  };\n\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  var INCORRECT_VALUES_NAME = false;\n\t  var IterablePrototype = Iterable.prototype;\n\t  var nativeIterator = IterablePrototype[ITERATOR$1]\n\t    || IterablePrototype['@@iterator']\n\t    || DEFAULT && IterablePrototype[DEFAULT];\n\t  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n\t  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n\t  var CurrentIteratorPrototype, methods, KEY;\n\n\t  // fix native\n\t  if (anyNativeIterator) {\n\t    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\t    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {\n\t      if (!isPure && objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {\n\t        if (objectSetPrototypeOf) {\n\t          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);\n\t        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {\n\t          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);\n\t        }\n\t      }\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n\t      if (isPure) { iterators[TO_STRING_TAG] = returnThis$2; }\n\t    }\n\t  }\n\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n\t    INCORRECT_VALUES_NAME = true;\n\t    defaultIterator = function values() { return nativeIterator.call(this); };\n\t  }\n\n\t  // define iterator\n\t  if ((!isPure || FORCED) && IterablePrototype[ITERATOR$1] !== defaultIterator) {\n\t    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);\n\t  }\n\t  iterators[NAME] = defaultIterator;\n\n\t  // export additional methods\n\t  if (DEFAULT) {\n\t    methods = {\n\t      values: getIterationMethod(VALUES),\n\t      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n\t      entries: getIterationMethod(ENTRIES)\n\t    };\n\t    if (FORCED) { for (KEY in methods) {\n\t      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n\t        redefine(IterablePrototype, KEY, methods[KEY]);\n\t      }\n\t    } } else { _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods); }\n\t  }\n\n\t  return methods;\n\t};\n\n\t'use strict';\n\tvar charAt = stringMultibyte.charAt;\n\n\n\n\tvar STRING_ITERATOR = 'String Iterator';\n\tvar setInternalState = internalState.set;\n\tvar getInternalState = internalState.getterFor(STRING_ITERATOR);\n\n\t// `String.prototype[@@iterator]` method\n\t// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n\tdefineIterator(String, 'String', function (iterated) {\n\t  setInternalState(this, {\n\t    type: STRING_ITERATOR,\n\t    string: String(iterated),\n\t    index: 0\n\t  });\n\t// `%StringIteratorPrototype%.next` method\n\t// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n\t}, function next() {\n\t  var state = getInternalState(this);\n\t  var string = state.string;\n\t  var index = state.index;\n\t  var point;\n\t  if (index >= string.length) { return { value: undefined, done: true }; }\n\t  point = charAt(string, index);\n\t  state.index += point.length;\n\t  return { value: point, done: false };\n\t});\n\n\tvar es_string_iterator = {\n\n\t};\n\n\tvar iteratorClose = function (iterator) {\n\t  var returnMethod = iterator['return'];\n\t  if (returnMethod !== undefined) {\n\t    return anObject(returnMethod.call(iterator)).value;\n\t  }\n\t};\n\n\t// call something on iterator step with safe closing on error\n\tvar callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {\n\t  try {\n\t    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch (error) {\n\t    iteratorClose(iterator);\n\t    throw error;\n\t  }\n\t};\n\n\tvar ITERATOR$2 = wellKnownSymbol('iterator');\n\tvar ArrayPrototype$1 = Array.prototype;\n\n\t// check on default Array iterator\n\tvar isArrayIteratorMethod = function (it) {\n\t  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);\n\t};\n\n\t'use strict';\n\n\n\n\n\tvar createProperty = function (object, key, value) {\n\t  var propertyKey = toPrimitive(key);\n\t  if (propertyKey in object) { objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value)); }\n\t  else { object[propertyKey] = value; }\n\t};\n\n\tvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');\n\tvar test = {};\n\n\ttest[TO_STRING_TAG$1] = 'z';\n\n\tvar toStringTagSupport = String(test) === '[object z]';\n\n\tvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\t// ES3 wrong here\n\tvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function (it, key) {\n\t  try {\n\t    return it[key];\n\t  } catch (error) { /* empty */ }\n\t};\n\n\t// getting tag from ES6+ `Object.prototype.toString`\n\tvar classof = toStringTagSupport ? classofRaw : function (it) {\n\t  var O, tag, result;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag\n\t    // builtinTag case\n\t    : CORRECT_ARGUMENTS ? classofRaw(O)\n\t    // ES3 arguments fallback\n\t    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n\t};\n\n\tvar ITERATOR$3 = wellKnownSymbol('iterator');\n\n\tvar getIteratorMethod = function (it) {\n\t  if (it != undefined) { return it[ITERATOR$3]\n\t    || it['@@iterator']\n\t    || iterators[classof(it)]; }\n\t};\n\n\t'use strict';\n\n\n\n\n\n\n\n\n\t// `Array.from` method implementation\n\t// https://tc39.es/ecma262/#sec-array.from\n\tvar arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n\t  var O = toObject(arrayLike);\n\t  var C = typeof this == 'function' ? this : Array;\n\t  var argumentsLength = arguments.length;\n\t  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n\t  var mapping = mapfn !== undefined;\n\t  var iteratorMethod = getIteratorMethod(O);\n\t  var index = 0;\n\t  var length, result, step, iterator, next, value;\n\t  if (mapping) { mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); }\n\t  // if the target is not iterable or it's an array with the default iterator - use a simple case\n\t  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n\t    iterator = iteratorMethod.call(O);\n\t    next = iterator.next;\n\t    result = new C();\n\t    for (;!(step = next.call(iterator)).done; index++) {\n\t      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n\t      createProperty(result, index, value);\n\t    }\n\t  } else {\n\t    length = toLength(O.length);\n\t    result = new C(length);\n\t    for (;length > index; index++) {\n\t      value = mapping ? mapfn(O[index], index) : O[index];\n\t      createProperty(result, index, value);\n\t    }\n\t  }\n\t  result.length = index;\n\t  return result;\n\t};\n\n\tvar ITERATOR$4 = wellKnownSymbol('iterator');\n\tvar SAFE_CLOSING = false;\n\n\ttry {\n\t  var called = 0;\n\t  var iteratorWithReturn = {\n\t    next: function () {\n\t      return { done: !!called++ };\n\t    },\n\t    'return': function () {\n\t      SAFE_CLOSING = true;\n\t    }\n\t  };\n\t  iteratorWithReturn[ITERATOR$4] = function () {\n\t    return this;\n\t  };\n\t  // eslint-disable-next-line no-throw-literal\n\t  Array.from(iteratorWithReturn, function () { throw 2; });\n\t} catch (error) { /* empty */ }\n\n\tvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n\t  if (!SKIP_CLOSING && !SAFE_CLOSING) { return false; }\n\t  var ITERATION_SUPPORT = false;\n\t  try {\n\t    var object = {};\n\t    object[ITERATOR$4] = function () {\n\t      return {\n\t        next: function () {\n\t          return { done: ITERATION_SUPPORT = true };\n\t        }\n\t      };\n\t    };\n\t    exec(object);\n\t  } catch (error) { /* empty */ }\n\t  return ITERATION_SUPPORT;\n\t};\n\n\tvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n\t  Array.from(iterable);\n\t});\n\n\t// `Array.from` method\n\t// https://tc39.es/ecma262/#sec-array.from\n\t_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n\t  from: arrayFrom\n\t});\n\n\tvar es_array_from = {\n\n\t};\n\n\tvar from_1 = path.Array.from;\n\n\tvar from_1$1 = from_1;\n\n\t'use strict';\n\n\tvar $findIndex = arrayIteration.findIndex;\n\n\n\n\tvar FIND_INDEX = 'findIndex';\n\tvar SKIPS_HOLES$1 = true;\n\n\tvar USES_TO_LENGTH$2 = arrayMethodUsesToLength(FIND_INDEX);\n\n\t// Shouldn't skip holes\n\tif (FIND_INDEX in []) { Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; }); }\n\n\t// `Array.prototype.findIndex` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.findindex\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$2 }, {\n\t  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n\t    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND_INDEX);\n\n\tvar es_array_findIndex = {\n\n\t};\n\n\tvar findIndex = entryUnbind('Array', 'findIndex');\n\n\tvar findIndex$1 = findIndex;\n\n\tvar base64 = createCommonjsModule(function (module, exports) {\n\t(function() {\n\n\t    /**\n\t     * version: 0.3.0\n\t     * git://github.com/davidchambers/Base64.js.git\n\t     */\n\n\t    var object = 'object' != 'undefined' ? exports : this; // #8: web workers\n\t    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n\t    function InvalidCharacterError(message) {\n\t        this.message = message;\n\t    }\n\n\t    InvalidCharacterError.prototype = new Error;\n\t    InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n\t    // encoder\n\t    // [https://gist.github.com/999166] by [https://github.com/nignag]\n\t    object.btoa || (\n\t        object.btoa = function(input) {\n\t            var str = String(input);\n\t            for (\n\t                // initialize result and counter\n\t                var block, charCode, idx = 0, map = chars, output = '';\n\t                // if the next str index does not exist:\n\t                //   change the mapping table to \"=\"\n\t                //   check if d has no fractional digits\n\t                str.charAt(idx | 0) || (map = '=', idx % 1);\n\t                // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n\t                output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n\t            ) {\n\t                charCode = str.charCodeAt(idx += 3 / 4);\n\t                if (charCode > 0xFF) {\n\t                    throw new InvalidCharacterError('\\'btoa\\' failed: The string to be encoded contains characters outside of the Latin1 range.');\n\t                }\n\t                block = block << 8 | charCode;\n\t            }\n\t            return output;\n\t        });\n\n\t    // decoder\n\t    // [https://gist.github.com/1020396] by [https://github.com/atk]\n\t    object.atob || (\n\t        object.atob = function(input) {\n\t            var str = String(input).replace(/=+$/, '');\n\t            if (str.length % 4 == 1) {\n\t                throw new InvalidCharacterError('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n\t            }\n\t            for (\n\t                // initialize result and counters\n\t                var bc = 0, bs, buffer, idx = 0, output = '';\n\t                // get next character\n\t                // eslint-disable-next-line no-cond-assign\n\t                buffer = str.charAt(idx++);\n\t                // character found in table? initialize bit storage and add its ascii value;\n\t                ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n\t                // and if not first of each 4 characters,\n\t                // convert the first 8 bits to one ascii character\n\t                bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n\t            ) {\n\t                // try to find character in table (0-63, not found => -1)\n\t                buffer = chars.indexOf(buffer);\n\t            }\n\t            return output;\n\t        });\n\n\t}());\n\t});\n\n\t// `Number.isNaN` method\n\t// https://tc39.es/ecma262/#sec-number.isnan\n\t_export({ target: 'Number', stat: true }, {\n\t  isNaN: function isNaN(number) {\n\t    // eslint-disable-next-line no-self-compare\n\t    return number != number;\n\t  }\n\t});\n\n\tvar es_number_isNan = {\n\n\t};\n\n\tvar isNan = path.Number.isNaN;\n\n\tvar isNan$1 = isNan;\n\n\tvar globalIsFinite = global_1.isFinite;\n\n\t// `Number.isFinite` method\n\t// https://tc39.es/ecma262/#sec-number.isfinite\n\tvar numberIsFinite = Number.isFinite || function isFinite(it) {\n\t  return typeof it == 'number' && globalIsFinite(it);\n\t};\n\n\t// `Number.isFinite` method\n\t// https://tc39.es/ecma262/#sec-number.isfinite\n\t_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });\n\n\tvar es_number_isFinite = {\n\n\t};\n\n\tvar _isFinite = path.Number.isFinite;\n\n\tvar _isFinite$1 = _isFinite;\n\n\tvar MATCH = wellKnownSymbol('match');\n\n\t// `IsRegExp` abstract operation\n\t// https://tc39.es/ecma262/#sec-isregexp\n\tvar isRegexp = function (it) {\n\t  var isRegExp;\n\t  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');\n\t};\n\n\tvar notARegexp = function (it) {\n\t  if (isRegexp(it)) {\n\t    throw TypeError(\"The method doesn't accept regular expressions\");\n\t  } return it;\n\t};\n\n\tvar MATCH$1 = wellKnownSymbol('match');\n\n\tvar correctIsRegexpLogic = function (METHOD_NAME) {\n\t  var regexp = /./;\n\t  try {\n\t    '/./'[METHOD_NAME](regexp);\n\t  } catch (error1) {\n\t    try {\n\t      regexp[MATCH$1] = false;\n\t      return '/./'[METHOD_NAME](regexp);\n\t    } catch (error2) { /* empty */ }\n\t  } return false;\n\t};\n\n\t'use strict';\n\n\n\n\n\n\t// `String.prototype.includes` method\n\t// https://tc39.es/ecma262/#sec-string.prototype.includes\n\t_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {\n\t  includes: function includes(searchString /* , position = 0 */) {\n\t    return !!~String(requireObjectCoercible(this))\n\t      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar es_string_includes = {\n\n\t};\n\n\tvar includes$2 = entryUnbind('String', 'includes');\n\n\tvar includes$3 = includes$2;\n\n\t'use strict';\n\n\tvar getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\tvar nativeStartsWith = ''.startsWith;\n\tvar min$2 = Math.min;\n\n\tvar CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith');\n\t// https://github.com/zloirock/core-js/pull/702\n\tvar MDN_POLYFILL_BUG = !isPure && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n\t  var descriptor = getOwnPropertyDescriptor$2(String.prototype, 'startsWith');\n\t  return descriptor && !descriptor.writable;\n\t}();\n\n\t// `String.prototype.startsWith` method\n\t// https://tc39.es/ecma262/#sec-string.prototype.startswith\n\t_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {\n\t  startsWith: function startsWith(searchString /* , position = 0 */) {\n\t    var that = String(requireObjectCoercible(this));\n\t    notARegexp(searchString);\n\t    var index = toLength(min$2(arguments.length > 1 ? arguments[1] : undefined, that.length));\n\t    var search = String(searchString);\n\t    return nativeStartsWith\n\t      ? nativeStartsWith.call(that, search, index)\n\t      : that.slice(index, index + search.length) === search;\n\t  }\n\t});\n\n\tvar es_string_startsWith = {\n\n\t};\n\n\tvar startsWith = entryUnbind('String', 'startsWith');\n\n\tvar startsWith$1 = startsWith;\n\n\t(function() {\n\n\t    if (typeof Uint8Array !== 'undefined' || typeof window === 'undefined') {\n\t        return;\n\t    }\n\n\t    function subarray(start, end) {\n\t        return this.slice(start, end);\n\t    }\n\n\t    function set_(array, offset) {\n\n\t        if (arguments.length < 2) {\n\t            offset = 0;\n\t        }\n\t        for (var i = 0, n = array.length; i < n; ++i, ++offset) {\n\t            this[offset] = array[i] & 0xFF;\n\t        }\n\t    }\n\n\t    // we need typed arrays\n\t    function TypedArray(arg1) {\n\n\t        var result;\n\t        if (typeof arg1 === 'number') {\n\t            result = new Array(arg1);\n\t            for (var i = 0; i < arg1; ++i) {\n\t                result[i] = 0;\n\t            }\n\t        } else {\n\t            result = arg1.slice(0);\n\t        }\n\t        result.subarray = subarray;\n\t        result.buffer = result;\n\t        result.byteLength = result.length;\n\t        result.set = set_;\n\t        if (typeof arg1 === 'object' && arg1.buffer) {\n\t            result.buffer = arg1.buffer;\n\t        }\n\n\t        return result;\n\t    }\n\n\t    window.Uint8Array = TypedArray;\n\t    window.Uint32Array = TypedArray;\n\t    window.Int32Array = TypedArray;\n\t})();\n\n\t/**\n\t * make xhr.response = 'arraybuffer' available for the IE9\n\t */\n\t(function() {\n\n\t    if (typeof XMLHttpRequest === 'undefined') {\n\t        return;\n\t    }\n\n\t    if ('response' in XMLHttpRequest.prototype ||\n\t        'mozResponseArrayBuffer' in XMLHttpRequest.prototype ||\n\t        'mozResponse' in XMLHttpRequest.prototype ||\n\t        'responseArrayBuffer' in XMLHttpRequest.prototype) {\n\t        return;\n\t    }\n\n\t    Object.defineProperty(XMLHttpRequest.prototype, 'response', {\n\t        get: function() {\n\t            /* global VBArray:true */\n\t            return new Uint8Array(new VBArray(this.responseBody).toArray());\n\t        }\n\t    });\n\t})();\n\n\t// Geometry library.\n\t// -----------------\n\n\t// Declare shorthands to the most used math functions.\n\tvar math = Math;\n\tvar abs = math.abs;\n\tvar cos = math.cos;\n\tvar sin = math.sin;\n\tvar sqrt = math.sqrt;\n\tvar min$3 = math.min;\n\tvar max$1 = math.max;\n\tvar atan2 = math.atan2;\n\tvar round = math.round;\n\tvar floor$1 = math.floor;\n\tvar PI = math.PI;\n\tvar pow = math.pow;\n\n\tvar bezier = {\n\n\t    // Cubic Bezier curve path through points.\n\t    // @deprecated\n\t    // @param {array} points Array of points through which the smooth line will go.\n\t    // @return {array} SVG Path commands as an array\n\t    curveThroughPoints: function(points) {\n\n\t        console.warn('deprecated');\n\n\t        return new Path(Curve.throughPoints(points)).serialize();\n\t    },\n\n\t    // Get open-ended Bezier Spline Control Points.\n\t    // @deprecated\n\t    // @param knots Input Knot Bezier spline points (At least two points!).\n\t    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n\t    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n\t    getCurveControlPoints: function(knots) {\n\n\t        console.warn('deprecated');\n\n\t        var firstControlPoints = [];\n\t        var secondControlPoints = [];\n\t        var n = knots.length - 1;\n\t        var i;\n\n\t        // Special case: Bezier curve should be a straight line.\n\t        if (n == 1) {\n\t            // 3P1 = 2P0 + P3\n\t            firstControlPoints[0] = new Point(\n\t                (2 * knots[0].x + knots[1].x) / 3,\n\t                (2 * knots[0].y + knots[1].y) / 3\n\t            );\n\n\t            // P2 = 2P1  P0\n\t            secondControlPoints[0] = new Point(\n\t                2 * firstControlPoints[0].x - knots[0].x,\n\t                2 * firstControlPoints[0].y - knots[0].y\n\t            );\n\n\t            return [firstControlPoints, secondControlPoints];\n\t        }\n\n\t        // Calculate first Bezier control points.\n\t        // Right hand side vector.\n\t        var rhs = [];\n\n\t        // Set right hand side X values.\n\t        for (i = 1; i < n - 1; i++) {\n\t            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n\t        }\n\n\t        rhs[0] = knots[0].x + 2 * knots[1].x;\n\t        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n\t        // Get first control points X-values.\n\t        var x = this.getFirstControlPoints(rhs);\n\n\t        // Set right hand side Y values.\n\t        for (i = 1; i < n - 1; ++i) {\n\t            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n\t        }\n\n\t        rhs[0] = knots[0].y + 2 * knots[1].y;\n\t        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n\t        // Get first control points Y-values.\n\t        var y = this.getFirstControlPoints(rhs);\n\n\t        // Fill output arrays.\n\t        for (i = 0; i < n; i++) {\n\t            // First control point.\n\t            firstControlPoints.push(new Point(x[i], y[i]));\n\n\t            // Second control point.\n\t            if (i < n - 1) {\n\t                secondControlPoints.push(new Point(\n\t                    2 * knots [i + 1].x - x[i + 1],\n\t                    2 * knots[i + 1].y - y[i + 1]\n\t                ));\n\n\t            } else {\n\t                secondControlPoints.push(new Point(\n\t                    (knots[n].x + x[n - 1]) / 2,\n\t                    (knots[n].y + y[n - 1]) / 2)\n\t                );\n\t            }\n\t        }\n\n\t        return [firstControlPoints, secondControlPoints];\n\t    },\n\n\t    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n\t    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n\t    // @deprecated\n\t    // @param control points (start, control start, control end, end)\n\t    // @return a function that accepts t and returns 2 curves.\n\t    getCurveDivider: function(p0, p1, p2, p3) {\n\n\t        console.warn('deprecated');\n\n\t        var curve = new Curve(p0, p1, p2, p3);\n\n\t        return function divideCurve(t) {\n\n\t            var divided = curve.divide(t);\n\n\t            return [{\n\t                p0: divided[0].start,\n\t                p1: divided[0].controlPoint1,\n\t                p2: divided[0].controlPoint2,\n\t                p3: divided[0].end\n\t            }, {\n\t                p0: divided[1].start,\n\t                p1: divided[1].controlPoint1,\n\t                p2: divided[1].controlPoint2,\n\t                p3: divided[1].end\n\t            }];\n\t        };\n\t    },\n\n\t    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n\t    // @deprecated\n\t    // @param rhs Right hand side vector.\n\t    // @return Solution vector.\n\t    getFirstControlPoints: function(rhs) {\n\n\t        console.warn('deprecated');\n\n\t        var n = rhs.length;\n\t        // `x` is a solution vector.\n\t        var x = [];\n\t        var tmp = [];\n\t        var b = 2.0;\n\n\t        x[0] = rhs[0] / b;\n\n\t        // Decomposition and forward substitution.\n\t        for (var i = 1; i < n; i++) {\n\t            tmp[i] = 1 / b;\n\t            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n\t            x[i] = (rhs[i] - x[i - 1]) / b;\n\t        }\n\n\t        for (i = 1; i < n; i++) {\n\t            // Backsubstitution.\n\t            x[n - i - 1] -= tmp[n - i] * x[n - i];\n\t        }\n\n\t        return x;\n\t    },\n\n\t    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n\t    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\n\t    // which corresponds to that point.\n\t    // @deprecated\n\t    // @param control points (start, control start, control end, end)\n\t    // @return a function that accepts a point and returns t.\n\t    getInversionSolver: function(p0, p1, p2, p3) {\n\n\t        console.warn('deprecated');\n\n\t        var curve = new Curve(p0, p1, p2, p3);\n\n\t        return function solveInversion(p) {\n\n\t            return curve.closestPointT(p);\n\t        };\n\t    }\n\t};\n\n\tvar Curve = function(p1, p2, p3, p4) {\n\n\t    if (!(this instanceof Curve)) {\n\t        return new Curve(p1, p2, p3, p4);\n\t    }\n\n\t    if (p1 instanceof Curve) {\n\t        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n\t    }\n\n\t    this.start = new Point(p1);\n\t    this.controlPoint1 = new Point(p2);\n\t    this.controlPoint2 = new Point(p3);\n\t    this.end = new Point(p4);\n\t};\n\n\t// Curve passing through points.\n\t// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n\t// @param {array} points Array of points through which the smooth line will go.\n\t// @return {array} curves.\n\tCurve.throughPoints = (function() {\n\n\t    // Get open-ended Bezier Spline Control Points.\n\t    // @param knots Input Knot Bezier spline points (At least two points!).\n\t    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n\t    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n\t    function getCurveControlPoints(knots) {\n\n\t        var firstControlPoints = [];\n\t        var secondControlPoints = [];\n\t        var n = knots.length - 1;\n\t        var i;\n\n\t        // Special case: Bezier curve should be a straight line.\n\t        if (n == 1) {\n\t            // 3P1 = 2P0 + P3\n\t            firstControlPoints[0] = new Point(\n\t                (2 * knots[0].x + knots[1].x) / 3,\n\t                (2 * knots[0].y + knots[1].y) / 3\n\t            );\n\n\t            // P2 = 2P1  P0\n\t            secondControlPoints[0] = new Point(\n\t                2 * firstControlPoints[0].x - knots[0].x,\n\t                2 * firstControlPoints[0].y - knots[0].y\n\t            );\n\n\t            return [firstControlPoints, secondControlPoints];\n\t        }\n\n\t        // Calculate first Bezier control points.\n\t        // Right hand side vector.\n\t        var rhs = [];\n\n\t        // Set right hand side X values.\n\t        for (i = 1; i < n - 1; i++) {\n\t            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n\t        }\n\n\t        rhs[0] = knots[0].x + 2 * knots[1].x;\n\t        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n\t        // Get first control points X-values.\n\t        var x = getFirstControlPoints(rhs);\n\n\t        // Set right hand side Y values.\n\t        for (i = 1; i < n - 1; ++i) {\n\t            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n\t        }\n\n\t        rhs[0] = knots[0].y + 2 * knots[1].y;\n\t        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n\t        // Get first control points Y-values.\n\t        var y = getFirstControlPoints(rhs);\n\n\t        // Fill output arrays.\n\t        for (i = 0; i < n; i++) {\n\t            // First control point.\n\t            firstControlPoints.push(new Point(x[i], y[i]));\n\n\t            // Second control point.\n\t            if (i < n - 1) {\n\t                secondControlPoints.push(new Point(\n\t                    2 * knots [i + 1].x - x[i + 1],\n\t                    2 * knots[i + 1].y - y[i + 1]\n\t                ));\n\n\t            } else {\n\t                secondControlPoints.push(new Point(\n\t                    (knots[n].x + x[n - 1]) / 2,\n\t                    (knots[n].y + y[n - 1]) / 2\n\t                ));\n\t            }\n\t        }\n\n\t        return [firstControlPoints, secondControlPoints];\n\t    }\n\n\t    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n\t    // @param rhs Right hand side vector.\n\t    // @return Solution vector.\n\t    function getFirstControlPoints(rhs) {\n\n\t        var n = rhs.length;\n\t        // `x` is a solution vector.\n\t        var x = [];\n\t        var tmp = [];\n\t        var b = 2.0;\n\n\t        x[0] = rhs[0] / b;\n\n\t        // Decomposition and forward substitution.\n\t        for (var i = 1; i < n; i++) {\n\t            tmp[i] = 1 / b;\n\t            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n\t            x[i] = (rhs[i] - x[i - 1]) / b;\n\t        }\n\n\t        for (i = 1; i < n; i++) {\n\t            // Backsubstitution.\n\t            x[n - i - 1] -= tmp[n - i] * x[n - i];\n\t        }\n\n\t        return x;\n\t    }\n\n\t    return function(points) {\n\n\t        if (!points || (Array.isArray(points) && points.length < 2)) {\n\t            throw new Error('At least 2 points are required');\n\t        }\n\n\t        var controlPoints = getCurveControlPoints(points);\n\n\t        var curves = [];\n\t        var n = controlPoints[0].length;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n\t            var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n\t            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n\t        }\n\n\t        return curves;\n\t    };\n\t})();\n\n\tCurve.prototype = {\n\n\t    // Returns a bbox that tightly envelops the curve.\n\t    bbox: function() {\n\n\t        var start = this.start;\n\t        var controlPoint1 = this.controlPoint1;\n\t        var controlPoint2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        var x0 = start.x;\n\t        var y0 = start.y;\n\t        var x1 = controlPoint1.x;\n\t        var y1 = controlPoint1.y;\n\t        var x2 = controlPoint2.x;\n\t        var y2 = controlPoint2.y;\n\t        var x3 = end.x;\n\t        var y3 = end.y;\n\n\t        var points = new Array(); // local extremes\n\t        var tvalues = new Array(); // t values of local extremes\n\t        var bounds = [new Array(), new Array()];\n\n\t        var a, b, c, t;\n\t        var t1, t2;\n\t        var b2ac, sqrtb2ac;\n\n\t        for (var i = 0; i < 2; ++i) {\n\n\t            if (i === 0) {\n\t                b = 6 * x0 - 12 * x1 + 6 * x2;\n\t                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n\t                c = 3 * x1 - 3 * x0;\n\n\t            } else {\n\t                b = 6 * y0 - 12 * y1 + 6 * y2;\n\t                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n\t                c = 3 * y1 - 3 * y0;\n\t            }\n\n\t            if (abs(a) < 1e-12) { // Numerical robustness\n\t                if (abs(b) < 1e-12) { // Numerical robustness\n\t                    continue;\n\t                }\n\n\t                t = -c / b;\n\t                if ((0 < t) && (t < 1)) { tvalues.push(t); }\n\n\t                continue;\n\t            }\n\n\t            b2ac = b * b - 4 * c * a;\n\t            sqrtb2ac = sqrt(b2ac);\n\n\t            if (b2ac < 0) { continue; }\n\n\t            t1 = (-b + sqrtb2ac) / (2 * a);\n\t            if ((0 < t1) && (t1 < 1)) { tvalues.push(t1); }\n\n\t            t2 = (-b - sqrtb2ac) / (2 * a);\n\t            if ((0 < t2) && (t2 < 1)) { tvalues.push(t2); }\n\t        }\n\n\t        var j = tvalues.length;\n\t        var jlen = j;\n\t        var mt;\n\t        var x, y;\n\n\t        while (j--) {\n\t            t = tvalues[j];\n\t            mt = 1 - t;\n\n\t            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n\t            bounds[0][j] = x;\n\n\t            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n\t            bounds[1][j] = y;\n\n\t            points[j] = { X: x, Y: y };\n\t        }\n\n\t        tvalues[jlen] = 0;\n\t        tvalues[jlen + 1] = 1;\n\n\t        points[jlen] = { X: x0, Y: y0 };\n\t        points[jlen + 1] = { X: x3, Y: y3 };\n\n\t        bounds[0][jlen] = x0;\n\t        bounds[1][jlen] = y0;\n\n\t        bounds[0][jlen + 1] = x3;\n\t        bounds[1][jlen + 1] = y3;\n\n\t        tvalues.length = jlen + 2;\n\t        bounds[0].length = jlen + 2;\n\t        bounds[1].length = jlen + 2;\n\t        points.length = jlen + 2;\n\n\t        var left = min$3.apply(null, bounds[0]);\n\t        var top = min$3.apply(null, bounds[1]);\n\t        var right = max$1.apply(null, bounds[0]);\n\t        var bottom = max$1.apply(null, bounds[1]);\n\n\t        return new Rect(left, top, (right - left), (bottom - top));\n\t    },\n\n\t    clone: function() {\n\n\t        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t    },\n\n\t    // Returns the point on the curve closest to point `p`\n\t    closestPoint: function(p, opt) {\n\n\t        return this.pointAtT(this.closestPointT(p, opt));\n\t    },\n\n\t    closestPointLength: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n\t        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n\t    },\n\n\t    closestPointNormalizedLength: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n\t        var cpLength = this.closestPointLength(p, localOpt);\n\t        if (!cpLength) { return 0; }\n\n\t        var length = this.length(localOpt);\n\t        if (length === 0) { return 0; }\n\n\t        return cpLength / length;\n\t    },\n\n\t    // Returns `t` of the point on the curve closest to point `p`\n\t    closestPointT: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        // does not use localOpt\n\n\t        // identify the subdivision that contains the point:\n\t        var investigatedSubdivision;\n\t        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\t        var investigatedSubdivisionEndT;\n\t        var distFromStart; // distance of point from start of baseline\n\t        var distFromEnd; // distance of point from end of baseline\n\t        var chordLength; // distance between start and end of the subdivision\n\t        var minSumDist; // lowest observed sum of the two distances\n\t        var n = subdivisions.length;\n\t        var subdivisionSize = (n ? (1 / n) : 0);\n\t        for (var i = 0; i < n; i++) {\n\n\t            var currentSubdivision = subdivisions[i];\n\n\t            var startDist = currentSubdivision.start.distance(p);\n\t            var endDist = currentSubdivision.end.distance(p);\n\t            var sumDist = startDist + endDist;\n\n\t            // check that the point is closest to current subdivision and not any other\n\t            if (!minSumDist || (sumDist < minSumDist)) {\n\t                investigatedSubdivision = currentSubdivision;\n\n\t                investigatedSubdivisionStartT = i * subdivisionSize;\n\t                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n\t                distFromStart = startDist;\n\t                distFromEnd = endDist;\n\n\t                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n\t                minSumDist = sumDist;\n\t            }\n\t        }\n\n\t        var precisionRatio = pow(10, -precision);\n\n\t        // recursively divide investigated subdivision:\n\t        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n\t        // then return the closest endpoint of that final subdivision\n\t        while (true) {\n\n\t            // check if we have reached at least one required observed precision\n\t            // - calculated as: the difference in distances from point to start and end divided by the distance\n\t            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n\t            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n\t            // - this criterion works well for points lying far away from the curve\n\t            var startPrecisionRatio = (distFromStart ? (abs(distFromStart - distFromEnd) / distFromStart) : 0);\n\t            var endPrecisionRatio = (distFromEnd ? (abs(distFromStart - distFromEnd) / distFromEnd) : 0);\n\t            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n\t            // check if we have reached at least one required minimal distance\n\t            // - calculated as: the subdivision chord length multiplied by precisionRatio\n\t            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n\t            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\t            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n\t            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n\t            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n\t            // do we stop now?\n\t            if (hasRequiredPrecision || hasMinimalDistance) {\n\t                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n\t            }\n\n\t            // otherwise, set up for next iteration\n\t            var divided = investigatedSubdivision.divide(0.5);\n\t            subdivisionSize /= 2;\n\n\t            var startDist1 = divided[0].start.distance(p);\n\t            var endDist1 = divided[0].end.distance(p);\n\t            var sumDist1 = startDist1 + endDist1;\n\n\t            var startDist2 = divided[1].start.distance(p);\n\t            var endDist2 = divided[1].end.distance(p);\n\t            var sumDist2 = startDist2 + endDist2;\n\n\t            if (sumDist1 <= sumDist2) {\n\t                investigatedSubdivision = divided[0];\n\n\t                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n\t                distFromStart = startDist1;\n\t                distFromEnd = endDist1;\n\n\t            } else {\n\t                investigatedSubdivision = divided[1];\n\n\t                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n\t                distFromStart = startDist2;\n\t                distFromEnd = endDist2;\n\t            }\n\t        }\n\t    },\n\n\t    closestPointTangent: function(p, opt) {\n\n\t        return this.tangentAtT(this.closestPointT(p, opt));\n\t    },\n\n\t    // Returns `true` if the area surrounded by the curve contains the point `p`.\n\t    // Implements the even-odd algorithm (self-intersections are \"outside\").\n\t    // Closes open curves (always imagines a closing segment).\n\t    // Precision may be adjusted by passing an `opt` object.\n\t    containsPoint: function(p, opt) {\n\n\t        var polyline = this.toPolyline(opt);\n\t        return polyline.containsPoint(p);\n\t    },\n\n\t    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    // For a function that uses `t`, use Curve.divideAtT().\n\t    divideAt: function(ratio, opt) {\n\n\t        if (ratio <= 0) { return this.divideAtT(0); }\n\t        if (ratio >= 1) { return this.divideAtT(1); }\n\n\t        var t = this.tAt(ratio, opt);\n\n\t        return this.divideAtT(t);\n\t    },\n\n\t    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    divideAtLength: function(length, opt) {\n\n\t        var t = this.tAtLength(length, opt);\n\n\t        return this.divideAtT(t);\n\t    },\n\n\t    // Divides the curve into two at point defined by `t` between 0 and 1.\n\t    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n\t    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n\t    divideAtT: function(t) {\n\n\t        var start = this.start;\n\t        var controlPoint1 = this.controlPoint1;\n\t        var controlPoint2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        // shortcuts for `t` values that are out of range\n\t        if (t <= 0) {\n\t            return [\n\t                new Curve(start, start, start, start),\n\t                new Curve(start, controlPoint1, controlPoint2, end)\n\t            ];\n\t        }\n\n\t        if (t >= 1) {\n\t            return [\n\t                new Curve(start, controlPoint1, controlPoint2, end),\n\t                new Curve(end, end, end, end)\n\t            ];\n\t        }\n\n\t        var dividerPoints = this.getSkeletonPoints(t);\n\n\t        var startControl1 = dividerPoints.startControlPoint1;\n\t        var startControl2 = dividerPoints.startControlPoint2;\n\t        var divider = dividerPoints.divider;\n\t        var dividerControl1 = dividerPoints.dividerControlPoint1;\n\t        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n\t        // return array with two new curves\n\t        return [\n\t            new Curve(start, startControl1, startControl2, divider),\n\t            new Curve(divider, dividerControl1, dividerControl2, end)\n\t        ];\n\t    },\n\n\t    // Returns the distance between the curve's start and end points.\n\t    endpointDistance: function() {\n\n\t        return this.start.distance(this.end);\n\t    },\n\n\t    // Checks whether two curves are exactly the same.\n\t    equals: function(c) {\n\n\t        return !!c &&\n\t            this.start.x === c.start.x &&\n\t            this.start.y === c.start.y &&\n\t            this.controlPoint1.x === c.controlPoint1.x &&\n\t            this.controlPoint1.y === c.controlPoint1.y &&\n\t            this.controlPoint2.x === c.controlPoint2.x &&\n\t            this.controlPoint2.y === c.controlPoint2.y &&\n\t            this.end.x === c.end.x &&\n\t            this.end.y === c.end.y;\n\t    },\n\n\t    // Returns five helper points necessary for curve division.\n\t    getSkeletonPoints: function(t) {\n\n\t        var start = this.start;\n\t        var control1 = this.controlPoint1;\n\t        var control2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        // shortcuts for `t` values that are out of range\n\t        if (t <= 0) {\n\t            return {\n\t                startControlPoint1: start.clone(),\n\t                startControlPoint2: start.clone(),\n\t                divider: start.clone(),\n\t                dividerControlPoint1: control1.clone(),\n\t                dividerControlPoint2: control2.clone()\n\t            };\n\t        }\n\n\t        if (t >= 1) {\n\t            return {\n\t                startControlPoint1: control1.clone(),\n\t                startControlPoint2: control2.clone(),\n\t                divider: end.clone(),\n\t                dividerControlPoint1: end.clone(),\n\t                dividerControlPoint2: end.clone()\n\t            };\n\t        }\n\n\t        var midpoint1 = (new Line(start, control1)).pointAt(t);\n\t        var midpoint2 = (new Line(control1, control2)).pointAt(t);\n\t        var midpoint3 = (new Line(control2, end)).pointAt(t);\n\n\t        var subControl1 = (new Line(midpoint1, midpoint2)).pointAt(t);\n\t        var subControl2 = (new Line(midpoint2, midpoint3)).pointAt(t);\n\n\t        var divider = (new Line(subControl1, subControl2)).pointAt(t);\n\n\t        var output = {\n\t            startControlPoint1: midpoint1,\n\t            startControlPoint2: subControl1,\n\t            divider: divider,\n\t            dividerControlPoint1: subControl2,\n\t            dividerControlPoint2: midpoint3\n\t        };\n\n\t        return output;\n\t    },\n\n\t    // Returns a list of curves whose flattened length is better than `opt.precision`.\n\t    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n\t    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n\t    // (That is why skipping iteration 1 is important)\n\t    // As a rule of thumb, increasing `precision` by 1 requires two more division operations\n\t    // - Precision 0 (endpointDistance) - total of 2^0 - 1 = 0 operations (1 subdivision)\n\t    // - Precision 1 (<10% error) - total of 2^2 - 1 = 3 operations (4 subdivisions)\n\t    // - Precision 2 (<1% error) - total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n\t    // - Precision 3 (<0.1% error) - total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n\t    // - Precision 4 (<0.01% error) - total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n\t    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n\t    getSubdivisions: function(opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        // not using opt.subdivisions\n\t        // not using localOpt\n\n\t        var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n\t        if (precision === 0) { return subdivisions; }\n\n\t        var previousLength = this.endpointDistance();\n\n\t        var precisionRatio = pow(10, -precision);\n\n\t        // recursively divide curve at `t = 0.5`\n\t        // until the difference between observed length at subsequent iterations is lower than precision\n\t        var iteration = 0;\n\t        while (true) {\n\t            iteration += 1;\n\n\t            // divide all subdivisions\n\t            var newSubdivisions = [];\n\t            var numSubdivisions = subdivisions.length;\n\t            for (var i = 0; i < numSubdivisions; i++) {\n\n\t                var currentSubdivision = subdivisions[i];\n\t                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n\t                newSubdivisions.push(divided[0], divided[1]);\n\t            }\n\n\t            // measure new length\n\t            var length = 0;\n\t            var numNewSubdivisions = newSubdivisions.length;\n\t            for (var j = 0; j < numNewSubdivisions; j++) {\n\n\t                var currentNewSubdivision = newSubdivisions[j];\n\t                length += currentNewSubdivision.endpointDistance();\n\t            }\n\n\t            // check if we have reached required observed precision\n\t            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n\t            // not a problem for further iterations because cubic curves cannot have more than two local extrema\n\t            // (i.e. cubic curves cannot intersect the baseline more than once)\n\t            // therefore two subsequent iterations cannot produce sampling with equal length\n\t            var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n\t            if (iteration > 1 && observedPrecisionRatio < precisionRatio) {\n\t                return newSubdivisions;\n\t            }\n\n\t            // otherwise, set up for next iteration\n\t            subdivisions = newSubdivisions;\n\t            previousLength = length;\n\t        }\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        var start = this.start;\n\t        var control1 = this.controlPoint1;\n\t        var control2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n\t    },\n\n\t    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n\t    length: function(opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        // not using localOpt\n\n\t        var length = 0;\n\t        var n = subdivisions.length;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var currentSubdivision = subdivisions[i];\n\t            length += currentSubdivision.endpointDistance();\n\t        }\n\n\t        return length;\n\t    },\n\n\t    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n\t    lengthAtT: function(t, opt) {\n\n\t        if (t <= 0) { return 0; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        // not using opt.subdivisions\n\t        // not using localOpt\n\n\t        var subCurve = this.divide(t)[0];\n\t        var subCurveLength = subCurve.length({ precision: precision });\n\n\t        return subCurveLength;\n\t    },\n\n\t    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    // Mirrors Line.pointAt() function.\n\t    // For a function that tracks `t`, use Curve.pointAtT().\n\t    pointAt: function(ratio, opt) {\n\n\t        if (ratio <= 0) { return this.start.clone(); }\n\t        if (ratio >= 1) { return this.end.clone(); }\n\n\t        var t = this.tAt(ratio, opt);\n\n\t        return this.pointAtT(t);\n\t    },\n\n\t    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    pointAtLength: function(length, opt) {\n\n\t        var t = this.tAtLength(length, opt);\n\n\t        return this.pointAtT(t);\n\t    },\n\n\t    // Returns the point at provided `t` between 0 and 1.\n\t    // `t` does not track distance along curve as it does in Line objects.\n\t    // Non-linear relationship, speeds up and slows down as curve warps!\n\t    // For linear length-based solution, use Curve.pointAt().\n\t    pointAtT: function(t) {\n\n\t        if (t <= 0) { return this.start.clone(); }\n\t        if (t >= 1) { return this.end.clone(); }\n\n\t        return this.getSkeletonPoints(t).divider;\n\t    },\n\n\t    // Default precision\n\t    PRECISION: 3,\n\n\t    round: function(precision) {\n\n\t        this.start.round(precision);\n\t        this.controlPoint1.round(precision);\n\t        this.controlPoint2.round(precision);\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.start.scale(sx, sy, origin);\n\t        this.controlPoint1.scale(sx, sy, origin);\n\t        this.controlPoint2.scale(sx, sy, origin);\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n\t    tangentAt: function(ratio, opt) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        else if (ratio > 1) { ratio = 1; }\n\n\t        var t = this.tAt(ratio, opt);\n\n\t        return this.tangentAtT(t);\n\t    },\n\n\t    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n\t    tangentAtLength: function(length, opt) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        var t = this.tAtLength(length, opt);\n\n\t        return this.tangentAtT(t);\n\t    },\n\n\t    // Returns a tangent line at requested `t`.\n\t    tangentAtT: function(t) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        if (t < 0) { t = 0; }\n\t        else if (t > 1) { t = 1; }\n\n\t        var skeletonPoints = this.getSkeletonPoints(t);\n\n\t        var p1 = skeletonPoints.startControlPoint2;\n\t        var p2 = skeletonPoints.dividerControlPoint1;\n\n\t        var tangentStart = skeletonPoints.divider;\n\n\t        var tangentLine = new Line(p1, p2);\n\t        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n\t        return tangentLine;\n\t    },\n\n\t    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    tAt: function(ratio, opt) {\n\n\t        if (ratio <= 0) { return 0; }\n\t        if (ratio >= 1) { return 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n\t        var curveLength = this.length(localOpt);\n\t        var length = curveLength * ratio;\n\n\t        return this.tAtLength(length, localOpt);\n\t    },\n\n\t    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    // Uses `precision` to approximate length within `precision` (always underestimates)\n\t    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n\t    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n\t    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n\t    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n\t    // - Precision 2 (<1% error) - 3 levels\n\t    // - Precision 3 (<0.1% error) - 7 levels\n\t    // - Precision 4 (<0.01% error) - 15 levels\n\t    tAtLength: function(length, opt) {\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n\t        // identify the subdivision that contains the point at requested `length`:\n\t        var investigatedSubdivision;\n\t        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\t        var investigatedSubdivisionEndT;\n\t        //var baseline; // straightened version of subdivision to investigate\n\t        //var baselinePoint; // point on the baseline that is the requested distance away from start\n\t        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n\t        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n\t        var l = 0; // length so far\n\t        var n = subdivisions.length;\n\t        var subdivisionSize = 1 / n;\n\t        for (var i = 0; i < n; i++) {\n\t            var index = (fromStart ? i : (n - 1 - i));\n\n\t            var currentSubdivision = subdivisions[i];\n\t            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n\t            if (length <= (l + d)) {\n\t                investigatedSubdivision = currentSubdivision;\n\n\t                investigatedSubdivisionStartT = index * subdivisionSize;\n\t                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n\t                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n\t                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n\t                break;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        if (!investigatedSubdivision) { return (fromStart ? 1 : 0); } // length requested is out of range - return maximum t\n\t        // note that precision affects what length is recorded\n\t        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n\t        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n\t        var curveLength = this.length(localOpt);\n\n\t        var precisionRatio = pow(10, -precision);\n\n\t        // recursively divide investigated subdivision:\n\t        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n\t        // then return the closest endpoint of that final subdivision\n\t        while (true) {\n\n\t            // check if we have reached required observed precision\n\t            var observedPrecisionRatio;\n\n\t            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n\t            if (observedPrecisionRatio < precisionRatio) { return investigatedSubdivisionStartT; }\n\t            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n\t            if (observedPrecisionRatio < precisionRatio) { return investigatedSubdivisionEndT; }\n\n\t            // otherwise, set up for next iteration\n\t            var newBaselinePointDistFromStart;\n\t            var newBaselinePointDistFromEnd;\n\n\t            var divided = investigatedSubdivision.divide(0.5);\n\t            subdivisionSize /= 2;\n\n\t            var baseline1Length = divided[0].endpointDistance();\n\t            var baseline2Length = divided[1].endpointDistance();\n\n\t            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n\t                investigatedSubdivision = divided[0];\n\n\t                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n\t                newBaselinePointDistFromStart = baselinePointDistFromStart;\n\t                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n\t            } else { // point at requested length is inside divided[1]\n\t                investigatedSubdivision = divided[1];\n\n\t                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n\t                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n\t                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n\t            }\n\n\t            baselinePointDistFromStart = newBaselinePointDistFromStart;\n\t            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n\t        }\n\t    },\n\n\t    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n\t    // Flattened length is no more than 10^(-precision) away from real curve length.\n\t    toPoints: function(opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\t        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n\t        // not using localOpt\n\n\t        var points = [subdivisions[0].start.clone()];\n\t        var n = subdivisions.length;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var currentSubdivision = subdivisions[i];\n\t            points.push(currentSubdivision.end.clone());\n\t        }\n\n\t        return points;\n\t    },\n\n\t    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n\t    // Flattened length is no more than 10^(-precision) away from real curve length.\n\t    toPolyline: function(opt) {\n\n\t        return new Polyline(this.toPoints(opt));\n\t    },\n\n\t    toString: function() {\n\n\t        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.start.translate(tx, ty);\n\t        this.controlPoint1.translate(tx, ty);\n\t        this.controlPoint2.translate(tx, ty);\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    }\n\t};\n\n\tCurve.prototype.divide = Curve.prototype.divideAtT;\n\n\tvar Ellipse = function(c, a, b) {\n\n\t    if (!(this instanceof Ellipse)) {\n\t        return new Ellipse(c, a, b);\n\t    }\n\n\t    if (c instanceof Ellipse) {\n\t        return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n\t    }\n\n\t    c = new Point(c);\n\t    this.x = c.x;\n\t    this.y = c.y;\n\t    this.a = a;\n\t    this.b = b;\n\t};\n\n\tEllipse.fromRect = function(rect) {\n\n\t    rect = new Rect(rect);\n\t    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n\t};\n\n\tEllipse.prototype = {\n\n\t    bbox: function() {\n\n\t        return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n\t    },\n\n\t    /**\n\t     * @returns {g.Point}\n\t     */\n\t    center: function() {\n\n\t        return new Point(this.x, this.y);\n\t    },\n\n\t    clone: function() {\n\n\t        return new Ellipse(this);\n\t    },\n\n\t    /**\n\t     * @param {g.Point} p\n\t     * @returns {boolean}\n\t     */\n\t    containsPoint: function(p) {\n\n\t        return this.normalizedDistance(p) <= 1;\n\t    },\n\n\t    equals: function(ellipse) {\n\n\t        return !!ellipse &&\n\t            ellipse.x === this.x &&\n\t            ellipse.y === this.y &&\n\t            ellipse.a === this.a &&\n\t            ellipse.b === this.b;\n\t    },\n\n\t    // inflate by dx and dy\n\t    // @param dx {delta_x} representing additional size to x\n\t    // @param dy {delta_y} representing additional size to y -\n\t    // dy param is not required -> in that case y is sized by dx\n\t    inflate: function(dx, dy) {\n\t        if (dx === undefined) {\n\t            dx = 0;\n\t        }\n\n\t        if (dy === undefined) {\n\t            dy = dx;\n\t        }\n\n\t        this.a += 2 * dx;\n\t        this.b += 2 * dy;\n\n\t        return this;\n\t    },\n\n\t    intersectionWithLine: function(line) {\n\n\t        var intersections = [];\n\t        var a1 = line.start;\n\t        var a2 = line.end;\n\t        var rx = this.a;\n\t        var ry = this.b;\n\t        var dir = line.vector();\n\t        var diff = a1.difference(new Point(this));\n\t        var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n\t        var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n\t        var a = dir.dot(mDir);\n\t        var b = dir.dot(mDiff);\n\t        var c = diff.dot(mDiff) - 1.0;\n\t        var d = b * b - a * c;\n\n\t        if (d < 0) {\n\t            return null;\n\t        } else if (d > 0) {\n\t            var root = sqrt(d);\n\t            var ta = (-b - root) / a;\n\t            var tb = (-b + root) / a;\n\n\t            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n\t                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n\t                return null;\n\t            } else {\n\t                if (0 <= ta && ta <= 1) { intersections.push(a1.lerp(a2, ta)); }\n\t                if (0 <= tb && tb <= 1) { intersections.push(a1.lerp(a2, tb)); }\n\t            }\n\t        } else {\n\t            var t = -b / a;\n\t            if (0 <= t && t <= 1) {\n\t                intersections.push(a1.lerp(a2, t));\n\t            } else {\n\t                // outside\n\t                return null;\n\t            }\n\t        }\n\n\t        return intersections;\n\t    },\n\n\t    // Find point on me where line from my center to\n\t    // point p intersects my boundary.\n\t    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n\t    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n\t        p = new Point(p);\n\n\t        if (angle) { p.rotate(new Point(this.x, this.y), angle); }\n\n\t        var dx = p.x - this.x;\n\t        var dy = p.y - this.y;\n\t        var result;\n\n\t        if (dx === 0) {\n\t            result = this.bbox().pointNearestToPoint(p);\n\t            if (angle) { return result.rotate(new Point(this.x, this.y), -angle); }\n\t            return result;\n\t        }\n\n\t        var m = dy / dx;\n\t        var mSquared = m * m;\n\t        var aSquared = this.a * this.a;\n\t        var bSquared = this.b * this.b;\n\n\t        var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\n\t        x = dx < 0 ? -x : x;\n\n\t        var y = m * x;\n\t        result = new Point(this.x + x, this.y + y);\n\n\t        if (angle) { return result.rotate(new Point(this.x, this.y), -angle); }\n\t        return result;\n\t    },\n\n\t    /**\n\t     * @param {g.Point} point\n\t     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n\t     */\n\t    normalizedDistance: function(point) {\n\n\t        var x0 = point.x;\n\t        var y0 = point.y;\n\t        var a = this.a;\n\t        var b = this.b;\n\t        var x = this.x;\n\t        var y = this.y;\n\n\t        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n\t    },\n\n\t    round: function(precision) {\n\n\t        var f = 1; // case 0\n\t        if (precision) {\n\t            switch (precision) {\n\t                case 1: f = 10; break;\n\t                case 2: f = 100; break;\n\t                case 3: f = 1000; break;\n\t                default: f = pow(10, precision); break;\n\t            }\n\t        }\n\n\t        this.x = round(this.x * f) / f;\n\t        this.y = round(this.y * f) / f;\n\t        this.a = round(this.a * f) / f;\n\t        this.b = round(this.b * f) / f;\n\t        return this;\n\t    },\n\n\t    /** Compute angle between tangent and x axis\n\t     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n\t     * @returns {number} angle between tangent and x axis\n\t     */\n\t    tangentTheta: function(p) {\n\n\t        var refPointDelta = 30;\n\t        var x0 = p.x;\n\t        var y0 = p.y;\n\t        var a = this.a;\n\t        var b = this.b;\n\t        var center = this.bbox().center();\n\t        var m = center.x;\n\t        var n = center.y;\n\n\t        var q1 = x0 > center.x + a / 2;\n\t        var q3 = x0 < center.x - a / 2;\n\n\t        var y, x;\n\t        if (q1 || q3) {\n\t            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n\t            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n\t        } else {\n\t            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n\t            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n\t        }\n\n\t        return (new Point(x, y)).theta(p);\n\n\t    },\n\n\t    toString: function() {\n\n\t        return (new Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n\t    }\n\t};\n\n\tvar Line = function(p1, p2) {\n\n\t    if (!(this instanceof Line)) {\n\t        return new Line(p1, p2);\n\t    }\n\n\t    if (p1 instanceof Line) {\n\t        return new Line(p1.start, p1.end);\n\t    }\n\n\t    this.start = new Point(p1);\n\t    this.end = new Point(p2);\n\t};\n\n\tLine.prototype = {\n\n\t    // @returns the angle of incline of the line.\n\t    angle: function() {\n\n\t        var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n\t        return this.start.angleBetween(this.end, horizontalPoint);\n\t    },\n\n\t    bbox: function() {\n\n\t        var left = min$3(this.start.x, this.end.x);\n\t        var top = min$3(this.start.y, this.end.y);\n\t        var right = max$1(this.start.x, this.end.x);\n\t        var bottom = max$1(this.start.y, this.end.y);\n\n\t        return new Rect(left, top, (right - left), (bottom - top));\n\t    },\n\n\t    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n\t    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\t    bearing: function() {\n\n\t        var lat1 = toRad(this.start.y);\n\t        var lat2 = toRad(this.end.y);\n\t        var lon1 = this.start.x;\n\t        var lon2 = this.end.x;\n\t        var dLon = toRad(lon2 - lon1);\n\t        var y = sin(dLon) * cos(lat2);\n\t        var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n\t        var brng = toDeg(atan2(y, x));\n\n\t        var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\n\t        var index = brng - 22.5;\n\t        if (index < 0)\n\t            { index += 360; }\n\t        index = parseInt(index / 45);\n\n\t        return bearings[index];\n\t    },\n\n\t    clone: function() {\n\n\t        return new Line(this.start, this.end);\n\t    },\n\n\t    // @return {point} the closest point on the line to point `p`\n\t    closestPoint: function(p) {\n\n\t        return this.pointAt(this.closestPointNormalizedLength(p));\n\t    },\n\n\t    closestPointLength: function(p) {\n\n\t        return this.closestPointNormalizedLength(p) * this.length();\n\t    },\n\n\t    // @return {number} the normalized length of the closest point on the line to point `p`\n\t    closestPointNormalizedLength: function(p) {\n\n\t        var product = this.vector().dot((new Line(this.start, p)).vector());\n\t        var cpNormalizedLength = min$3(1, max$1(0, product / this.squaredLength()));\n\n\t        // cpNormalizedLength returns `NaN` if this line has zero length\n\t        // we can work with that - if `NaN`, return 0\n\t        if (cpNormalizedLength !== cpNormalizedLength) { return 0; } // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n\t        // (`NaN` is the only value that is not equal to itself)\n\n\t        return cpNormalizedLength;\n\t    },\n\n\t    closestPointTangent: function(p) {\n\n\t        return this.tangentAt(this.closestPointNormalizedLength(p));\n\t    },\n\n\t    // Returns `true` if the point lies on the line.\n\t    containsPoint: function(p) {\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        if (start.cross(p, end) !== 0) { return false; }\n\t        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n\t        var length = this.length();\n\t        if ((new Line(start, p)).length() > length) { return false; }\n\t        if ((new Line(p, end)).length() > length) { return false; }\n\t        // else: `p` lies between start and end of the line\n\n\t        return true;\n\t    },\n\n\t    // Divides the line into two at requested `ratio` between 0 and 1.\n\t    divideAt: function(ratio) {\n\n\t        var dividerPoint = this.pointAt(ratio);\n\n\t        // return array with two lines\n\t        return [\n\t            new Line(this.start, dividerPoint),\n\t            new Line(dividerPoint, this.end)\n\t        ];\n\t    },\n\n\t    // Divides the line into two at requested `length`.\n\t    divideAtLength: function(length) {\n\n\t        var dividerPoint = this.pointAtLength(length);\n\n\t        // return array with two new lines\n\t        return [\n\t            new Line(this.start, dividerPoint),\n\t            new Line(dividerPoint, this.end)\n\t        ];\n\t    },\n\n\t    equals: function(l) {\n\n\t        return !!l &&\n\t            this.start.x === l.start.x &&\n\t            this.start.y === l.start.y &&\n\t            this.end.x === l.end.x &&\n\t            this.end.y === l.end.y;\n\t    },\n\n\t    // @return {point} Point where I'm intersecting a line.\n\t    // @return [point] Points where I'm intersecting a rectangle.\n\t    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n\t    intersect: function(shape, opt) {\n\n\t        if (shape instanceof Line ||\n\t            shape instanceof Rect ||\n\t            shape instanceof Polyline ||\n\t            shape instanceof Ellipse ||\n\t            shape instanceof Path\n\t        ) {\n\t            var intersection = shape.intersectionWithLine(this, opt);\n\n\t            // Backwards compatibility\n\t            if (intersection && (shape instanceof Line)) {\n\t                intersection = intersection[0];\n\t            }\n\n\t            return intersection;\n\t        }\n\n\t        return null;\n\t    },\n\n\t    intersectionWithLine: function(line) {\n\n\t        var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n\t        var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n\t        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n\t        var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n\t        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n\t        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n\t        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n\t            // No intersection found.\n\t            return null;\n\t        }\n\n\t        if (det > 0) {\n\t            if (alpha > det || beta > det) {\n\t                return null;\n\t            }\n\n\t        } else {\n\t            if (alpha < det || beta < det) {\n\t                return null;\n\t            }\n\t        }\n\n\t        return [new Point(\n\t            this.start.x + (alpha * pt1Dir.x / det),\n\t            this.start.y + (alpha * pt1Dir.y / det)\n\t        )];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        return !this.start.equals(this.end);\n\t    },\n\n\t    // @return {double} length of the line\n\t    length: function() {\n\n\t        return sqrt(this.squaredLength());\n\t    },\n\n\t    // @return {point} my midpoint\n\t    midpoint: function() {\n\n\t        return new Point(\n\t            (this.start.x + this.end.x) / 2,\n\t            (this.start.y + this.end.y) / 2\n\t        );\n\t    },\n\n\t    parallel: function(distance) {\n\t        var l = this.clone();\n\t        if (!this.isDifferentiable()) { return l; }\n\t        var start = l.start;\n\t        var end = l.end;\n\t        var eRef = start.clone().rotate(end, 270);\n\t        var sRef = end.clone().rotate(start, 90);\n\t        start.move(sRef, distance);\n\t        end.move(eRef, distance);\n\t        return l;\n\t    },\n\n\t    // @return {point} my point at 't' <0,1>\n\t    pointAt: function(t) {\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        if (t <= 0) { return start.clone(); }\n\t        if (t >= 1) { return end.clone(); }\n\n\t        return start.lerp(end, t);\n\t    },\n\n\t    pointAtLength: function(length) {\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        var lineLength = this.length();\n\t        if (length >= lineLength) { return (fromStart ? end.clone() : start.clone()); }\n\n\t        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n\t    },\n\n\t    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n\t    pointOffset: function(p) {\n\n\t        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n\t        p = new Point(p);\n\t        var start = this.start;\n\t        var end = this.end;\n\t        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n\t        return determinant / this.length();\n\t    },\n\n\t    rotate: function(origin, angle) {\n\n\t        this.start.rotate(origin, angle);\n\t        this.end.rotate(origin, angle);\n\t        return this;\n\t    },\n\n\t    round: function(precision) {\n\n\t        this.start.round(precision);\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.start.scale(sx, sy, origin);\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    // @return {number} scale the line so that it has the requested length\n\t    setLength: function(length) {\n\n\t        var currentLength = this.length();\n\t        if (!currentLength) { return this; }\n\n\t        var scaleFactor = length / currentLength;\n\t        return this.scale(scaleFactor, scaleFactor, this.start);\n\t    },\n\n\t    // @return {integer} length without sqrt\n\t    // @note for applications where the exact length is not necessary (e.g. compare only)\n\t    squaredLength: function() {\n\n\t        var x0 = this.start.x;\n\t        var y0 = this.start.y;\n\t        var x1 = this.end.x;\n\t        var y1 = this.end.y;\n\t        return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n\t    },\n\n\t    tangentAt: function(t) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n\t        var tangentLine = new Line(start, end);\n\t        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n\t        return tangentLine;\n\t    },\n\n\t    tangentAtLength: function(length) {\n\n\t        if (!this.isDifferentiable()) { return null; }\n\n\t        var start = this.start;\n\t        var end = this.end;\n\n\t        var tangentStart = this.pointAtLength(length);\n\n\t        var tangentLine = new Line(start, end);\n\t        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n\t        return tangentLine;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.start.toString() + ' ' + this.end.toString();\n\t    },\n\n\t    serialize: function() {\n\n\t        return this.start.serialize() + ' ' + this.end.serialize();\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.start.translate(tx, ty);\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    },\n\n\t    // @return vector {point} of the line\n\t    vector: function() {\n\n\t        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n\t    }\n\t};\n\n\t// For backwards compatibility:\n\tLine.prototype.intersection = Line.prototype.intersect;\n\n\t// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n\t// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\n\tvar Path = function(arg) {\n\n\t    if (!(this instanceof Path)) {\n\t        return new Path(arg);\n\t    }\n\n\t    if (typeof arg === 'string') { // create from a path data string\n\t        return new Path.parse(arg);\n\t    }\n\n\t    this.segments = [];\n\n\t    var i;\n\t    var n;\n\n\t    if (!arg) {\n\t        // don't do anything\n\n\t    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n\t        // flatten one level deep\n\t        // so we can chain arbitrary Path.createSegment results\n\t        arg = arg.reduce(function(acc, val) {\n\t            return acc.concat(val);\n\t        }, []);\n\n\t        n = arg.length;\n\t        if (arg[0].isSegment) { // create from an array of segments\n\t            for (i = 0; i < n; i++) {\n\n\t                var segment = arg[i];\n\n\t                this.appendSegment(segment);\n\t            }\n\n\t        } else { // create from an array of Curves and/or Lines\n\t            var previousObj = null;\n\t            for (i = 0; i < n; i++) {\n\n\t                var obj = arg[i];\n\n\t                if (!((obj instanceof Line) || (obj instanceof Curve))) {\n\t                    throw new Error('Cannot construct a path segment from the provided object.');\n\t                }\n\n\t                if (i === 0) { this.appendSegment(Path.createSegment('M', obj.start)); }\n\n\t                // if objects do not link up, moveto segments are inserted to cover the gaps\n\t                if (previousObj && !previousObj.end.equals(obj.start)) { this.appendSegment(Path.createSegment('M', obj.start)); }\n\n\t                if (obj instanceof Line) {\n\t                    this.appendSegment(Path.createSegment('L', obj.end));\n\n\t                } else if (obj instanceof Curve) {\n\t                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n\t                }\n\n\t                previousObj = obj;\n\t            }\n\t        }\n\n\t    } else if (arg.isSegment) { // create from a single segment\n\t        this.appendSegment(arg);\n\n\t    } else if (arg instanceof Line) { // create from a single Line\n\t        this.appendSegment(Path.createSegment('M', arg.start));\n\t        this.appendSegment(Path.createSegment('L', arg.end));\n\n\t    } else if (arg instanceof Curve) { // create from a single Curve\n\t        this.appendSegment(Path.createSegment('M', arg.start));\n\t        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n\t    } else if (arg instanceof Polyline) { // create from a Polyline\n\t        if (!(arg.points && (arg.points.length !== 0))) { return; } // if Polyline has no points, leave Path empty\n\n\t        n = arg.points.length;\n\t        for (i = 0; i < n; i++) {\n\n\t            var point = arg.points[i];\n\n\t            if (i === 0) { this.appendSegment(Path.createSegment('M', point)); }\n\t            else { this.appendSegment(Path.createSegment('L', point)); }\n\t        }\n\n\t    } else { // unknown object\n\t        throw new Error('Cannot construct a path from the provided object.');\n\t    }\n\t};\n\n\t// More permissive than V.normalizePathData and Path.prototype.serialize.\n\t// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n\t// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n\t// Allows for command argument chaining.\n\t// Throws an error if wrong number of arguments is provided with a command.\n\t// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\n\tPath.parse = function(pathData) {\n\n\t    if (!pathData) { return new Path(); }\n\n\t    var path = new Path();\n\n\t    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n\t    var commands = pathData.match(commandRe);\n\n\t    var numCommands = commands.length;\n\t    for (var i = 0; i < numCommands; i++) {\n\n\t        var command = commands[i];\n\t        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n\t        var args = command.match(argRe);\n\n\t        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n\t        path.appendSegment(segment);\n\t    }\n\n\t    return path;\n\t};\n\n\t// Create a segment or an array of segments.\n\t// Accepts unlimited points/coords arguments after `type`.\n\tPath.createSegment = function(type) {\n\t    var arguments$1 = arguments;\n\n\n\t    if (!type) { throw new Error('Type must be provided.'); }\n\n\t    var segmentConstructor = Path.segmentTypes[type];\n\t    if (!segmentConstructor) { throw new Error(type + ' is not a recognized path segment type.'); }\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    return applyToNew(segmentConstructor, args);\n\t};\n\n\tPath.prototype = {\n\n\t    // Accepts one segment or an array of segments as argument.\n\t    // Throws an error if argument is not a segment or an array of segments.\n\t    appendSegment: function(arg) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        // works even if path has no segments\n\n\t        var currentSegment;\n\n\t        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n\t        var nextSegment = null;\n\n\t        if (!Array.isArray(arg)) { // arg is a segment\n\t            if (!arg || !arg.isSegment) { throw new Error('Segment required.'); }\n\n\t            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t            segments.push(currentSegment);\n\n\t        } else { // arg is an array of segments\n\t            // flatten one level deep\n\t            // so we can chain arbitrary Path.createSegment results\n\t            arg = arg.reduce(function(acc, val) {\n\t                return acc.concat(val);\n\t            }, []);\n\n\t            if (!arg[0].isSegment) { throw new Error('Segments required.'); }\n\n\t            var n = arg.length;\n\t            for (var i = 0; i < n; i++) {\n\n\t                var currentArg = arg[i];\n\t                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t                segments.push(currentSegment);\n\t                previousSegment = currentSegment;\n\t            }\n\t        }\n\t    },\n\n\t    // Returns the bbox of the path.\n\t    // If path has no segments, returns null.\n\t    // If path has only invisible segments, returns bbox of the end point of last segment.\n\t    bbox: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var bbox;\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            if (segment.isVisible) {\n\t                var segmentBBox = segment.bbox();\n\t                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n\t            }\n\t        }\n\n\t        if (bbox) { return bbox; }\n\n\t        // if the path has only invisible elements, return end point of last segment\n\t        var lastSegment = segments[numSegments - 1];\n\t        return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n\t    },\n\n\t    // Returns a new path that is a clone of this path.\n\t    clone: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        // works even if path has no segments\n\n\t        var path = new Path();\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i].clone();\n\t            path.appendSegment(segment);\n\t        }\n\n\t        return path;\n\t    },\n\n\t    closestPoint: function(p, opt) {\n\n\t        var t = this.closestPointT(p, opt);\n\t        if (!t) { return null; }\n\n\t        return this.pointAtT(t);\n\t    },\n\n\t    closestPointLength: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var t = this.closestPointT(p, localOpt);\n\t        if (!t) { return 0; }\n\n\t        return this.lengthAtT(t, localOpt);\n\t    },\n\n\t    closestPointNormalizedLength: function(p, opt) {\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var cpLength = this.closestPointLength(p, localOpt);\n\t        if (cpLength === 0) { return 0; } // shortcut\n\n\t        var length = this.length(localOpt);\n\t        if (length === 0) { return 0; } // prevents division by zero\n\n\t        return cpLength / length;\n\t    },\n\n\t    // Private function.\n\t    closestPointT: function(p, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var closestPointT;\n\t        var minSquaredDistance = Infinity;\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var subdivisions = segmentSubdivisions[i];\n\n\t            if (segment.isVisible) {\n\t                var segmentClosestPointT = segment.closestPointT(p, {\n\t                    precision: precision,\n\t                    subdivisions: subdivisions\n\t                });\n\t                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n\t                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n\t                if (squaredDistance < minSquaredDistance) {\n\t                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n\t                    minSquaredDistance = squaredDistance;\n\t                }\n\t            }\n\t        }\n\n\t        if (closestPointT) { return closestPointT; }\n\n\t        // if no visible segment, return end of last segment\n\t        return { segmentIndex: numSegments - 1, value: 1 };\n\t    },\n\n\t    closestPointTangent: function(p, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var closestPointTangent;\n\t        var minSquaredDistance = Infinity;\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var subdivisions = segmentSubdivisions[i];\n\n\t            if (segment.isDifferentiable()) {\n\t                var segmentClosestPointT = segment.closestPointT(p, {\n\t                    precision: precision,\n\t                    subdivisions: subdivisions\n\t                });\n\t                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n\t                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n\t                if (squaredDistance < minSquaredDistance) {\n\t                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n\t                    minSquaredDistance = squaredDistance;\n\t                }\n\t            }\n\t        }\n\n\t        if (closestPointTangent) { return closestPointTangent; }\n\n\t        // if no valid segment, return null\n\t        return null;\n\t    },\n\n\t    // Returns `true` if the area surrounded by the path contains the point `p`.\n\t    // Implements the even-odd algorithm (self-intersections are \"outside\").\n\t    // Closes open paths (always imagines a final closing segment).\n\t    // Precision may be adjusted by passing an `opt` object.\n\t    containsPoint: function(p, opt) {\n\n\t        var polylines = this.toPolylines(opt);\n\t        if (!polylines) { return false; } // shortcut (this path has no polylines)\n\n\t        var numPolylines = polylines.length;\n\n\t        // how many component polylines does `p` lie within?\n\t        var numIntersections = 0;\n\t        for (var i = 0; i < numPolylines; i++) {\n\t            var polyline = polylines[i];\n\t            if (polyline.containsPoint(p)) {\n\t                // `p` lies within this polyline\n\t                numIntersections++;\n\t            }\n\t        }\n\n\t        // returns `true` for odd numbers of intersections (even-odd algorithm)\n\t        return ((numIntersections % 2) === 1);\n\t    },\n\n\t    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    divideAt: function(ratio, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        if (ratio > 1) { ratio = 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var pathLength = this.length(localOpt);\n\t        var length = pathLength * ratio;\n\n\t        return this.divideAtLength(length, localOpt);\n\t    },\n\n\t    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n\t    divideAtLength: function(length, opt) {\n\n\t        var numSegments = this.segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var i;\n\t        var segment;\n\n\t        // identify the segment to divide:\n\n\t        var l = 0; // length so far\n\t        var divided;\n\t        var dividedSegmentIndex;\n\t        var lastValidSegment; // visible AND differentiable\n\t        var lastValidSegmentIndex;\n\t        var t;\n\t        for (i = 0; i < numSegments; i++) {\n\t            var index = (fromStart ? i : (numSegments - 1 - i));\n\n\t            segment = this.getSegment(index);\n\t            var subdivisions = segmentSubdivisions[index];\n\t            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n\t            if (segment.isDifferentiable()) { // segment is not just a point\n\t                lastValidSegment = segment;\n\t                lastValidSegmentIndex = index;\n\n\t                if (length <= (l + d)) {\n\t                    dividedSegmentIndex = index;\n\t                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n\t                        precision: precision,\n\t                        subdivisions: subdivisions\n\t                    });\n\t                    break;\n\t                }\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        if (!lastValidSegment) { // no valid segment found\n\t            return null;\n\t        }\n\n\t        // else: the path contains at least one valid segment\n\n\t        if (!divided) { // the desired length is greater than the length of the path\n\t            dividedSegmentIndex = lastValidSegmentIndex;\n\t            t = (fromStart ? 1 : 0);\n\t            divided = lastValidSegment.divideAtT(t);\n\t        }\n\n\t        // create a copy of this path and replace the identified segment with its two divided parts:\n\n\t        var pathCopy = this.clone();\n\t        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n\t        var divisionStartIndex = dividedSegmentIndex;\n\t        var divisionMidIndex = dividedSegmentIndex + 1;\n\t        var divisionEndIndex = dividedSegmentIndex + 2;\n\n\t        // do not insert the part if it looks like a point\n\t        if (!divided[0].isDifferentiable()) {\n\t            pathCopy.removeSegment(divisionStartIndex);\n\t            divisionMidIndex -= 1;\n\t            divisionEndIndex -= 1;\n\t        }\n\n\t        // insert a Moveto segment to ensure secondPath will be valid:\n\t        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n\t        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n\t        divisionEndIndex += 1;\n\n\t        // do not insert the part if it looks like a point\n\t        if (!divided[1].isDifferentiable()) {\n\t            pathCopy.removeSegment(divisionEndIndex - 1);\n\t            divisionEndIndex -= 1;\n\t        }\n\n\t        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\t        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\t        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n\t            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n\t            segment = pathCopy.getSegment(i);\n\n\t            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n\t                // pathCopy segment's subpathStartSegment is different from original segment's one\n\t                // convert this Closepath segment to a Lineto and replace it in pathCopy\n\t                var convertedSegment = Path.createSegment('L', originalSegment.end);\n\t                pathCopy.replaceSegment(i, convertedSegment);\n\t            }\n\t        }\n\n\t        // distribute pathCopy segments into two paths and return those:\n\n\t        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n\t        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n\t        return [firstPath, secondPath];\n\t    },\n\n\t    // Checks whether two paths are exactly the same.\n\t    // If `p` is undefined or null, returns false.\n\t    equals: function(p) {\n\n\t        if (!p) { return false; }\n\n\t        var segments = this.segments;\n\t        var otherSegments = p.segments;\n\n\t        var numSegments = segments.length;\n\t        if (otherSegments.length !== numSegments) { return false; } // if the two paths have different number of segments, they cannot be equal\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var otherSegment = otherSegments[i];\n\n\t            // as soon as an inequality is found in segments, return false\n\t            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) { return false; }\n\t        }\n\n\t        // if no inequality found in segments, return true\n\t        return true;\n\t    },\n\n\t    // Accepts negative indices.\n\t    // Throws an error if path has no segments.\n\t    // Throws an error if index is out of range.\n\t    getSegment: function(index) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { throw new Error('Path has no segments.'); }\n\n\t        if (index < 0) { index = numSegments + index; } // convert negative indices to positive\n\t        if (index >= numSegments || index < 0) { throw new Error('Index out of range.'); }\n\n\t        return segments[index];\n\t    },\n\n\t    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n\t    getSegmentSubdivisions: function(opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        // works even if path has no segments\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        // not using opt.segmentSubdivisions\n\t        // not using localOpt\n\n\t        var segmentSubdivisions = [];\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var subdivisions = segment.getSubdivisions({ precision: precision });\n\t            segmentSubdivisions.push(subdivisions);\n\t        }\n\n\t        return segmentSubdivisions;\n\t    },\n\n\t    // Returns an array of subpaths of this path.\n\t    // Invalid paths are validated first.\n\t    // Returns `[]` if path has no segments.\n\t    getSubpaths: function() {\n\n\t        var validatedPath = this.clone().validate();\n\n\t        var segments = validatedPath.segments;\n\t        var numSegments = segments.length;\n\n\t        var subpaths = [];\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            if (segment.isSubpathStart) {\n\t                // we encountered a subpath start segment\n\t                // create a new path for segment, and push it to list of subpaths\n\t                subpaths.push(new Path(segment));\n\n\t            } else {\n\t                // append current segment to the last subpath\n\t                subpaths[subpaths.length - 1].appendSegment(segment);\n\t            }\n\t        }\n\n\t        return subpaths;\n\t    },\n\n\t    // Insert `arg` at given `index`.\n\t    // `index = 0` means insert at the beginning.\n\t    // `index = segments.length` means insert at the end.\n\t    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n\t    // Accepts one segment or an array of segments as argument.\n\t    // Throws an error if index is out of range.\n\t    // Throws an error if argument is not a segment or an array of segments.\n\t    insertSegment: function(index, arg) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        // works even if path has no segments\n\n\t        // note that these are incremented comapared to getSegments()\n\t        // we can insert after last element (note that this changes the meaning of index -1)\n\t        if (index < 0) { index = numSegments + index + 1; } // convert negative indices to positive\n\t        if (index > numSegments || index < 0) { throw new Error('Index out of range.'); }\n\n\t        var currentSegment;\n\n\t        var previousSegment = null;\n\t        var nextSegment = null;\n\n\t        if (numSegments !== 0) {\n\t            if (index >= 1) {\n\t                previousSegment = segments[index - 1];\n\t                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n\t            } else { // if index === 0\n\t                // previousSegment is null\n\t                nextSegment = segments[0];\n\t            }\n\t        }\n\n\t        if (!Array.isArray(arg)) {\n\t            if (!arg || !arg.isSegment) { throw new Error('Segment required.'); }\n\n\t            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t            segments.splice(index, 0, currentSegment);\n\n\t        } else {\n\t            // flatten one level deep\n\t            // so we can chain arbitrary Path.createSegment results\n\t            arg = arg.reduce(function(acc, val) {\n\t                return acc.concat(val);\n\t            }, []);\n\n\t            if (!arg[0].isSegment) { throw new Error('Segments required.'); }\n\n\t            var n = arg.length;\n\t            for (var i = 0; i < n; i++) {\n\n\t                var currentArg = arg[i];\n\t                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\t                previousSegment = currentSegment;\n\t            }\n\t        }\n\t    },\n\n\t    intersectionWithLine: function(line, opt) {\n\n\t        var intersection = null;\n\t        var polylines = this.toPolylines(opt);\n\t        if (!polylines) { return null; }\n\t        for (var i = 0, n = polylines.length; i < n; i++) {\n\t            var polyline = polylines[i];\n\t            var polylineIntersection = line.intersect(polyline);\n\t            if (polylineIntersection) {\n\t                intersection || (intersection = []);\n\t                if (Array.isArray(polylineIntersection)) {\n\t                    Array.prototype.push.apply(intersection, polylineIntersection);\n\t                } else {\n\t                    intersection.push(polylineIntersection);\n\t                }\n\t            }\n\t        }\n\n\t        return intersection;\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            // as soon as a differentiable segment is found in segments, return true\n\t            if (segment.isDifferentiable()) { return true; }\n\t        }\n\n\t        // if no differentiable segment is found in segments, return false\n\t        return false;\n\t    },\n\n\t    // Checks whether current path segments are valid.\n\t    // Note that d is allowed to be empty - should disable rendering of the path.\n\t    isValid: function() {\n\n\t        var segments = this.segments;\n\t        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n\t        return isValid;\n\t    },\n\n\t    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n\t    // If path has no segments, returns 0.\n\t    length: function(opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return 0; } // if segments is an empty array\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var length = 0;\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            var subdivisions = segmentSubdivisions[i];\n\t            length += segment.length({ subdivisions: subdivisions });\n\t        }\n\n\t        return length;\n\t    },\n\n\t    // Private function.\n\t    lengthAtT: function(t, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return 0; } // if segments is an empty array\n\n\t        var segmentIndex = t.segmentIndex;\n\t        if (segmentIndex < 0) { return 0; } // regardless of t.value\n\n\t        var tValue = t.value;\n\t        if (segmentIndex >= numSegments) {\n\t            segmentIndex = numSegments - 1;\n\t            tValue = 1;\n\t        } else if (tValue < 0) { tValue = 0; }\n\t        else if (tValue > 1) { tValue = 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var subdivisions;\n\t        var length = 0;\n\t        for (var i = 0; i < segmentIndex; i++) {\n\n\t            var segment = segments[i];\n\t            subdivisions = segmentSubdivisions[i];\n\t            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n\t        }\n\n\t        segment = segments[segmentIndex];\n\t        subdivisions = segmentSubdivisions[segmentIndex];\n\t        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n\t        return length;\n\t    },\n\n\t    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t    pointAt: function(ratio, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (ratio <= 0) { return this.start.clone(); }\n\t        if (ratio >= 1) { return this.end.clone(); }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var pathLength = this.length(localOpt);\n\t        var length = pathLength * ratio;\n\n\t        return this.pointAtLength(length, localOpt);\n\t    },\n\n\t    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t    // Accepts negative length.\n\t    pointAtLength: function(length, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (length === 0) { return this.start.clone(); }\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var lastVisibleSegment;\n\t        var l = 0; // length so far\n\t        for (var i = 0; i < numSegments; i++) {\n\t            var index = (fromStart ? i : (numSegments - 1 - i));\n\n\t            var segment = segments[index];\n\t            var subdivisions = segmentSubdivisions[index];\n\t            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n\t            if (segment.isVisible) {\n\t                if (length <= (l + d)) {\n\t                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n\t                        precision: precision,\n\t                        subdivisions: subdivisions\n\t                    });\n\t                }\n\n\t                lastVisibleSegment = segment;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the path, return last visible segment endpoint\n\t        if (lastVisibleSegment) { return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start); }\n\n\t        // if no visible segment, return last segment end point (no matter if fromStart or no)\n\t        var lastSegment = segments[numSegments - 1];\n\t        return lastSegment.end.clone();\n\t    },\n\n\t    // Private function.\n\t    pointAtT: function(t) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var segmentIndex = t.segmentIndex;\n\t        if (segmentIndex < 0) { return segments[0].pointAtT(0); }\n\t        if (segmentIndex >= numSegments) { return segments[numSegments - 1].pointAtT(1); }\n\n\t        var tValue = t.value;\n\t        if (tValue < 0) { tValue = 0; }\n\t        else if (tValue > 1) { tValue = 1; }\n\n\t        return segments[segmentIndex].pointAtT(tValue);\n\t    },\n\n\t    // Default precision\n\t    PRECISION: 3,\n\n\t    // Helper method for adding segments.\n\t    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n\t        // insert after previous segment and before previous segment's next segment\n\t        segment.previousSegment = previousSegment;\n\t        segment.nextSegment = nextSegment;\n\t        if (previousSegment) { previousSegment.nextSegment = segment; }\n\t        if (nextSegment) { nextSegment.previousSegment = segment; }\n\n\t        var updateSubpathStart = segment;\n\t        if (segment.isSubpathStart) {\n\t            segment.subpathStartSegment = segment; // assign self as subpath start segment\n\t            updateSubpathStart = nextSegment; // start updating from next segment\n\t        }\n\n\t        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\t        if (updateSubpathStart) { this.updateSubpathStartSegment(updateSubpathStart); }\n\n\t        return segment;\n\t    },\n\n\t    // Remove the segment at `index`.\n\t    // Accepts negative indices, from `-1` to `-segments.length`.\n\t    // Throws an error if path has no segments.\n\t    // Throws an error if index is out of range.\n\t    removeSegment: function(index) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { throw new Error('Path has no segments.'); }\n\n\t        if (index < 0) { index = numSegments + index; } // convert negative indices to positive\n\t        if (index >= numSegments || index < 0) { throw new Error('Index out of range.'); }\n\n\t        var removedSegment = segments.splice(index, 1)[0];\n\t        var previousSegment = removedSegment.previousSegment;\n\t        var nextSegment = removedSegment.nextSegment;\n\n\t        // link the previous and next segments together (if present)\n\t        if (previousSegment) { previousSegment.nextSegment = nextSegment; } // may be null\n\t        if (nextSegment) { nextSegment.previousSegment = previousSegment; } // may be null\n\n\t        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n\t        if (removedSegment.isSubpathStart && nextSegment) { this.updateSubpathStartSegment(nextSegment); }\n\t    },\n\n\t    // Replace the segment at `index` with `arg`.\n\t    // Accepts negative indices, from `-1` to `-segments.length`.\n\t    // Accepts one segment or an array of segments as argument.\n\t    // Throws an error if path has no segments.\n\t    // Throws an error if index is out of range.\n\t    // Throws an error if argument is not a segment or an array of segments.\n\t    replaceSegment: function(index, arg) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { throw new Error('Path has no segments.'); }\n\n\t        if (index < 0) { index = numSegments + index; } // convert negative indices to positive\n\t        if (index >= numSegments || index < 0) { throw new Error('Index out of range.'); }\n\n\t        var currentSegment;\n\n\t        var replacedSegment = segments[index];\n\t        var previousSegment = replacedSegment.previousSegment;\n\t        var nextSegment = replacedSegment.nextSegment;\n\n\t        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n\t        if (!Array.isArray(arg)) {\n\t            if (!arg || !arg.isSegment) { throw new Error('Segment required.'); }\n\n\t            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n\t            segments.splice(index, 1, currentSegment); // directly replace\n\n\t            if (updateSubpathStart && currentSegment.isSubpathStart) { updateSubpathStart = false; } // already updated by `prepareSegment`\n\n\t        } else {\n\t            // flatten one level deep\n\t            // so we can chain arbitrary Path.createSegment results\n\t            arg = arg.reduce(function(acc, val) {\n\t                return acc.concat(val);\n\t            }, []);\n\n\t            if (!arg[0].isSegment) { throw new Error('Segments required.'); }\n\n\t            segments.splice(index, 1);\n\n\t            var n = arg.length;\n\t            for (var i = 0; i < n; i++) {\n\n\t                var currentArg = arg[i];\n\t                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n\t                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\t                previousSegment = currentSegment;\n\n\t                if (updateSubpathStart && currentSegment.isSubpathStart) { updateSubpathStart = false; } // already updated by `prepareSegment`\n\t            }\n\t        }\n\n\t        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n\t        if (updateSubpathStart && nextSegment) { this.updateSubpathStartSegment(nextSegment); }\n\t    },\n\n\t    round: function(precision) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            segment.round(precision);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            segment.scale(sx, sy, origin);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    segmentAt: function(ratio, opt) {\n\n\t        var index = this.segmentIndexAt(ratio, opt);\n\t        if (!index) { return null; }\n\n\t        return this.getSegment(index);\n\t    },\n\n\t    // Accepts negative length.\n\t    segmentAtLength: function(length, opt) {\n\n\t        var index = this.segmentIndexAtLength(length, opt);\n\t        if (!index) { return null; }\n\n\t        return this.getSegment(index);\n\t    },\n\n\t    segmentIndexAt: function(ratio, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        if (ratio > 1) { ratio = 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var pathLength = this.length(localOpt);\n\t        var length = pathLength * ratio;\n\n\t        return this.segmentIndexAtLength(length, localOpt);\n\t    },\n\n\t    // Accepts negative length.\n\t    segmentIndexAtLength: function(length, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var lastVisibleSegmentIndex = null;\n\t        var l = 0; // length so far\n\t        for (var i = 0; i < numSegments; i++) {\n\t            var index = (fromStart ? i : (numSegments - 1 - i));\n\n\t            var segment = segments[index];\n\t            var subdivisions = segmentSubdivisions[index];\n\t            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n\t            if (segment.isVisible) {\n\t                if (length <= (l + d)) { return index; }\n\t                lastVisibleSegmentIndex = index;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the path, return last visible segment index\n\t        // if no visible segment, return null\n\t        return lastVisibleSegmentIndex;\n\t    },\n\n\t    // Returns a string that can be used to reconstruct the path.\n\t    // Additional error checking compared to toString (must start with M segment).\n\t    serialize: function() {\n\n\t        if (!this.isValid()) { throw new Error('Invalid path segments.'); }\n\n\t        return this.toString();\n\t    },\n\n\t    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t    tangentAt: function(ratio, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        if (ratio > 1) { ratio = 1; }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n\t        var pathLength = this.length(localOpt);\n\t        var length = pathLength * ratio;\n\n\t        return this.tangentAtLength(length, localOpt);\n\t    },\n\n\t    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n\t    // Accepts negative length.\n\t    tangentAtLength: function(length, opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\t        // not using localOpt\n\n\t        var lastValidSegment; // visible AND differentiable (with a tangent)\n\t        var l = 0; // length so far\n\t        for (var i = 0; i < numSegments; i++) {\n\t            var index = (fromStart ? i : (numSegments - 1 - i));\n\n\t            var segment = segments[index];\n\t            var subdivisions = segmentSubdivisions[index];\n\t            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n\t            if (segment.isDifferentiable()) {\n\t                if (length <= (l + d)) {\n\t                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n\t                        precision: precision,\n\t                        subdivisions: subdivisions\n\t                    });\n\t                }\n\n\t                lastValidSegment = segment;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\t        if (lastValidSegment) {\n\t            var t = (fromStart ? 1 : 0);\n\t            return lastValidSegment.tangentAtT(t);\n\t        }\n\n\t        // if no valid segment, return null\n\t        return null;\n\t    },\n\n\t    // Private function.\n\t    tangentAtT: function(t) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        var segmentIndex = t.segmentIndex;\n\t        if (segmentIndex < 0) { return segments[0].tangentAtT(0); }\n\t        if (segmentIndex >= numSegments) { return segments[numSegments - 1].tangentAtT(1); }\n\n\t        var tValue = t.value;\n\t        if (tValue < 0) { tValue = 0; }\n\t        else if (tValue > 1) { tValue = 1; }\n\n\t        return segments[segmentIndex].tangentAtT(tValue);\n\t    },\n\n\t    toPoints: function(opt) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; } // if segments is an empty array\n\n\t        opt = opt || {};\n\t        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n\t        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n\t        var points = [];\n\t        var partialPoints = [];\n\t        for (var i = 0; i < numSegments; i++) {\n\t            var segment = segments[i];\n\t            if (segment.isVisible) {\n\t                var currentSegmentSubdivisions = segmentSubdivisions[i];\n\t                if (currentSegmentSubdivisions.length > 0) {\n\t                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n\t                        return curve.start;\n\t                    });\n\t                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n\t                } else {\n\t                    partialPoints.push(segment.start);\n\t                }\n\t            } else if (partialPoints.length > 0) {\n\t                partialPoints.push(segments[i - 1].end);\n\t                points.push(partialPoints);\n\t                partialPoints = [];\n\t            }\n\t        }\n\n\t        if (partialPoints.length > 0) {\n\t            partialPoints.push(this.end);\n\t            points.push(partialPoints);\n\t        }\n\t        return points;\n\t    },\n\n\t    toPolylines: function(opt) {\n\n\t        var polylines = [];\n\t        var points = this.toPoints(opt);\n\t        if (!points) { return null; }\n\t        for (var i = 0, n = points.length; i < n; i++) {\n\t            polylines.push(new Polyline(points[i]));\n\t        }\n\n\t        return polylines;\n\t    },\n\n\t    toString: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        var pathData = '';\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            pathData += segment.serialize() + ' ';\n\t        }\n\n\t        return pathData.trim();\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            segment.translate(tx, ty);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    // Helper method for updating subpath start of segments, starting with the one provided.\n\t    updateSubpathStartSegment: function(segment) {\n\n\t        var previousSegment = segment.previousSegment; // may be null\n\t        while (segment && !segment.isSubpathStart) {\n\n\t            // assign previous segment's subpath start segment to this segment\n\t            if (previousSegment) { segment.subpathStartSegment = previousSegment.subpathStartSegment; } // may be null\n\t            else { segment.subpathStartSegment = null; } // if segment had no previous segment, assign null - creates an invalid path!\n\n\t            previousSegment = segment;\n\t            segment = segment.nextSegment; // move on to the segment after etc.\n\t        }\n\t    },\n\n\t    // If the path is not valid, insert M 0 0 at the beginning.\n\t    // Path with no segments is considered valid, so nothing is inserted.\n\t    validate: function() {\n\n\t        if (!this.isValid()) { this.insertSegment(0, Path.createSegment('M', 0, 0)); }\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(Path.prototype, 'start', {\n\t    // Getter for the first visible endpoint of the path.\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; }\n\n\t        for (var i = 0; i < numSegments; i++) {\n\n\t            var segment = segments[i];\n\t            if (segment.isVisible) { return segment.start; }\n\t        }\n\n\t        // if no visible segment, return last segment end point\n\t        return segments[numSegments - 1].end;\n\t    }\n\t});\n\n\tObject.defineProperty(Path.prototype, 'end', {\n\t    // Getter for the last visible endpoint of the path.\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        var segments = this.segments;\n\t        var numSegments = segments.length;\n\t        if (numSegments === 0) { return null; }\n\n\t        for (var i = numSegments - 1; i >= 0; i--) {\n\n\t            var segment = segments[i];\n\t            if (segment.isVisible) { return segment.end; }\n\t        }\n\n\t        // if no visible segment, return last segment end point\n\t        return segments[numSegments - 1].end;\n\t    }\n\t});\n\n\t/*\n\t    Point is the most basic object consisting of x/y coordinate.\n\n\t    Possible instantiations are:\n\t    * `Point(10, 20)`\n\t    * `new Point(10, 20)`\n\t    * `Point('10 20')`\n\t    * `Point(Point(10, 20))`\n\t*/\n\tvar Point = function(x, y) {\n\n\t    if (!(this instanceof Point)) {\n\t        return new Point(x, y);\n\t    }\n\n\t    if (typeof x === 'string') {\n\t        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n\t        x = parseFloat(xy[0]);\n\t        y = parseFloat(xy[1]);\n\n\t    } else if (Object(x) === x) {\n\t        y = x.y;\n\t        x = x.x;\n\t    }\n\n\t    this.x = x === undefined ? 0 : x;\n\t    this.y = y === undefined ? 0 : y;\n\t};\n\n\t// Alternative constructor, from polar coordinates.\n\t// @param {number} Distance.\n\t// @param {number} Angle in radians.\n\t// @param {point} [optional] Origin.\n\tPoint.fromPolar = function(distance, angle, origin) {\n\n\t    origin = new Point(origin);\n\t    var x = abs(distance * cos(angle));\n\t    var y = abs(distance * sin(angle));\n\t    var deg = normalizeAngle(toDeg(angle));\n\n\t    if (deg < 90) {\n\t        y = -y;\n\n\t    } else if (deg < 180) {\n\t        x = -x;\n\t        y = -y;\n\n\t    } else if (deg < 270) {\n\t        x = -x;\n\t    }\n\n\t    return new Point(origin.x + x, origin.y + y);\n\t};\n\n\t// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\n\tPoint.random = function(x1, x2, y1, y2) {\n\n\t    return new Point(random(x1, x2), random(y1, y2));\n\t};\n\n\tPoint.prototype = {\n\n\t    chooseClosest: function(points) {\n\n\t        var n = points.length;\n\t        if (n === 1) { return new Point(points[0]); }\n\t        var closest = null;\n\t        var minSqrDistance = Infinity;\n\t        for (var i = 0; i < n; i++) {\n\t            var p = new Point(points[i]);\n\t            var sqrDistance = this.squaredDistance(p);\n\t            if (sqrDistance < minSqrDistance) {\n\t                closest = p;\n\t                minSqrDistance = sqrDistance;\n\t            }\n\t        }\n\t        return closest;\n\t    },\n\n\t    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n\t    // otherwise return point itself.\n\t    // (see Squeak Smalltalk, Point>>adhereTo:)\n\t    adhereToRect: function(r) {\n\n\t        if (r.containsPoint(this)) {\n\t            return this;\n\t        }\n\n\t        this.x = min$3(max$1(this.x, r.x), r.x + r.width);\n\t        this.y = min$3(max$1(this.y, r.y), r.y + r.height);\n\t        return this;\n\t    },\n\n\t    // Compute the angle between vector from me to p1 and the vector from me to p2.\n\t    // ordering of points p1 and p2 is important!\n\t    // theta function's angle convention:\n\t    // returns angles between 0 and 180 when the angle is counterclockwise\n\t    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n\t    // returns NaN if any of the points p1, p2 is coincident with this point\n\t    angleBetween: function(p1, p2) {\n\n\t        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n\t        if (angleBetween < 0) {\n\t            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n\t        }\n\n\t        return angleBetween;\n\t    },\n\n\t    // Return the bearing between me and the given point.\n\t    bearing: function(point) {\n\n\t        return (new Line(this, point)).bearing();\n\t    },\n\n\t    // Returns change in angle from my previous position (-dx, -dy) to my new position\n\t    // relative to ref point.\n\t    changeInAngle: function(dx, dy, ref) {\n\n\t        // Revert the translation and measure the change in angle around x-axis.\n\t        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n\t    },\n\n\t    clone: function() {\n\n\t        return new Point(this);\n\t    },\n\n\t    // Returns the cross product of this point relative to two other points\n\t    // this point is the common point\n\t    // point p1 lies on the first vector, point p2 lies on the second vector\n\t    // watch out for the ordering of points p1 and p2!\n\t    // positive result indicates a clockwise (\"right\") turn from first to second vector\n\t    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n\t    // zero indicates that the first and second vector are collinear\n\t    // note that the above directions are reversed from the usual answer on the Internet\n\t    // that is because we are in a left-handed coord system (because the y-axis points downward)\n\t    cross: function(p1, p2) {\n\n\t        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n\t    },\n\n\t    difference: function(dx, dy) {\n\n\t        if ((Object(dx) === dx)) {\n\t            dy = dx.y;\n\t            dx = dx.x;\n\t        }\n\n\t        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n\t    },\n\n\t    // Returns distance between me and point `p`.\n\t    distance: function(p) {\n\n\t        return (new Line(this, p)).length();\n\t    },\n\n\t    // Returns the dot product of this point with given other point\n\t    dot: function(p) {\n\n\t        return p ? (this.x * p.x + this.y * p.y) : NaN;\n\t    },\n\n\t    equals: function(p) {\n\n\t        return !!p &&\n\t            this.x === p.x &&\n\t            this.y === p.y;\n\t    },\n\n\t    // Linear interpolation\n\t    lerp: function(p, t) {\n\n\t        var x = this.x;\n\t        var y = this.y;\n\t        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n\t    },\n\n\t    magnitude: function() {\n\n\t        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n\t    },\n\n\t    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n\t    manhattanDistance: function(p) {\n\n\t        return abs(p.x - this.x) + abs(p.y - this.y);\n\t    },\n\n\t    // Move point on line starting from ref ending at me by\n\t    // distance distance.\n\t    move: function(ref, distance) {\n\n\t        var theta = toRad((new Point(ref)).theta(this));\n\t        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n\t        return offset;\n\t    },\n\n\t    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n\t    normalize: function(length) {\n\n\t        var scale = (length || 1) / this.magnitude();\n\t        return this.scale(scale, scale);\n\t    },\n\n\t    // Offset me by the specified amount.\n\t    offset: function(dx, dy) {\n\n\t        if ((Object(dx) === dx)) {\n\t            dy = dx.y;\n\t            dx = dx.x;\n\t        }\n\n\t        this.x += dx || 0;\n\t        this.y += dy || 0;\n\t        return this;\n\t    },\n\n\t    // Returns a point that is the reflection of me with\n\t    // the center of inversion in ref point.\n\t    reflection: function(ref) {\n\n\t        return (new Point(ref)).move(this, this.distance(ref));\n\t    },\n\n\t    // Rotate point by angle around origin.\n\t    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n\t    rotate: function(origin, angle) {\n\n\t        if (angle === 0) { return this; }\n\n\t        origin = origin || new Point(0, 0);\n\n\t        angle = toRad(normalizeAngle(-angle));\n\t        var cosAngle = cos(angle);\n\t        var sinAngle = sin(angle);\n\n\t        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n\t        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n\t        this.x = x;\n\t        this.y = y;\n\t        return this;\n\t    },\n\n\t    round: function(precision) {\n\n\t        var f = 1; // case 0\n\t        if (precision) {\n\t            switch (precision) {\n\t                case 1: f = 10; break;\n\t                case 2: f = 100; break;\n\t                case 3: f = 1000; break;\n\t                default: f = pow(10, precision); break;\n\t            }\n\t        }\n\n\t        this.x = round(this.x * f) / f;\n\t        this.y = round(this.y * f) / f;\n\t        return this;\n\t    },\n\n\t    // Scale point with origin.\n\t    scale: function(sx, sy, origin) {\n\n\t        origin = (origin && new Point(origin)) || new Point(0, 0);\n\t        this.x = origin.x + sx * (this.x - origin.x);\n\t        this.y = origin.y + sy * (this.y - origin.y);\n\t        return this;\n\t    },\n\n\t    snapToGrid: function(gx, gy) {\n\n\t        this.x = snapToGrid(this.x, gx);\n\t        this.y = snapToGrid(this.y, gy || gx);\n\t        return this;\n\t    },\n\n\t    squaredDistance: function(p) {\n\n\t        return (new Line(this, p)).squaredLength();\n\t    },\n\n\t    // Compute the angle between me and `p` and the x axis.\n\t    // (cartesian-to-polar coordinates conversion)\n\t    // Return theta angle in degrees.\n\t    theta: function(p) {\n\n\t        p = new Point(p);\n\n\t        // Invert the y-axis.\n\t        var y = -(p.y - this.y);\n\t        var x = p.x - this.x;\n\t        var rad = atan2(y, x); // defined for all 0 corner cases\n\n\t        // Correction for III. and IV. quadrant.\n\t        if (rad < 0) {\n\t            rad = 2 * PI + rad;\n\t        }\n\n\t        return 180 * rad / PI;\n\t    },\n\n\t    toJSON: function() {\n\n\t        return { x: this.x, y: this.y };\n\t    },\n\n\t    // Converts rectangular to polar coordinates.\n\t    // An origin can be specified, otherwise it's 0@0.\n\t    toPolar: function(o) {\n\n\t        o = (o && new Point(o)) || new Point(0, 0);\n\t        var x = this.x;\n\t        var y = this.y;\n\t        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n\t        this.y = toRad(o.theta(new Point(x, y)));\n\t        return this;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.x + '@' + this.y;\n\t    },\n\n\t    serialize: function() {\n\n\t        return this.x + ',' + this.y;\n\t    },\n\n\t    update: function(x, y) {\n\n\t        this.x = x || 0;\n\t        this.y = y || 0;\n\t        return this;\n\t    },\n\n\t    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n\t    // Returns NaN if p is at 0,0.\n\t    vectorAngle: function(p) {\n\n\t        var zero = new Point(0, 0);\n\t        return zero.angleBetween(this, p);\n\t    }\n\t};\n\n\tPoint.prototype.translate = Point.prototype.offset;\n\n\tvar Polyline = function(points) {\n\n\t    if (!(this instanceof Polyline)) {\n\t        return new Polyline(points);\n\t    }\n\n\t    if (typeof points === 'string') {\n\t        return new Polyline.parse(points);\n\t    }\n\n\t    this.points = (Array.isArray(points) ? points.map(Point) : []);\n\t};\n\n\tPolyline.parse = function(svgString) {\n\t    svgString = svgString.trim();\n\t    if (svgString === '') { return new Polyline(); }\n\n\t    var points = [];\n\n\t    var coords = svgString.split(/\\s*,\\s*|\\s+/);\n\t    var n = coords.length;\n\t    for (var i = 0; i < n; i += 2) {\n\t        points.push({ x: +coords[i], y: +coords[i + 1] });\n\t    }\n\n\t    return new Polyline(points);\n\t};\n\n\tPolyline.prototype = {\n\n\t    bbox: function() {\n\n\t        var x1 = Infinity;\n\t        var x2 = -Infinity;\n\t        var y1 = Infinity;\n\t        var y2 = -Infinity;\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\n\t        for (var i = 0; i < numPoints; i++) {\n\n\t            var point = points[i];\n\t            var x = point.x;\n\t            var y = point.y;\n\n\t            if (x < x1) { x1 = x; }\n\t            if (x > x2) { x2 = x; }\n\t            if (y < y1) { y1 = y; }\n\t            if (y > y2) { y2 = y; }\n\t        }\n\n\t        return new Rect(x1, y1, x2 - x1, y2 - y1);\n\t    },\n\n\t    clone: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return new Polyline(); } // if points array is empty\n\n\t        var newPoints = [];\n\t        for (var i = 0; i < numPoints; i++) {\n\n\t            var point = points[i].clone();\n\t            newPoints.push(point);\n\t        }\n\n\t        return new Polyline(newPoints);\n\t    },\n\n\t    closestPoint: function(p) {\n\n\t        var cpLength = this.closestPointLength(p);\n\n\t        return this.pointAtLength(cpLength);\n\t    },\n\n\t    closestPointLength: function(p) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return 0; } // if points array is empty\n\t        if (numPoints === 1) { return 0; } // if there is only one point\n\n\t        var cpLength;\n\t        var minSqrDistance = Infinity;\n\t        var length = 0;\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var line = new Line(points[i], points[i + 1]);\n\t            var lineLength = line.length();\n\n\t            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n\t            var cp = line.pointAt(cpNormalizedLength);\n\n\t            var sqrDistance = cp.squaredDistance(p);\n\t            if (sqrDistance < minSqrDistance) {\n\t                minSqrDistance = sqrDistance;\n\t                cpLength = length + (cpNormalizedLength * lineLength);\n\t            }\n\n\t            length += lineLength;\n\t        }\n\n\t        return cpLength;\n\t    },\n\n\t    closestPointNormalizedLength: function(p) {\n\n\t        var cpLength = this.closestPointLength(p);\n\t        if (cpLength === 0) { return 0; } // shortcut\n\n\t        var length = this.length();\n\t        if (length === 0) { return 0; } // prevents division by zero\n\n\t        return cpLength / length;\n\t    },\n\n\t    closestPointTangent: function(p) {\n\n\t        var cpLength = this.closestPointLength(p);\n\n\t        return this.tangentAtLength(cpLength);\n\t    },\n\n\t    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n\t    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n\t    // (Uses horizontal rays to the right of `p` to look for intersections.)\n\t    // Closes open polylines (always imagines a final closing segment).\n\t    containsPoint: function(p) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return false; } // shortcut (this polyline has no points)\n\n\t        var x = p.x;\n\t        var y = p.y;\n\n\t        // initialize a final closing segment by creating one from last-first points on polyline\n\t        var startIndex = numPoints - 1; // start of current polyline segment\n\t        var endIndex = 0; // end of current polyline segment\n\t        var numIntersections = 0;\n\t        for (; endIndex < numPoints; endIndex++) {\n\t            var start = points[startIndex];\n\t            var end = points[endIndex];\n\t            if (p.equals(start)) { return true; } // shortcut (`p` is a point on polyline)\n\n\t            var segment = new Line(start, end); // current polyline segment\n\t            if (segment.containsPoint(p)) { return true; } // shortcut (`p` lies on a polyline segment)\n\n\t            // do we have an intersection?\n\t            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n\t                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n\t                // (when `y === start.y === end.y`)\n\t                // this conditional branch IS entered when `segment` touches `ray` at only one point\n\t                // (e.g. when `y === start.y !== end.y`)\n\t                // since this branch is entered again for the following segment, the two touches cancel out\n\n\t                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n\t                if (xDifference >= 0) {\n\t                    // segment lies at least partially to the right of `p`\n\t                    var rayEnd = new Point((x + xDifference), y); // right\n\t                    var ray = new Line(p, rayEnd);\n\n\t                    if (segment.intersect(ray)) {\n\t                        // an intersection was detected to the right of `p`\n\t                        numIntersections++;\n\t                    }\n\t                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\t            }\n\n\t            // move to check the next polyline segment\n\t            startIndex = endIndex;\n\t        }\n\n\t        // returns `true` for odd numbers of intersections (even-odd algorithm)\n\t        return ((numIntersections % 2) === 1);\n\t    },\n\n\t    // Returns a convex-hull polyline from this polyline.\n\t    // Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n\t    // Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n\t    // Minimal polyline is found (only vertices of the hull are reported, no collinear points).\n\t    convexHull: function() {\n\n\t        var i;\n\t        var n;\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return new Polyline(); } // if points array is empty\n\n\t        // step 1: find the starting point - point with the lowest y (if equality, highest x)\n\t        var startPoint;\n\t        for (i = 0; i < numPoints; i++) {\n\t            if (startPoint === undefined) {\n\t                // if this is the first point we see, set it as start point\n\t                startPoint = points[i];\n\n\t            } else if (points[i].y < startPoint.y) {\n\t                // start point should have lowest y from all points\n\t                startPoint = points[i];\n\n\t            } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n\t                // if two points have the lowest y, choose the one that has highest x\n\t                // there are no points to the right of startPoint - no ambiguity about theta 0\n\t                // if there are several coincident start point candidates, first one is reported\n\t                startPoint = points[i];\n\t            }\n\t        }\n\n\t        // step 2: sort the list of points\n\t        // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n\t        // step 2a: create the point records = [point, originalIndex, angle]\n\t        var sortedPointRecords = [];\n\t        for (i = 0; i < numPoints; i++) {\n\n\t            var angle = startPoint.theta(points[i]);\n\t            if (angle === 0) {\n\t                angle = 360; // give highest angle to start point\n\t                // the start point will end up at end of sorted list\n\t                // the start point will end up at beginning of hull points list\n\t            }\n\n\t            var entry = [points[i], i, angle];\n\t            sortedPointRecords.push(entry);\n\t        }\n\n\t        // step 2b: sort the list in place\n\t        sortedPointRecords.sort(function(record1, record2) {\n\t            // returning a negative number here sorts record1 before record2\n\t            // if first angle is smaller than second, first angle should come before second\n\n\t            var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n\t            if (sortOutput === 0) {\n\t                // if the two angles are equal, sort by originalIndex\n\t                sortOutput = record2[1] - record1[1]; // negative if first index larger\n\t                // coincident points will be sorted in reverse-numerical order\n\t                // so the coincident points with lower original index will be considered first\n\t            }\n\n\t            return sortOutput;\n\t        });\n\n\t        // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n\t        if (sortedPointRecords.length > 2) {\n\t            var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n\t            sortedPointRecords.unshift(startPointRecord);\n\t        }\n\n\t        // step 3a: go through sorted points in order and find those with right turns\n\t        // we want to get our results in clockwise order\n\t        var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n\t        var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n\t        var currentPointRecord;\n\t        var currentPoint;\n\t        var lastHullPointRecord;\n\t        var lastHullPoint;\n\t        var secondLastHullPointRecord;\n\t        var secondLastHullPoint;\n\t        while (sortedPointRecords.length !== 0) {\n\n\t            currentPointRecord = sortedPointRecords.pop();\n\t            currentPoint = currentPointRecord[0];\n\n\t            // check if point has already been discarded\n\t            // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n\t            if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n\t                // this point had an incorrect turn at some previous iteration of this loop\n\t                // this disqualifies it from possibly being on the hull\n\t                continue;\n\t            }\n\n\t            var correctTurnFound = false;\n\t            while (!correctTurnFound) {\n\n\t                if (hullPointRecords.length < 2) {\n\t                    // not enough points for comparison, just add current point\n\t                    hullPointRecords.push(currentPointRecord);\n\t                    correctTurnFound = true;\n\n\t                } else {\n\t                    lastHullPointRecord = hullPointRecords.pop();\n\t                    lastHullPoint = lastHullPointRecord[0];\n\t                    secondLastHullPointRecord = hullPointRecords.pop();\n\t                    secondLastHullPoint = secondLastHullPointRecord[0];\n\n\t                    var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n\t                    if (crossProduct < 0) {\n\t                        // found a right turn\n\t                        hullPointRecords.push(secondLastHullPointRecord);\n\t                        hullPointRecords.push(lastHullPointRecord);\n\t                        hullPointRecords.push(currentPointRecord);\n\t                        correctTurnFound = true;\n\n\t                    } else if (crossProduct === 0) {\n\t                        // the three points are collinear\n\t                        // three options:\n\t                        // there may be a 180 or 0 degree angle at lastHullPoint\n\t                        // or two of the three points are coincident\n\t                        var THRESHOLD = 1e-10; // we have to take rounding errors into account\n\t                        var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\t                        if (abs(angleBetween - 180) < THRESHOLD) { // rouding around 180 to 180\n\t                            // if the cross product is 0 because the angle is 180 degrees\n\t                            // discard last hull point (add to insidePoints)\n\t                            //insidePoints.unshift(lastHullPoint);\n\t                            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t                            // reenter second-to-last hull point (will be last at next iter)\n\t                            hullPointRecords.push(secondLastHullPointRecord);\n\t                            // do not do anything with current point\n\t                            // correct turn not found\n\n\t                        } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n\t                            // if the cross product is 0 because two points are the same\n\t                            // discard last hull point (add to insidePoints)\n\t                            //insidePoints.unshift(lastHullPoint);\n\t                            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t                            // reenter second-to-last hull point (will be last at next iter)\n\t                            hullPointRecords.push(secondLastHullPointRecord);\n\t                            // do not do anything with current point\n\t                            // correct turn not found\n\n\t                        } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n\t                            // if the cross product is 0 because the angle is 0 degrees\n\t                            // remove last hull point from hull BUT do not discard it\n\t                            // reenter second-to-last hull point (will be last at next iter)\n\t                            hullPointRecords.push(secondLastHullPointRecord);\n\t                            // put last hull point back into the sorted point records list\n\t                            sortedPointRecords.push(lastHullPointRecord);\n\t                            // we are switching the order of the 0deg and 180deg points\n\t                            // correct turn not found\n\t                        }\n\n\t                    } else {\n\t                        // found a left turn\n\t                        // discard last hull point (add to insidePoints)\n\t                        //insidePoints.unshift(lastHullPoint);\n\t                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n\t                        // reenter second-to-last hull point (will be last at next iter of loop)\n\t                        hullPointRecords.push(secondLastHullPointRecord);\n\t                        // do not do anything with current point\n\t                        // correct turn not found\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        // at this point, hullPointRecords contains the output points in clockwise order\n\t        // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n\t        // step 3b: remove duplicated startPointRecord from the end of the array\n\t        if (hullPointRecords.length > 2) {\n\t            hullPointRecords.pop();\n\t        }\n\n\t        // step 4: find the lowest originalIndex record and put it at the beginning of hull\n\t        var lowestHullIndex; // the lowest originalIndex on the hull\n\t        var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\t        n = hullPointRecords.length;\n\t        for (i = 0; i < n; i++) {\n\n\t            var currentHullIndex = hullPointRecords[i][1];\n\n\t            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n\t                lowestHullIndex = currentHullIndex;\n\t                indexOfLowestHullIndexRecord = i;\n\t            }\n\t        }\n\n\t        var hullPointRecordsReordered = [];\n\t        if (indexOfLowestHullIndexRecord > 0) {\n\t            var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n\t            var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n\t            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n\t        } else {\n\t            hullPointRecordsReordered = hullPointRecords;\n\t        }\n\n\t        var hullPoints = [];\n\t        n = hullPointRecordsReordered.length;\n\t        for (i = 0; i < n; i++) {\n\t            hullPoints.push(hullPointRecordsReordered[i][0]);\n\t        }\n\n\t        return new Polyline(hullPoints);\n\t    },\n\n\t    // Checks whether two polylines are exactly the same.\n\t    // If `p` is undefined or null, returns false.\n\t    equals: function(p) {\n\n\t        if (!p) { return false; }\n\n\t        var points = this.points;\n\t        var otherPoints = p.points;\n\n\t        var numPoints = points.length;\n\t        if (otherPoints.length !== numPoints) { return false; } // if the two polylines have different number of points, they cannot be equal\n\n\t        for (var i = 0; i < numPoints; i++) {\n\n\t            var point = points[i];\n\t            var otherPoint = p.points[i];\n\n\t            // as soon as an inequality is found in points, return false\n\t            if (!point.equals(otherPoint)) { return false; }\n\t        }\n\n\t        // if no inequality found in points, return true\n\t        return true;\n\t    },\n\n\t    intersectionWithLine: function(l) {\n\t        var line = new Line(l);\n\t        var intersections = [];\n\t        var points = this.points;\n\t        for (var i = 0, n = points.length - 1; i < n; i++) {\n\t            var a = points[i];\n\t            var b = points[i + 1];\n\t            var l2 = new Line(a, b);\n\t            var int = line.intersectionWithLine(l2);\n\t            if (int) { intersections.push(int[0]); }\n\t        }\n\t        return (intersections.length > 0) ? intersections : null;\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return false; }\n\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\n\t            var a = points[i];\n\t            var b = points[i + 1];\n\t            var line = new Line(a, b);\n\n\t            // as soon as a differentiable line is found between two points, return true\n\t            if (line.isDifferentiable()) { return true; }\n\t        }\n\n\t        // if no differentiable line is found between pairs of points, return false\n\t        return false;\n\t    },\n\n\t    length: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return 0; } // if points array is empty\n\n\t        var length = 0;\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\t            length += points[i].distance(points[i + 1]);\n\t        }\n\n\t        return length;\n\t    },\n\n\t    pointAt: function(ratio) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\t        if (numPoints === 1) { return points[0].clone(); } // if there is only one point\n\n\t        if (ratio <= 0) { return points[0].clone(); }\n\t        if (ratio >= 1) { return points[numPoints - 1].clone(); }\n\n\t        var polylineLength = this.length();\n\t        var length = polylineLength * ratio;\n\n\t        return this.pointAtLength(length);\n\t    },\n\n\t    pointAtLength: function(length) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\t        if (numPoints === 1) { return points[0].clone(); } // if there is only one point\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        var l = 0;\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\t            var index = (fromStart ? i : (n - 1 - i));\n\n\t            var a = points[index];\n\t            var b = points[index + 1];\n\t            var line = new Line(a, b);\n\t            var d = a.distance(b);\n\n\t            if (length <= (l + d)) {\n\t                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the polyline, return last endpoint\n\t        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n\t        return lastPoint.clone();\n\t    },\n\n\t    round: function(precision) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\n\t        for (var i = 0; i < numPoints; i++) {\n\t            points[i].round(precision);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\n\t        for (var i = 0; i < numPoints; i++) {\n\t            points[i].scale(sx, sy, origin);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    simplify: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var points = this.points;\n\t        if (points.length < 3) { return this; } // we need at least 3 points\n\n\t        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\t        var threshold = opt.threshold || 0; // = max distance of middle point from chord to be simplified\n\n\t        // start at the beginning of the polyline and go forward\n\t        var currentIndex = 0;\n\t        // we need at least one intermediate point (3 points) in every iteration\n\t        // as soon as that stops being true, we know we reached the end of the polyline\n\t        while (points[currentIndex + 2]) {\n\t            var firstIndex = currentIndex;\n\t            var middleIndex = (currentIndex + 1);\n\t            var lastIndex = (currentIndex + 2);\n\n\t            var firstPoint = points[firstIndex];\n\t            var middlePoint = points[middleIndex];\n\t            var lastPoint = points[lastIndex];\n\n\t            var chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\t            var closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\t            var closestPointDistance = closestPoint.distance(middlePoint);\n\t            if (closestPointDistance <= threshold) {\n\t                // middle point is close enough to the chord = simplify\n\t                // 1) remove middle point:\n\t                points.splice(middleIndex, 1);\n\t                // 2) in next iteration, investigate the newly-created triplet of points\n\t                //    - do not change `currentIndex`\n\t                //    = (first point stays, point after removed point becomes middle point)\n\t            } else {\n\t                // middle point is far from the chord\n\t                // 1) preserve middle point\n\t                // 2) in next iteration, move `currentIndex` by one step:\n\t                currentIndex += 1;\n\t                //    = (point after first point becomes first point)\n\t            }\n\t        }\n\n\t        // `points` array was modified in-place\n\t        return this;\n\t    },\n\n\t    tangentAt: function(ratio) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\t        if (numPoints === 1) { return null; } // if there is only one point\n\n\t        if (ratio < 0) { ratio = 0; }\n\t        if (ratio > 1) { ratio = 1; }\n\n\t        var polylineLength = this.length();\n\t        var length = polylineLength * ratio;\n\n\t        return this.tangentAtLength(length);\n\t    },\n\n\t    tangentAtLength: function(length) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\t        if (numPoints === 1) { return null; } // if there is only one point\n\n\t        var fromStart = true;\n\t        if (length < 0) {\n\t            fromStart = false; // negative lengths mean start calculation from end point\n\t            length = -length; // absolute value\n\t        }\n\n\t        var lastValidLine; // differentiable (with a tangent)\n\t        var l = 0; // length so far\n\t        var n = numPoints - 1;\n\t        for (var i = 0; i < n; i++) {\n\t            var index = (fromStart ? i : (n - 1 - i));\n\n\t            var a = points[index];\n\t            var b = points[index + 1];\n\t            var line = new Line(a, b);\n\t            var d = a.distance(b);\n\n\t            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n\t                if (length <= (l + d)) {\n\t                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n\t                }\n\n\t                lastValidLine = line;\n\t            }\n\n\t            l += d;\n\t        }\n\n\t        // if length requested is higher than the length of the polyline, return last valid endpoint\n\t        if (lastValidLine) {\n\t            var ratio = (fromStart ? 1 : 0);\n\t            return lastValidLine.tangentAt(ratio);\n\t        }\n\n\t        // if no valid line, return null\n\t        return null;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.points + '';\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\n\t        for (var i = 0; i < numPoints; i++) {\n\t            points[i].translate(tx, ty);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    // Return svgString that can be used to recreate this line.\n\t    serialize: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return ''; } // if points array is empty\n\n\t        var output = '';\n\t        for (var i = 0; i < numPoints; i++) {\n\n\t            var point = points[i];\n\t            output += point.x + ',' + point.y + ' ';\n\t        }\n\n\t        return output.trim();\n\t    }\n\t};\n\n\tObject.defineProperty(Polyline.prototype, 'start', {\n\t    // Getter for the first point of the polyline.\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\n\t        return this.points[0];\n\t    },\n\t});\n\n\tObject.defineProperty(Polyline.prototype, 'end', {\n\t    // Getter for the last point of the polyline.\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        var points = this.points;\n\t        var numPoints = points.length;\n\t        if (numPoints === 0) { return null; } // if points array is empty\n\n\t        return this.points[numPoints - 1];\n\t    },\n\t});\n\n\tvar Rect = function(x, y, w, h) {\n\n\t    if (!(this instanceof Rect)) {\n\t        return new Rect(x, y, w, h);\n\t    }\n\n\t    if ((Object(x) === x)) {\n\t        y = x.y;\n\t        w = x.width;\n\t        h = x.height;\n\t        x = x.x;\n\t    }\n\n\t    this.x = x === undefined ? 0 : x;\n\t    this.y = y === undefined ? 0 : y;\n\t    this.width = w === undefined ? 0 : w;\n\t    this.height = h === undefined ? 0 : h;\n\t};\n\n\tRect.fromEllipse = function(e) {\n\n\t    e = new Ellipse(e);\n\t    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n\t};\n\n\tRect.prototype = {\n\n\t    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n\t    // @return r {rectangle} representing a bounding box\n\t    bbox: function(angle) {\n\n\t        if (!angle) { return this.clone(); }\n\n\t        var theta = toRad(angle);\n\t        var st = abs(sin(theta));\n\t        var ct = abs(cos(theta));\n\t        var w = this.width * ct + this.height * st;\n\t        var h = this.width * st + this.height * ct;\n\t        return new Rect(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n\t    },\n\n\t    bottomLeft: function() {\n\n\t        return new Point(this.x, this.y + this.height);\n\t    },\n\n\t    bottomLine: function() {\n\n\t        return new Line(this.bottomLeft(), this.bottomRight());\n\t    },\n\n\t    bottomMiddle: function() {\n\n\t        return new Point(this.x + this.width / 2, this.y + this.height);\n\t    },\n\n\t    center: function() {\n\n\t        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t    },\n\n\t    clone: function() {\n\n\t        return new Rect(this);\n\t    },\n\n\t    // @return {bool} true if point p is inside me.\n\t    containsPoint: function(p) {\n\n\t        p = new Point(p);\n\t        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n\t    },\n\n\t    // @return {bool} true if rectangle `r` is inside me.\n\t    containsRect: function(r) {\n\n\t        var r0 = new Rect(this).normalize();\n\t        var r1 = new Rect(r).normalize();\n\t        var w0 = r0.width;\n\t        var h0 = r0.height;\n\t        var w1 = r1.width;\n\t        var h1 = r1.height;\n\n\t        if (!w0 || !h0 || !w1 || !h1) {\n\t            // At least one of the dimensions is 0\n\t            return false;\n\t        }\n\n\t        var x0 = r0.x;\n\t        var y0 = r0.y;\n\t        var x1 = r1.x;\n\t        var y1 = r1.y;\n\n\t        w1 += x1;\n\t        w0 += x0;\n\t        h1 += y1;\n\t        h0 += y0;\n\n\t        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n\t    },\n\n\t    corner: function() {\n\n\t        return new Point(this.x + this.width, this.y + this.height);\n\t    },\n\n\t    // @return {boolean} true if rectangles are equal.\n\t    equals: function(r) {\n\n\t        var mr = (new Rect(this)).normalize();\n\t        var nr = (new Rect(r)).normalize();\n\t        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n\t    },\n\n\t    // inflate by dx and dy, recompute origin [x, y]\n\t    // @param dx {delta_x} representing additional size to x\n\t    // @param dy {delta_y} representing additional size to y -\n\t    // dy param is not required -> in that case y is sized by dx\n\t    inflate: function(dx, dy) {\n\n\t        if (dx === undefined) {\n\t            dx = 0;\n\t        }\n\n\t        if (dy === undefined) {\n\t            dy = dx;\n\t        }\n\n\t        this.x -= dx;\n\t        this.y -= dy;\n\t        this.width += 2 * dx;\n\t        this.height += 2 * dy;\n\n\t        return this;\n\t    },\n\n\t    // @return {rect} if rectangles intersect, {null} if not.\n\t    intersect: function(r) {\n\n\t        var myOrigin = this.origin();\n\t        var myCorner = this.corner();\n\t        var rOrigin = r.origin();\n\t        var rCorner = r.corner();\n\n\t        // No intersection found\n\t        if (rCorner.x <= myOrigin.x ||\n\t            rCorner.y <= myOrigin.y ||\n\t            rOrigin.x >= myCorner.x ||\n\t            rOrigin.y >= myCorner.y) { return null; }\n\n\t        var x = max$1(myOrigin.x, rOrigin.x);\n\t        var y = max$1(myOrigin.y, rOrigin.y);\n\n\t        return new Rect(x, y, min$3(myCorner.x, rCorner.x) - x, min$3(myCorner.y, rCorner.y) - y);\n\t    },\n\n\t    intersectionWithLine: function(line) {\n\n\t        var r = this;\n\t        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n\t        var points = [];\n\t        var dedupeArr = [];\n\t        var pt, i;\n\n\t        var n = rectLines.length;\n\t        for (i = 0; i < n; i++) {\n\n\t            pt = line.intersect(rectLines[i]);\n\t            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n\t                points.push(pt);\n\t                dedupeArr.push(pt.toString());\n\t            }\n\t        }\n\n\t        return points.length > 0 ? points : null;\n\t    },\n\n\t    // Find point on my boundary where line starting\n\t    // from my center ending in point p intersects me.\n\t    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n\t    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n\t        p = new Point(p);\n\t        var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t        var result;\n\n\t        if (angle) { p.rotate(center, angle); }\n\n\t        // (clockwise, starting from the top side)\n\t        var sides = [\n\t            this.topLine(),\n\t            this.rightLine(),\n\t            this.bottomLine(),\n\t            this.leftLine()\n\t        ];\n\t        var connector = new Line(center, p);\n\n\t        for (var i = sides.length - 1; i >= 0; --i) {\n\t            var intersection = sides[i].intersection(connector);\n\t            if (intersection !== null) {\n\t                result = intersection;\n\t                break;\n\t            }\n\t        }\n\t        if (result && angle) { result.rotate(center, -angle); }\n\t        return result;\n\t    },\n\n\t    leftLine: function() {\n\n\t        return new Line(this.topLeft(), this.bottomLeft());\n\t    },\n\n\t    leftMiddle: function() {\n\n\t        return new Point(this.x, this.y + this.height / 2);\n\t    },\n\n\t    maxRectScaleToFit: function(rect, origin) {\n\n\t        rect = new Rect(rect);\n\t        origin || (origin = rect.center());\n\n\t        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n\t        var ox = origin.x;\n\t        var oy = origin.y;\n\n\t        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n\t        // so when the scale is applied the point is still inside the rectangle.\n\n\t        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n\t        // Top Left\n\t        var p1 = rect.topLeft();\n\t        if (p1.x < ox) {\n\t            sx1 = (this.x - ox) / (p1.x - ox);\n\t        }\n\t        if (p1.y < oy) {\n\t            sy1 = (this.y - oy) / (p1.y - oy);\n\t        }\n\t        // Bottom Right\n\t        var p2 = rect.bottomRight();\n\t        if (p2.x > ox) {\n\t            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n\t        }\n\t        if (p2.y > oy) {\n\t            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n\t        }\n\t        // Top Right\n\t        var p3 = rect.topRight();\n\t        if (p3.x > ox) {\n\t            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n\t        }\n\t        if (p3.y < oy) {\n\t            sy3 = (this.y - oy) / (p3.y - oy);\n\t        }\n\t        // Bottom Left\n\t        var p4 = rect.bottomLeft();\n\t        if (p4.x < ox) {\n\t            sx4 = (this.x - ox) / (p4.x - ox);\n\t        }\n\t        if (p4.y > oy) {\n\t            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n\t        }\n\n\t        return {\n\t            sx: min$3(sx1, sx2, sx3, sx4),\n\t            sy: min$3(sy1, sy2, sy3, sy4)\n\t        };\n\t    },\n\n\t    maxRectUniformScaleToFit: function(rect, origin) {\n\n\t        var scale = this.maxRectScaleToFit(rect, origin);\n\t        return min$3(scale.sx, scale.sy);\n\t    },\n\n\t    // Move and expand me.\n\t    // @param r {rectangle} representing deltas\n\t    moveAndExpand: function(r) {\n\n\t        this.x += r.x || 0;\n\t        this.y += r.y || 0;\n\t        this.width += r.width || 0;\n\t        this.height += r.height || 0;\n\t        return this;\n\t    },\n\n\t    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n\t    // If width < 0 the function swaps the left and right corners,\n\t    // and it swaps the top and bottom corners if height < 0\n\t    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n\t    normalize: function() {\n\n\t        var newx = this.x;\n\t        var newy = this.y;\n\t        var newwidth = this.width;\n\t        var newheight = this.height;\n\t        if (this.width < 0) {\n\t            newx = this.x + this.width;\n\t            newwidth = -this.width;\n\t        }\n\t        if (this.height < 0) {\n\t            newy = this.y + this.height;\n\t            newheight = -this.height;\n\t        }\n\t        this.x = newx;\n\t        this.y = newy;\n\t        this.width = newwidth;\n\t        this.height = newheight;\n\t        return this;\n\t    },\n\n\t    // Offset me by the specified amount.\n\t    offset: function(dx, dy) {\n\n\t        // pretend that this is a point and call offset()\n\t        // rewrites x and y according to dx and dy\n\t        return Point.prototype.offset.call(this, dx, dy);\n\t    },\n\n\t    origin: function() {\n\n\t        return new Point(this.x, this.y);\n\t    },\n\n\t    // @return {point} a point on my boundary nearest to the given point.\n\t    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n\t    pointNearestToPoint: function(point) {\n\n\t        point = new Point(point);\n\t        if (this.containsPoint(point)) {\n\t            var side = this.sideNearestToPoint(point);\n\t            switch (side) {\n\t                case 'right':\n\t                    return new Point(this.x + this.width, point.y);\n\t                case 'left':\n\t                    return new Point(this.x, point.y);\n\t                case 'bottom':\n\t                    return new Point(point.x, this.y + this.height);\n\t                case 'top':\n\t                    return new Point(point.x, this.y);\n\t            }\n\t        }\n\t        return point.adhereToRect(this);\n\t    },\n\n\t    rightLine: function() {\n\n\t        return new Line(this.topRight(), this.bottomRight());\n\t    },\n\n\t    rightMiddle: function() {\n\n\t        return new Point(this.x + this.width, this.y + this.height / 2);\n\t    },\n\n\t    round: function(precision) {\n\n\t        var f = 1; // case 0\n\t        if (precision) {\n\t            switch (precision) {\n\t                case 1: f = 10; break;\n\t                case 2: f = 100; break;\n\t                case 3: f = 1000; break;\n\t                default: f = pow(10, precision); break;\n\t            }\n\t        }\n\n\t        this.x = round(this.x * f) / f;\n\t        this.y = round(this.y * f) / f;\n\t        this.width = round(this.width * f) / f;\n\t        this.height = round(this.height * f) / f;\n\t        return this;\n\t    },\n\n\t    // Scale rectangle with origin.\n\t    scale: function(sx, sy, origin) {\n\n\t        origin = this.origin().scale(sx, sy, origin);\n\t        this.x = origin.x;\n\t        this.y = origin.y;\n\t        this.width *= sx;\n\t        this.height *= sy;\n\t        return this;\n\t    },\n\n\t    // @return {string} (left|right|top|bottom) side which is nearest to point\n\t    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n\t    sideNearestToPoint: function(point) {\n\n\t        point = new Point(point);\n\t        var distToLeft = point.x - this.x;\n\t        var distToRight = (this.x + this.width) - point.x;\n\t        var distToTop = point.y - this.y;\n\t        var distToBottom = (this.y + this.height) - point.y;\n\t        var closest = distToLeft;\n\t        var side = 'left';\n\n\t        if (distToRight < closest) {\n\t            closest = distToRight;\n\t            side = 'right';\n\t        }\n\t        if (distToTop < closest) {\n\t            closest = distToTop;\n\t            side = 'top';\n\t        }\n\t        if (distToBottom < closest) {\n\t            // closest = distToBottom;\n\t            side = 'bottom';\n\t        }\n\t        return side;\n\t    },\n\n\t    snapToGrid: function(gx, gy) {\n\n\t        var origin = this.origin().snapToGrid(gx, gy);\n\t        var corner = this.corner().snapToGrid(gx, gy);\n\t        this.x = origin.x;\n\t        this.y = origin.y;\n\t        this.width = corner.x - origin.x;\n\t        this.height = corner.y - origin.y;\n\t        return this;\n\t    },\n\n\t    toJSON: function() {\n\n\t        return { x: this.x, y: this.y, width: this.width, height: this.height };\n\t    },\n\n\t    topLine: function() {\n\n\t        return new Line(this.topLeft(), this.topRight());\n\t    },\n\n\t    topMiddle: function() {\n\n\t        return new Point(this.x + this.width / 2, this.y);\n\t    },\n\n\t    topRight: function() {\n\n\t        return new Point(this.x + this.width, this.y);\n\t    },\n\n\t    toString: function() {\n\n\t        return this.origin().toString() + ' ' + this.corner().toString();\n\t    },\n\n\t    // @return {rect} representing the union of both rectangles.\n\t    union: function(rect) {\n\n\t        var u = new Rect(rect);\n\t        var ref = this;\n\t        var x = ref.x;\n\t        var y = ref.y;\n\t        var width = ref.width;\n\t        var height = ref.height;\n\t        var rx = u.x;\n\t        var ry = u.y;\n\t        var rw = u.width;\n\t        var rh = u.height;\n\t        var ux = u.x = min$3(x, rx);\n\t        var uy = u.y = min$3(y, ry);\n\t        u.width = max$1(x + width, rx + rw) - ux;\n\t        u.height = max$1(y + height, ry + rh) - uy;\n\t        return u;\n\t    }\n\t};\n\n\tRect.prototype.bottomRight = Rect.prototype.corner;\n\n\tRect.prototype.topLeft = Rect.prototype.origin;\n\n\tRect.prototype.translate = Rect.prototype.offset;\n\n\tvar scale = {\n\n\t    // Return the `value` from the `domain` interval scaled to the `range` interval.\n\t    linear: function(domain, range, value) {\n\n\t        var domainSpan = domain[1] - domain[0];\n\t        var rangeSpan = range[1] - range[0];\n\t        return (((value - domain[0]) / domainSpan) * rangeSpan + range[0]) || 0;\n\t    }\n\t};\n\n\tvar normalizeAngle = function(angle) {\n\n\t    return (angle % 360) + (angle < 0 ? 360 : 0);\n\t};\n\n\tvar snapToGrid = function(value, gridSize) {\n\n\t    return gridSize * round(value / gridSize);\n\t};\n\n\tvar toDeg = function(rad) {\n\n\t    return (180 * rad / PI) % 360;\n\t};\n\n\tvar toRad = function(deg, over360) {\n\n\t    over360 = over360 || false;\n\t    deg = over360 ? deg : (deg % 360);\n\t    return deg * PI / 180;\n\t};\n\n\t// Return a random integer from the interval [min,max], inclusive.\n\tvar random = function(min, max) {\n\n\t    if (max === undefined) {\n\t        // use first argument as max, min is 0\n\t        max = (min === undefined) ? 1 : min;\n\t        min = 0;\n\n\t    } else if (max < min) {\n\t        // switch max and min\n\t        var temp = min;\n\t        min = max;\n\t        max = temp;\n\t    }\n\n\t    return floor$1((math.random() * (max - min + 1)) + min);\n\t};\n\n\t// For backwards compatibility:\n\tvar ellipse = Ellipse;\n\tvar line = Line;\n\tvar point = Point;\n\tvar rect = Rect;\n\n\t// Local helper function.\n\t// Use an array of arguments to call a constructor (function called with `new`).\n\t// Adapted from https://stackoverflow.com/a/8843181/2263595\n\t// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n\t// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n\t// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n\t// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\n\tfunction applyToNew(constructor, argsArray) {\n\t    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n\t    // - We can fake that with .bind().\n\t    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n\t    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n\t    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n\t    // We need to pass in a variable number of arguments to the bind() call.\n\t    // - We can use .apply().\n\t    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\t    // - `thisArg` can still be anything because `new` overwrites it.\n\t    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n\t    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n\t    // The function expects `argsArray[0]` to be `thisArg`.\n\t    // - This means that whatever is sent as the first element will be ignored.\n\t    // - The constructor will only see arguments starting from argsArray[1].\n\t    // - So, a new dummy element is inserted at the start of the array.\n\t    argsArray.unshift(null);\n\n\t    return new (Function.prototype.bind.apply(constructor, argsArray));\n\t}\n\n\t// Local helper function.\n\t// Add properties from arguments on top of properties from `obj`.\n\t// This allows for rudimentary inheritance.\n\t// - The `obj` argument acts as parent.\n\t// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n\t// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\n\tfunction extend(obj) {\n\t    var arguments$1 = arguments;\n\n\t    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n\t    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n\t    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n\t    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n\t    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n\t    // - This method provides a way to do exactly that.\n\t    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n\t    // - Therefore, to continue with the example above:\n\t    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n\t    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n\t    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n\t    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n\t    // - Multiple inheritance is also possible, if multiple arguments are provided.\n\t    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n\t    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n\t    //   - The ancestors are applied in order of appearance.\n\t    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n\t    //   - Any number of ancestors may be provided.\n\t    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n\t    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n\t    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n\t    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n\t    // - Therefore, both of the following are valid:\n\t    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n\t    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n\t    var i;\n\t    var n;\n\n\t    var args = [];\n\t    n = arguments.length;\n\t    for (i = 1; i < n; i++) { // skip over obj\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!obj) { throw new Error('Missing a parent object.'); }\n\t    var child = Object.create(obj);\n\n\t    n = args.length;\n\t    for (i = 0; i < n; i++) {\n\n\t        var src = args[i];\n\n\t        var inheritedProperty;\n\t        var key;\n\t        for (key in src) {\n\n\t            if (src.hasOwnProperty(key)) {\n\t                delete child[key]; // delete property inherited from parent\n\t                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n\t                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n\t            }\n\t        }\n\t    }\n\n\t    return child;\n\t}\n\n\t// Path segment interface:\n\tvar segmentPrototype = {\n\n\t    // virtual\n\t    bbox: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    clone: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    closestPoint: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    closestPointLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    closestPointNormalizedLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n\t    closestPointT: function(p) {\n\n\t        if (this.closestPointNormalizedLength) { return this.closestPointNormalizedLength(p); }\n\n\t        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n\t    },\n\n\t    // virtual\n\t    closestPointTangent: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    divideAt: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    divideAtLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n\t    divideAtT: function(t) {\n\n\t        if (this.divideAt) { return this.divideAt(t); }\n\n\t        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n\t    },\n\n\t    // virtual\n\t    equals: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    getSubdivisions: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    isDifferentiable: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    isSegment: true,\n\n\t    isSubpathStart: false, // true for Moveto segments\n\n\t    isVisible: true, // false for Moveto segments\n\n\t    // virtual\n\t    length: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n\t    lengthAtT: function(t) {\n\n\t        if (t <= 0) { return 0; }\n\n\t        var length = this.length();\n\n\t        if (t >= 1) { return length; }\n\n\t        return length * t;\n\t    },\n\n\t    nextSegment: null, // needed for subpath start segment updating\n\n\t    // virtual\n\t    pointAt: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    pointAtLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n\t    pointAtT: function(t) {\n\n\t        if (this.pointAt) { return this.pointAt(t); }\n\n\t        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n\t    },\n\n\t    previousSegment: null, // needed to get segment start property\n\n\t    // virtual\n\t    round: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    subpathStartSegment: null, // needed to get Closepath segment end property\n\n\t    // virtual\n\t    scale: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    serialize: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    tangentAt: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    tangentAtLength: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n\t    tangentAtT: function(t) {\n\n\t        if (this.tangentAt) { return this.tangentAt(t); }\n\n\t        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n\t    },\n\n\t    // virtual\n\t    toString: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    },\n\n\t    // virtual\n\t    translate: function() {\n\n\t        throw new Error('Declaration missing for virtual function.');\n\t    }\n\t};\n\n\t// usually directly assigned\n\t// getter for Closepath\n\tObject.defineProperty(segmentPrototype, 'end', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    writable: true\n\t});\n\n\t// always a getter\n\t// always throws error for Moveto\n\tObject.defineProperty(segmentPrototype, 'start', {\n\t    // get a reference to the end point of previous segment\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        if (!this.previousSegment) { throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)'); }\n\n\t        return this.previousSegment.end;\n\t    }\n\t});\n\n\t// virtual\n\tObject.defineProperty(segmentPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        throw new Error('Bad segment declaration. No type specified.');\n\t    }\n\t});\n\n\t// Path segment implementations:\n\tvar Lineto = function() {\n\t    var arguments$1 = arguments;\n\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 0; i < n; i++) {\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n\t        return applyToNew(Lineto, args);\n\t    }\n\n\t    if (n === 0) {\n\t        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n\t    }\n\n\t    var outputArray;\n\n\t    if (args[0] instanceof Line) { // lines provided\n\t        if (n === 1) {\n\t            this.end = args[0].end.clone();\n\t            return this;\n\n\t        } else {\n\t            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n\t        }\n\n\t    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n\t        if (n === 2) {\n\t            this.end = new Point(+args[0], +args[1]);\n\t            return this;\n\n\t        } else if (n < 2) {\n\t            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n\t        } else { // this is a poly-line segment\n\t            var segmentCoords;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n\t                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\t                outputArray.push(applyToNew(Lineto, segmentCoords));\n\t            }\n\t            return outputArray;\n\t        }\n\n\t    } else { // points provided (needs to be last to also cover plain objects with x and y)\n\t        if (n === 1) {\n\t            this.end = new Point(args[0]);\n\t            return this;\n\n\t        } else { // this is a poly-line segment\n\t            var segmentPoint;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 1) {\n\n\t                segmentPoint = args[i];\n\t                outputArray.push(new Lineto(segmentPoint));\n\t            }\n\t            return outputArray;\n\t        }\n\t    }\n\t};\n\n\tvar linetoPrototype = {\n\n\t    clone: function() {\n\n\t        return new Lineto(this.end);\n\t    },\n\n\t    divideAt: function(ratio) {\n\n\t        var line = new Line(this.start, this.end);\n\t        var divided = line.divideAt(ratio);\n\t        return [\n\t            new Lineto(divided[0]),\n\t            new Lineto(divided[1])\n\t        ];\n\t    },\n\n\t    divideAtLength: function(length) {\n\n\t        var line = new Line(this.start, this.end);\n\t        var divided = line.divideAtLength(length);\n\t        return [\n\t            new Lineto(divided[0]),\n\t            new Lineto(divided[1])\n\t        ];\n\t    },\n\n\t    getSubdivisions: function() {\n\n\t        return [];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        if (!this.previousSegment) { return false; }\n\n\t        return !this.start.equals(this.end);\n\t    },\n\n\t    round: function(precision) {\n\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    serialize: function() {\n\n\t        var end = this.end;\n\t        return this.type + ' ' + end.x + ' ' + end.y;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.type + ' ' + this.start + ' ' + this.end;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(linetoPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    value: 'L'\n\t});\n\n\tLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\n\tvar Curveto = function() {\n\t    var arguments$1 = arguments;\n\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 0; i < n; i++) {\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n\t        return applyToNew(Curveto, args);\n\t    }\n\n\t    if (n === 0) {\n\t        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n\t    }\n\n\t    var outputArray;\n\n\t    if (args[0] instanceof Curve) { // curves provided\n\t        if (n === 1) {\n\t            this.controlPoint1 = args[0].controlPoint1.clone();\n\t            this.controlPoint2 = args[0].controlPoint2.clone();\n\t            this.end = args[0].end.clone();\n\t            return this;\n\n\t        } else {\n\t            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n\t        }\n\n\t    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n\t        if (n === 6) {\n\t            this.controlPoint1 = new Point(+args[0], +args[1]);\n\t            this.controlPoint2 = new Point(+args[2], +args[3]);\n\t            this.end = new Point(+args[4], +args[5]);\n\t            return this;\n\n\t        } else if (n < 6) {\n\t            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n\t        } else { // this is a poly-bezier segment\n\t            var segmentCoords;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n\t                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n\t                outputArray.push(applyToNew(Curveto, segmentCoords));\n\t            }\n\t            return outputArray;\n\t        }\n\n\t    } else { // points provided (needs to be last to also cover plain objects with x and y)\n\t        if (n === 3) {\n\t            this.controlPoint1 = new Point(args[0]);\n\t            this.controlPoint2 = new Point(args[1]);\n\t            this.end = new Point(args[2]);\n\t            return this;\n\n\t        } else if (n < 3) {\n\t            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n\t        } else { // this is a poly-bezier segment\n\t            var segmentPoints;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n\t                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n\t                outputArray.push(applyToNew(Curveto, segmentPoints));\n\t            }\n\t            return outputArray;\n\t        }\n\t    }\n\t};\n\n\tvar curvetoPrototype = {\n\n\t    clone: function() {\n\n\t        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n\t    },\n\n\t    divideAt: function(ratio, opt) {\n\n\t        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t        var divided = curve.divideAt(ratio, opt);\n\t        return [\n\t            new Curveto(divided[0]),\n\t            new Curveto(divided[1])\n\t        ];\n\t    },\n\n\t    divideAtLength: function(length, opt) {\n\n\t        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t        var divided = curve.divideAtLength(length, opt);\n\t        return [\n\t            new Curveto(divided[0]),\n\t            new Curveto(divided[1])\n\t        ];\n\t    },\n\n\t    divideAtT: function(t) {\n\n\t        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n\t        var divided = curve.divideAtT(t);\n\t        return [\n\t            new Curveto(divided[0]),\n\t            new Curveto(divided[1])\n\t        ];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        if (!this.previousSegment) { return false; }\n\n\t        var start = this.start;\n\t        var control1 = this.controlPoint1;\n\t        var control2 = this.controlPoint2;\n\t        var end = this.end;\n\n\t        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n\t    },\n\n\t    round: function(precision) {\n\n\t        this.controlPoint1.round(precision);\n\t        this.controlPoint2.round(precision);\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.controlPoint1.scale(sx, sy, origin);\n\t        this.controlPoint2.scale(sx, sy, origin);\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    serialize: function() {\n\n\t        var c1 = this.controlPoint1;\n\t        var c2 = this.controlPoint2;\n\t        var end = this.end;\n\t        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.controlPoint1.translate(tx, ty);\n\t        this.controlPoint2.translate(tx, ty);\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(curvetoPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    value: 'C'\n\t});\n\n\tCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\n\tvar Moveto = function() {\n\t    var arguments$1 = arguments;\n\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 0; i < n; i++) {\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n\t        return applyToNew(Moveto, args);\n\t    }\n\n\t    if (n === 0) {\n\t        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n\t    }\n\n\t    var outputArray;\n\n\t    if (args[0] instanceof Line) { // lines provided\n\t        if (n === 1) {\n\t            this.end = args[0].end.clone();\n\t            return this;\n\n\t        } else {\n\t            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n\t        }\n\n\t    } else if (args[0] instanceof Curve) { // curves provided\n\t        if (n === 1) {\n\t            this.end = args[0].end.clone();\n\t            return this;\n\n\t        } else {\n\t            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n\t        }\n\n\t    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n\t        if (n === 2) {\n\t            this.end = new Point(+args[0], +args[1]);\n\t            return this;\n\n\t        } else if (n < 2) {\n\t            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n\t        } else { // this is a moveto-with-subsequent-poly-line segment\n\t            var segmentCoords;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n\t                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\t                if (i === 0) { outputArray.push(applyToNew(Moveto, segmentCoords)); }\n\t                else { outputArray.push(applyToNew(Lineto, segmentCoords)); }\n\t            }\n\t            return outputArray;\n\t        }\n\n\t    } else { // points provided (needs to be last to also cover plain objects with x and y)\n\t        if (n === 1) {\n\t            this.end = new Point(args[0]);\n\t            return this;\n\n\t        } else { // this is a moveto-with-subsequent-poly-line segment\n\t            var segmentPoint;\n\t            outputArray = [];\n\t            for (i = 0; i < n; i += 1) { // points come one by one\n\n\t                segmentPoint = args[i];\n\t                if (i === 0) { outputArray.push(new Moveto(segmentPoint)); }\n\t                else { outputArray.push(new Lineto(segmentPoint)); }\n\t            }\n\t            return outputArray;\n\t        }\n\t    }\n\t};\n\n\tvar movetoPrototype = {\n\n\t    bbox: function() {\n\n\t        return null;\n\t    },\n\n\t    clone: function() {\n\n\t        return new Moveto(this.end);\n\t    },\n\n\t    closestPoint: function() {\n\n\t        return this.end.clone();\n\t    },\n\n\t    closestPointNormalizedLength: function() {\n\n\t        return 0;\n\t    },\n\n\t    closestPointLength: function() {\n\n\t        return 0;\n\t    },\n\n\t    closestPointT: function() {\n\n\t        return 1;\n\t    },\n\n\t    closestPointTangent: function() {\n\n\t        return null;\n\t    },\n\n\t    divideAt: function() {\n\n\t        return [\n\t            this.clone(),\n\t            this.clone()\n\t        ];\n\t    },\n\n\t    divideAtLength: function() {\n\n\t        return [\n\t            this.clone(),\n\t            this.clone()\n\t        ];\n\t    },\n\n\t    equals: function(m) {\n\n\t        return this.end.equals(m.end);\n\t    },\n\n\t    getSubdivisions: function() {\n\n\t        return [];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        return false;\n\t    },\n\n\t    isSubpathStart: true,\n\n\t    isVisible: false,\n\n\t    length: function() {\n\n\t        return 0;\n\t    },\n\n\t    lengthAtT: function() {\n\n\t        return 0;\n\t    },\n\n\t    pointAt: function() {\n\n\t        return this.end.clone();\n\t    },\n\n\t    pointAtLength: function() {\n\n\t        return this.end.clone();\n\t    },\n\n\t    pointAtT: function() {\n\n\t        return this.end.clone();\n\t    },\n\n\t    round: function(precision) {\n\n\t        this.end.round(precision);\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin) {\n\n\t        this.end.scale(sx, sy, origin);\n\t        return this;\n\t    },\n\n\t    serialize: function() {\n\n\t        var end = this.end;\n\t        return this.type + ' ' + end.x + ' ' + end.y;\n\t    },\n\n\t    tangentAt: function() {\n\n\t        return null;\n\t    },\n\n\t    tangentAtLength: function() {\n\n\t        return null;\n\t    },\n\n\t    tangentAtT: function() {\n\n\t        return null;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.type + ' ' + this.end;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        this.end.translate(tx, ty);\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(movetoPrototype, 'start', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        throw new Error('Illegal access. Moveto segments should not need a start property.');\n\t    }\n\t});\n\n\tObject.defineProperty(movetoPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    value: 'M'\n\t});\n\n\tMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\n\tvar Closepath = function() {\n\t    var arguments$1 = arguments;\n\n\n\t    var args = [];\n\t    var n = arguments.length;\n\t    for (var i = 0; i < n; i++) {\n\t        args.push(arguments$1[i]);\n\t    }\n\n\t    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n\t        return applyToNew(Closepath, args);\n\t    }\n\n\t    if (n > 0) {\n\t        throw new Error('Closepath constructor expects no arguments.');\n\t    }\n\n\t    return this;\n\t};\n\n\tvar closepathPrototype = {\n\n\t    clone: function() {\n\n\t        return new Closepath();\n\t    },\n\n\t    divideAt: function(ratio) {\n\n\t        var line = new Line(this.start, this.end);\n\t        var divided = line.divideAt(ratio);\n\t        return [\n\t            // if we didn't actually cut into the segment, first divided part can stay as Z\n\t            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n\t            new Lineto(divided[1])\n\t        ];\n\t    },\n\n\t    divideAtLength: function(length) {\n\n\t        var line = new Line(this.start, this.end);\n\t        var divided = line.divideAtLength(length);\n\t        return [\n\t            // if we didn't actually cut into the segment, first divided part can stay as Z\n\t            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n\t            new Lineto(divided[1])\n\t        ];\n\t    },\n\n\t    getSubdivisions: function() {\n\n\t        return [];\n\t    },\n\n\t    isDifferentiable: function() {\n\n\t        if (!this.previousSegment || !this.subpathStartSegment) { return false; }\n\n\t        return !this.start.equals(this.end);\n\t    },\n\n\t    round: function() {\n\n\t        return this;\n\t    },\n\n\t    scale: function() {\n\n\t        return this;\n\t    },\n\n\t    serialize: function() {\n\n\t        return this.type;\n\t    },\n\n\t    toString: function() {\n\n\t        return this.type + ' ' + this.start + ' ' + this.end;\n\t    },\n\n\t    translate: function() {\n\n\t        return this;\n\t    }\n\t};\n\n\tObject.defineProperty(closepathPrototype, 'end', {\n\t    // get a reference to the end point of subpath start segment\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    get: function() {\n\n\t        if (!this.subpathStartSegment) { throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)'); }\n\n\t        return this.subpathStartSegment.end;\n\t    }\n\t});\n\n\tObject.defineProperty(closepathPrototype, 'type', {\n\n\t    configurable: true,\n\n\t    enumerable: true,\n\n\t    value: 'Z'\n\t});\n\n\tClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\n\n\tvar segmentTypes = Path.segmentTypes = {\n\t    L: Lineto,\n\t    C: Curveto,\n\t    M: Moveto,\n\t    Z: Closepath,\n\t    z: Closepath\n\t};\n\n\tPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\n\tPath.isDataSupported = function(data) {\n\n\t    if (typeof data !== 'string') { return false; }\n\t    return this.regexSupportedData.test(data);\n\t};\n\n\tvar g = ({\n\t\tbezier: bezier,\n\t\tCurve: Curve,\n\t\tEllipse: Ellipse,\n\t\tLine: Line,\n\t\tPath: Path,\n\t\tPoint: Point,\n\t\tPolyline: Polyline,\n\t\tRect: Rect,\n\t\tscale: scale,\n\t\tnormalizeAngle: normalizeAngle,\n\t\tsnapToGrid: snapToGrid,\n\t\ttoDeg: toDeg,\n\t\ttoRad: toRad,\n\t\trandom: random,\n\t\tellipse: ellipse,\n\t\tline: line,\n\t\tpoint: point,\n\t\trect: rect\n\t});\n\n\t// Vectorizer.\n\n\tvar V = (function() {\n\n\t    var hasSvg = typeof window === 'object' &&\n\t        !!(\n\t            window.SVGAngle ||\n\t            document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')\n\t        );\n\n\t    // SVG support is required.\n\t    if (!hasSvg) {\n\n\t        // Return a function that throws an error when it is used.\n\t        return function() {\n\t            throw new Error('SVG is required to use Vectorizer.');\n\t        };\n\t    }\n\n\t    // XML namespaces.\n\t    var ns = {\n\t        svg: 'http://www.w3.org/2000/svg',\n\t        xmlns: 'http://www.w3.org/2000/xmlns/',\n\t        xml: 'http://www.w3.org/XML/1998/namespace',\n\t        xlink: 'http://www.w3.org/1999/xlink',\n\t        xhtml: 'http://www.w3.org/1999/xhtml'\n\t    };\n\n\t    var SVGVersion = '1.1';\n\n\t    // Declare shorthands to the most used math functions.\n\t    var math = Math;\n\t    var PI = math.PI;\n\t    var atan2 = math.atan2;\n\t    var sqrt = math.sqrt;\n\t    var min = math.min;\n\t    var max = math.max;\n\t    var cos = math.cos;\n\t    var sin = math.sin;\n\n\t    var V = function(el, attrs, children) {\n\n\t        // This allows using V() without the new keyword.\n\t        if (!(this instanceof V)) {\n\t            return V.apply(Object.create(V.prototype), arguments);\n\t        }\n\n\t        if (!el) { return; }\n\n\t        if (V.isV(el)) {\n\t            el = el.node;\n\t        }\n\n\t        attrs = attrs || {};\n\n\t        if (V.isString(el)) {\n\n\t            if (el.toLowerCase() === 'svg') {\n\n\t                // Create a new SVG canvas.\n\t                el = V.createSvgDocument();\n\n\t            } else if (el[0] === '<') {\n\n\t                // Create element from an SVG string.\n\t                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n\t                var svgDoc = V.createSvgDocument(el);\n\n\t                // Note that `V()` might also return an array should the SVG string passed as\n\t                // the first argument contain more than one root element.\n\t                if (svgDoc.childNodes.length > 1) {\n\n\t                    // Map child nodes to `V`s.\n\t                    var arrayOfVels = [];\n\t                    var i, len;\n\n\t                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\n\t                        var childNode = svgDoc.childNodes[i];\n\t                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n\t                    }\n\n\t                    return arrayOfVels;\n\t                }\n\n\t                el = document.importNode(svgDoc.firstChild, true);\n\n\t            } else {\n\n\t                el = document.createElementNS(ns.svg, el);\n\t            }\n\n\t            V.ensureId(el);\n\t        }\n\n\t        this.node = el;\n\n\t        this.setAttributes(attrs);\n\n\t        if (children) {\n\t            this.append(children);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    var VPrototype = V.prototype;\n\n\t    Object.defineProperty(VPrototype, 'id', {\n\t        enumerable: true,\n\t        get: function() {\n\t            return this.node.id;\n\t        },\n\t        set: function(id) {\n\t            this.node.id = id;\n\t        }\n\t    });\n\n\t    /**\n\t     * @param {SVGGElement} toElem\n\t     * @returns {SVGMatrix}\n\t     */\n\t    VPrototype.getTransformToElement = function(target) {\n\t        var node = this.node;\n\t        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n\t            var targetCTM = V.toNode(target).getScreenCTM();\n\t            var nodeCTM = node.getScreenCTM();\n\t            if (targetCTM && nodeCTM) {\n\t                return targetCTM.inverse().multiply(nodeCTM);\n\t            }\n\t        }\n\t        // Could not get actual transformation matrix\n\t        return V.createSVGMatrix();\n\t    };\n\n\t    /**\n\t     * @param {SVGMatrix} matrix\n\t     * @param {Object=} opt\n\t     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n\t     */\n\t    VPrototype.transform = function(matrix, opt) {\n\n\t        var node = this.node;\n\t        if (V.isUndefined(matrix)) {\n\t            return V.transformStringToMatrix(this.attr('transform'));\n\t        }\n\n\t        if (opt && opt.absolute) {\n\t            return this.attr('transform', V.matrixToTransformString(matrix));\n\t        }\n\n\t        var svgTransform = V.createSVGTransform(matrix);\n\t        node.transform.baseVal.appendItem(svgTransform);\n\t        return this;\n\t    };\n\n\t    VPrototype.translate = function(tx, ty, opt) {\n\n\t        opt = opt || {};\n\t        ty = ty || 0;\n\n\t        var transformAttr = this.attr('transform') || '';\n\t        var transform = V.parseTransformString(transformAttr);\n\t        transformAttr = transform.value;\n\t        // Is it a getter?\n\t        if (V.isUndefined(tx)) {\n\t            return transform.translate;\n\t        }\n\n\t        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\n\t        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n\t        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n\t        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n\t        // Note that `translate()` is always the first transformation. This is\n\t        // usually the desired case.\n\t        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n\t        return this;\n\t    };\n\n\t    VPrototype.rotate = function(angle, cx, cy, opt) {\n\n\t        opt = opt || {};\n\n\t        var transformAttr = this.attr('transform') || '';\n\t        var transform = V.parseTransformString(transformAttr);\n\t        transformAttr = transform.value;\n\n\t        // Is it a getter?\n\t        if (V.isUndefined(angle)) {\n\t            return transform.rotate;\n\t        }\n\n\t        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\n\t        angle %= 360;\n\n\t        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n\t        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\n\t        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\n\t        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n\t        return this;\n\t    };\n\n\t    // Note that `scale` as the only transformation does not combine with previous values.\n\t    VPrototype.scale = function(sx, sy) {\n\n\t        sy = V.isUndefined(sy) ? sx : sy;\n\n\t        var transformAttr = this.attr('transform') || '';\n\t        var transform = V.parseTransformString(transformAttr);\n\t        transformAttr = transform.value;\n\n\t        // Is it a getter?\n\t        if (V.isUndefined(sx)) {\n\t            return transform.scale;\n\t        }\n\n\t        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\n\t        var newScale = 'scale(' + sx + ',' + sy + ')';\n\n\t        this.attr('transform', (transformAttr + ' ' + newScale).trim());\n\t        return this;\n\t    };\n\n\t    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n\t    // i.e. after transformations are applied.\n\t    // If `target` is specified, bounding box will be computed relatively to `target` element.\n\t    VPrototype.bbox = function(withoutTransformations, target) {\n\n\t        var box;\n\t        var node = this.node;\n\t        var ownerSVGElement = node.ownerSVGElement;\n\n\t        // If the element is not in the live DOM, it does not have a bounding box defined and\n\t        // so fall back to 'zero' dimension element.\n\t        if (!ownerSVGElement) {\n\t            return new Rect(0, 0, 0, 0);\n\t        }\n\n\t        try {\n\n\t            box = node.getBBox();\n\n\t        } catch (e) {\n\n\t            // Fallback for IE.\n\t            box = {\n\t                x: node.clientLeft,\n\t                y: node.clientTop,\n\t                width: node.clientWidth,\n\t                height: node.clientHeight\n\t            };\n\t        }\n\n\t        if (withoutTransformations) {\n\t            return new Rect(box);\n\t        }\n\n\t        var matrix = this.getTransformToElement(target || ownerSVGElement);\n\n\t        return V.transformRect(box, matrix);\n\t    };\n\n\t    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n\t    // i.e. after transformations are applied.\n\t    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n\t    // Takes an (Object) `opt` argument (optional) with the following attributes:\n\t    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n\t    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n\t    VPrototype.getBBox = function(opt) {\n\n\t        var options = {};\n\n\t        var outputBBox;\n\t        var node = this.node;\n\t        var ownerSVGElement = node.ownerSVGElement;\n\n\t        // If the element is not in the live DOM, it does not have a bounding box defined and\n\t        // so fall back to 'zero' dimension element.\n\t        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n\t        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n\t            return new Rect(0, 0, 0, 0);\n\t        }\n\n\t        if (opt) {\n\t            if (opt.target) { // check if target exists\n\t                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n\t            }\n\t            if (opt.recursive) {\n\t                options.recursive = opt.recursive;\n\t            }\n\t        }\n\n\t        if (!options.recursive) {\n\t            try {\n\t                outputBBox = node.getBBox();\n\t            } catch (e) {\n\t                // Fallback for IE.\n\t                outputBBox = {\n\t                    x: node.clientLeft,\n\t                    y: node.clientTop,\n\t                    width: node.clientWidth,\n\t                    height: node.clientHeight\n\t                };\n\t            }\n\n\t            if (!options.target) {\n\t                // transform like this (that is, not at all)\n\t                return new Rect(outputBBox);\n\t            } else {\n\t                // transform like target\n\t                var matrix = this.getTransformToElement(options.target);\n\t                return V.transformRect(outputBBox, matrix);\n\t            }\n\t        } else { // if we want to calculate the bbox recursively\n\t            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n\t            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n\t            // this happens even if we wrap a single svg element into a group!\n\t            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n\t            var children = this.children();\n\t            var n = children.length;\n\n\t            if (n === 0) {\n\t                return this.getBBox({ target: options.target, recursive: false });\n\t            }\n\n\t            // recursion's initial pass-through setting:\n\t            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n\t            if (!options.target) {\n\t                // transform children/descendants like this (their parent/ancestor)\n\t                options.target = this;\n\t            } // else transform children/descendants like target\n\n\t            for (var i = 0; i < n; i++) {\n\t                var currentChild = children[i];\n\n\t                var childBBox;\n\n\t                // if currentChild is not a group element, get its bbox with a nonrecursive call\n\t                if (currentChild.children().length === 0) {\n\t                    childBBox = currentChild.getBBox({ target: options.target, recursive: false });\n\t                } else {\n\t                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n\t                    childBBox = currentChild.getBBox({ target: options.target, recursive: true });\n\t                }\n\n\t                if (!outputBBox) {\n\t                    // if this is the first iteration\n\t                    outputBBox = childBBox;\n\t                } else {\n\t                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n\t                    outputBBox = outputBBox.union(childBBox);\n\t                }\n\t            }\n\n\t            return outputBBox;\n\t        }\n\t    };\n\n\t    // Text() helpers\n\n\t    function createTextPathNode(attrs, vel) {\n\t        attrs || (attrs = {});\n\t        var textPathElement = V('textPath');\n\t        var d = attrs.d;\n\t        if (d && attrs['xlink:href'] === undefined) {\n\t            // If `opt.attrs` is a plain string, consider it to be directly the\n\t            // SVG path data for the text to go along (this is a shortcut).\n\t            // Otherwise if it is an object and contains the `d` property, then this is our path.\n\t            // Wrap the text in the SVG <textPath> element that points\n\t            // to a path defined by `opt.attrs` inside the `<defs>` element.\n\t            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n\t            textPathElement.attr('xlink:href', '#' + linkedPath.id);\n\t        }\n\t        if (V.isObject(attrs)) {\n\t            // Set attributes on the `<textPath>`. The most important one\n\t            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n\t            // Note that we also allow the following construct:\n\t            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n\t            // In other words, one can completely skip the auto-creation of the path\n\t            // and use any other arbitrary path that is in the document.\n\t            textPathElement.attr(attrs);\n\t        }\n\t        return textPathElement.node;\n\t    }\n\n\t    function annotateTextLine(lineNode, lineAnnotations, opt) {\n\t        opt || (opt = {});\n\t        var includeAnnotationIndices = opt.includeAnnotationIndices;\n\t        var eol = opt.eol;\n\t        var lineHeight = opt.lineHeight;\n\t        var baseSize = opt.baseSize;\n\t        var maxFontSize = 0;\n\t        var fontMetrics = {};\n\t        var lastJ = lineAnnotations.length - 1;\n\t        for (var j = 0; j <= lastJ; j++) {\n\t            var annotation = lineAnnotations[j];\n\t            var fontSize = null;\n\t            if (V.isObject(annotation)) {\n\t                var annotationAttrs = annotation.attrs;\n\t                var vTSpan = V('tspan', annotationAttrs);\n\t                var tspanNode = vTSpan.node;\n\t                var t = annotation.t;\n\t                if (eol && j === lastJ) { t += eol; }\n\t                tspanNode.textContent = t;\n\t                // Per annotation className\n\t                var annotationClass = annotationAttrs['class'];\n\t                if (annotationClass) { vTSpan.addClass(annotationClass); }\n\t                // If `opt.includeAnnotationIndices` is `true`,\n\t                // set the list of indices of all the applied annotations\n\t                // in the `annotations` attribute. This list is a comma\n\t                // separated list of indices.\n\t                if (includeAnnotationIndices) { vTSpan.attr('annotations', annotation.annotations); }\n\t                // Check for max font size\n\t                fontSize = parseFloat(annotationAttrs['font-size']);\n\t                if (fontSize === undefined) { fontSize = baseSize; }\n\t                if (fontSize && fontSize > maxFontSize) { maxFontSize = fontSize; }\n\t            } else {\n\t                if (eol && j === lastJ) { annotation += eol; }\n\t                tspanNode = document.createTextNode(annotation || ' ');\n\t                if (baseSize && baseSize > maxFontSize) { maxFontSize = baseSize; }\n\t            }\n\t            lineNode.appendChild(tspanNode);\n\t        }\n\n\t        if (maxFontSize) { fontMetrics.maxFontSize = maxFontSize; }\n\t        if (lineHeight) {\n\t            fontMetrics.lineHeight = lineHeight;\n\t        } else if (maxFontSize) {\n\t            fontMetrics.lineHeight = (maxFontSize * 1.2);\n\t        }\n\t        return fontMetrics;\n\t    }\n\n\t    var emRegex = /em$/;\n\n\t    function convertEmToPx(em, fontSize) {\n\t        var numerical = parseFloat(em);\n\t        if (emRegex.test(em)) { return numerical * fontSize; }\n\t        return numerical;\n\t    }\n\n\t    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n\t        if (!Array.isArray(linesMetrics)) { return 0; }\n\t        var n = linesMetrics.length;\n\t        if (!n) { return 0; }\n\t        var lineMetrics = linesMetrics[0];\n\t        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n\t        var rLineHeights = 0;\n\t        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n\t        for (var i = 1; i < n; i++) {\n\t            lineMetrics = linesMetrics[i];\n\t            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n\t            rLineHeights += iLineHeight;\n\t        }\n\t        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n\t        var dy;\n\t        switch (alignment) {\n\t            case 'middle':\n\t                dy = (flMaxFont / 2) - (0.15 * llMaxFont) - (rLineHeights / 2);\n\t                break;\n\t            case 'bottom':\n\t                dy = -(0.25 * llMaxFont) - rLineHeights;\n\t                break;\n\t            default:\n\t            case 'top':\n\t                dy = (0.8 * flMaxFont);\n\t                break;\n\t        }\n\t        return dy;\n\t    }\n\n\t    VPrototype.text = function(content, opt) {\n\n\t        if (content && typeof content !== 'string') { throw new Error('Vectorizer: text() expects the first argument to be a string.'); }\n\n\t        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n\t        // IE would otherwise collapse all spaces into one.\n\t        content = V.sanitizeText(content);\n\t        opt || (opt = {});\n\t        // Should we allow the text to be selected?\n\t        var displayEmpty = opt.displayEmpty;\n\t        // End of Line character\n\t        var eol = opt.eol;\n\t        // Text along path\n\t        var textPath = opt.textPath;\n\t        // Vertical shift\n\t        var verticalAnchor = opt.textVerticalAnchor;\n\t        var namedVerticalAnchor = (verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top');\n\t        // Horizontal shift applied to all the lines but the first.\n\t        var x = opt.x;\n\t        if (x === undefined) { x = this.attr('x') || 0; }\n\t        // Annotations\n\t        var iai = opt.includeAnnotationIndices;\n\t        var annotations = opt.annotations;\n\t        if (annotations && !V.isArray(annotations)) { annotations = [annotations]; }\n\t        // Shift all the <tspan> but first by one line (`1em`)\n\t        var defaultLineHeight = opt.lineHeight;\n\t        var autoLineHeight = (defaultLineHeight === 'auto');\n\t        var lineHeight = (autoLineHeight) ? '1.5em' : (defaultLineHeight || '1em');\n\t        // Clearing the element\n\t        this.empty();\n\t        this.attr({\n\t            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n\t            'xml:space': 'preserve',\n\t            // An empty text gets rendered into the DOM in webkit-based browsers.\n\t            // In order to unify this behaviour across all browsers\n\t            // we rather hide the text element when it's empty.\n\t            'display': (content || displayEmpty) ? null : 'none'\n\t        });\n\n\t        // Set default font-size if none\n\t        var fontSize = parseFloat(this.attr('font-size'));\n\t        if (!fontSize) {\n\t            fontSize = 16;\n\t            if (namedVerticalAnchor || annotations) { this.attr('font-size', fontSize); }\n\t        }\n\n\t        var doc = document;\n\t        var containerNode;\n\t        if (textPath) {\n\t            // Now all the `<tspan>`s will be inside the `<textPath>`.\n\t            if (typeof textPath === 'string') { textPath = { d: textPath }; }\n\t            containerNode = createTextPathNode(textPath, this);\n\t        } else {\n\t            containerNode = doc.createDocumentFragment();\n\t        }\n\t        var offset = 0;\n\t        var lines = content.split('\\n');\n\t        var linesMetrics = [];\n\t        var annotatedY;\n\t        for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n\t            var dy = lineHeight;\n\t            var lineClassName = 'v-line';\n\t            var lineNode = doc.createElementNS(ns.svg, 'tspan');\n\t            var line = lines[i];\n\t            var lineMetrics;\n\t            if (line) {\n\t                if (annotations) {\n\t                    // Find the *compacted* annotations for this line.\n\t                    var lineAnnotations = V.annotateString(line, annotations, {\n\t                        offset: -offset,\n\t                        includeAnnotationIndices: iai\n\t                    });\n\t                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n\t                        includeAnnotationIndices: iai,\n\t                        eol: (i !== lastI && eol),\n\t                        lineHeight: (autoLineHeight) ? null : lineHeight,\n\t                        baseSize: fontSize\n\t                    });\n\t                    // Get the line height based on the biggest font size in the annotations for this line.\n\t                    var iLineHeight = lineMetrics.lineHeight;\n\t                    if (iLineHeight && autoLineHeight && i !== 0) { dy = iLineHeight; }\n\t                    if (i === 0) { annotatedY = lineMetrics.maxFontSize * 0.8; }\n\t                } else {\n\t                    if (eol && i !== lastI) { line += eol; }\n\t                    lineNode.textContent = line;\n\t                }\n\t            } else {\n\t                // Make sure the textContent is never empty. If it is, add a dummy\n\t                // character and make it invisible, making the following lines correctly\n\t                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n\t                lineNode.textContent = '-';\n\t                lineClassName += ' v-empty-line';\n\t                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n\t                // is not applied in Firefox\n\t                var lineNodeStyle = lineNode.style;\n\t                lineNodeStyle.fillOpacity = 0;\n\t                lineNodeStyle.strokeOpacity = 0;\n\t                if (annotations) { lineMetrics = {}; }\n\t            }\n\t            if (lineMetrics) { linesMetrics.push(lineMetrics); }\n\t            if (i > 0) { lineNode.setAttribute('dy', dy); }\n\t            // Firefox requires 'x' to be set on the first line when inside a text path\n\t            if (i > 0 || textPath) { lineNode.setAttribute('x', x); }\n\t            lineNode.className.baseVal = lineClassName;\n\t            containerNode.appendChild(lineNode);\n\t            offset += line.length + 1;      // + 1 = newline character.\n\t        }\n\t        // Y Alignment calculation\n\t        if (namedVerticalAnchor) {\n\t            if (annotations) {\n\t                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n\t            } else if (verticalAnchor === 'top') {\n\t                // A shortcut for top alignment. It does not depend on font-size nor line-height\n\t                dy = '0.8em';\n\t            } else {\n\t                var rh; // remaining height\n\t                if (lastI > 0) {\n\t                    rh = parseFloat(lineHeight) || 1;\n\t                    rh *= lastI;\n\t                    if (!emRegex.test(lineHeight)) { rh /= fontSize; }\n\t                } else {\n\t                    // Single-line text\n\t                    rh = 0;\n\t                }\n\t                switch (verticalAnchor) {\n\t                    case 'middle':\n\t                        dy = (0.3 - (rh / 2)) + 'em';\n\t                        break;\n\t                    case 'bottom':\n\t                        dy = (-rh - 0.3) + 'em';\n\t                        break;\n\t                }\n\t            }\n\t        } else {\n\t            if (verticalAnchor === 0) {\n\t                dy = '0em';\n\t            } else if (verticalAnchor) {\n\t                dy = verticalAnchor;\n\t            } else {\n\t                // No vertical anchor is defined\n\t                dy = 0;\n\t                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n\t                if (this.attr('y') === null) { this.attr('y', annotatedY || '0.8em'); }\n\t            }\n\t        }\n\t        containerNode.firstChild.setAttribute('dy', dy);\n\t        // Appending lines to the element.\n\t        this.append(containerNode);\n\t        return this;\n\t    };\n\n\t    /**\n\t     * @public\n\t     * @param {string} name\n\t     * @returns {Vectorizer}\n\t     */\n\t    VPrototype.removeAttr = function(name) {\n\n\t        var qualifiedName = V.qualifyAttr(name);\n\t        var el = this.node;\n\n\t        if (qualifiedName.ns) {\n\t            if (el.hasAttributeNS(qualifiedName.ns, qualifiedName.local)) {\n\t                el.removeAttributeNS(qualifiedName.ns, qualifiedName.local);\n\t            }\n\t        } else if (el.hasAttribute(name)) {\n\t            el.removeAttribute(name);\n\t        }\n\t        return this;\n\t    };\n\n\t    VPrototype.attr = function(name, value) {\n\n\t        if (V.isUndefined(name)) {\n\n\t            // Return all attributes.\n\t            var attributes = this.node.attributes;\n\t            var attrs = {};\n\n\t            for (var i = 0; i < attributes.length; i++) {\n\t                attrs[attributes[i].name] = attributes[i].value;\n\t            }\n\n\t            return attrs;\n\t        }\n\n\t        if (V.isString(name) && V.isUndefined(value)) {\n\t            return this.node.getAttribute(name);\n\t        }\n\n\t        if (typeof name === 'object') {\n\n\t            for (var attrName in name) {\n\t                if (name.hasOwnProperty(attrName)) {\n\t                    this.setAttribute(attrName, name[attrName]);\n\t                }\n\t            }\n\n\t        } else {\n\n\t            this.setAttribute(name, value);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.normalizePath = function() {\n\n\t        var tagName = this.tagName();\n\t        if (tagName === 'PATH') {\n\t            this.attr('d', V.normalizePathData(this.attr('d')));\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.remove = function() {\n\n\t        if (this.node.parentNode) {\n\t            this.node.parentNode.removeChild(this.node);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.empty = function() {\n\n\t        while (this.node.firstChild) {\n\t            this.node.removeChild(this.node.firstChild);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    /**\n\t     * @private\n\t     * @param {object} attrs\n\t     * @returns {Vectorizer}\n\t     */\n\t    VPrototype.setAttributes = function(attrs) {\n\n\t        for (var key in attrs) {\n\t            if (attrs.hasOwnProperty(key)) {\n\t                this.setAttribute(key, attrs[key]);\n\t            }\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.append = function(els) {\n\n\t        if (!V.isArray(els)) {\n\t            els = [els];\n\t        }\n\n\t        for (var i = 0, len = els.length; i < len; i++) {\n\t            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.prepend = function(els) {\n\n\t        var child = this.node.firstChild;\n\t        return child ? V(child).before(els) : this.append(els);\n\t    };\n\n\t    VPrototype.before = function(els) {\n\n\t        var node = this.node;\n\t        var parent = node.parentNode;\n\n\t        if (parent) {\n\n\t            if (!V.isArray(els)) {\n\t                els = [els];\n\t            }\n\n\t            for (var i = 0, len = els.length; i < len; i++) {\n\t                parent.insertBefore(V.toNode(els[i]), node);\n\t            }\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.appendTo = function(node) {\n\t        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n\t        return this;\n\t    };\n\n\t    VPrototype.svg = function() {\n\n\t        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n\t    };\n\n\t    VPrototype.tagName = function() {\n\n\t        return this.node.tagName.toUpperCase();\n\t    };\n\n\t    VPrototype.defs = function() {\n\t        var context = this.svg() || this;\n\t        var defsNode = context.node.getElementsByTagName('defs')[0];\n\t        if (defsNode) { return V(defsNode); }\n\t        return V('defs').appendTo(context);\n\t    };\n\n\t    VPrototype.clone = function() {\n\n\t        var clone = V(this.node.cloneNode(true/* deep */));\n\t        // Note that clone inherits also ID. Therefore, we need to change it here.\n\t        clone.node.id = V.uniqueId();\n\t        return clone;\n\t    };\n\n\t    VPrototype.findOne = function(selector) {\n\n\t        var found = this.node.querySelector(selector);\n\t        return found ? V(found) : undefined;\n\t    };\n\n\t    VPrototype.find = function(selector) {\n\n\t        var vels = [];\n\t        var nodes = this.node.querySelectorAll(selector);\n\n\t        if (nodes) {\n\n\t            // Map DOM elements to `V`s.\n\t            for (var i = 0; i < nodes.length; i++) {\n\t                vels.push(V(nodes[i]));\n\t            }\n\t        }\n\n\t        return vels;\n\t    };\n\n\t    // Returns an array of V elements made from children of this.node.\n\t    VPrototype.children = function() {\n\n\t        var children = this.node.childNodes;\n\n\t        var outputArray = [];\n\t        for (var i = 0; i < children.length; i++) {\n\t            var currentChild = children[i];\n\t            if (currentChild.nodeType === 1) {\n\t                outputArray.push(V(children[i]));\n\t            }\n\t        }\n\t        return outputArray;\n\t    };\n\n\t    // Returns the V element from parentNode of this.node.\n\t    VPrototype.parent = function() {\n\t        return V(this.node.parentNode) || null;\n\t    },\n\n\t    // Find an index of an element inside its container.\n\t    VPrototype.index = function() {\n\n\t        var index = 0;\n\t        var node = this.node.previousSibling;\n\n\t        while (node) {\n\t            // nodeType 1 for ELEMENT_NODE\n\t            if (node.nodeType === 1) { index++; }\n\t            node = node.previousSibling;\n\t        }\n\n\t        return index;\n\t    };\n\n\t    VPrototype.findParentByClass = function(className, terminator) {\n\n\t        var ownerSVGElement = this.node.ownerSVGElement;\n\t        var node = this.node.parentNode;\n\n\t        while (node && node !== terminator && node !== ownerSVGElement) {\n\n\t            var vel = V(node);\n\t            if (vel.hasClass(className)) {\n\t                return vel;\n\t            }\n\n\t            node = node.parentNode;\n\t        }\n\n\t        return null;\n\t    };\n\n\t    // https://jsperf.com/get-common-parent\n\t    VPrototype.contains = function(el) {\n\n\t        var a = this.node;\n\t        var b = V.toNode(el);\n\t        var bup = b && b.parentNode;\n\n\t        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\n\t    };\n\n\t    // Convert global point into the coordinate space of this element.\n\t    VPrototype.toLocalPoint = function(x, y) {\n\n\t        var svg = this.svg().node;\n\n\t        var p = svg.createSVGPoint();\n\t        p.x = x;\n\t        p.y = y;\n\n\t        try {\n\n\t            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n\t            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\n\t        } catch (e) {\n\t            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n\t            // We have to make do with the original coordianates.\n\t            return p;\n\t        }\n\n\t        return globalPoint.matrixTransform(globalToLocalMatrix);\n\t    };\n\n\t    VPrototype.translateCenterToPoint = function(p) {\n\n\t        var bbox = this.getBBox({ target: this.svg() });\n\t        var center = bbox.center();\n\n\t        this.translate(p.x - center.x, p.y - center.y);\n\t        return this;\n\t    };\n\n\t    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n\t    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n\t    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n\t    // being auto-oriented (properly rotated) towards the `reference` point.\n\t    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n\t    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n\n\t        position = new Point(position);\n\t        reference =  new Point(reference);\n\t        target || (target = this.svg());\n\n\t        // Clean-up previously set transformations except the scale. If we didn't clean up the\n\t        // previous transformations then they'd add up with the old ones. Scale is an exception as\n\t        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n\t        // element is scaled by the factor 2, not 8.\n\t        var scale = this.scale();\n\t        this.attr('transform', '');\n\t        var bbox = this.getBBox({ target: target }).scale(scale.sx, scale.sy);\n\n\t        // 1. Translate to origin.\n\t        var translateToOrigin = V.createSVGTransform();\n\t        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n\t        // 2. Rotate around origin.\n\t        var rotateAroundOrigin = V.createSVGTransform();\n\t        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n\t        if (angle) { rotateAroundOrigin.setRotate(angle, 0, 0); }\n\n\t        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n\t        var translateFromOrigin = V.createSVGTransform();\n\t        var finalPosition = position.clone().move(reference, bbox.width / 2);\n\t        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n\t        // 4. Get the current transformation matrix of this node\n\t        var ctm = this.getTransformToElement(target);\n\n\t        // 5. Apply transformations and the scale\n\t        var transform = V.createSVGTransform();\n\t        transform.setMatrix(\n\t            translateFromOrigin.matrix.multiply(\n\t                rotateAroundOrigin.matrix.multiply(\n\t                    translateToOrigin.matrix.multiply(\n\t                        ctm.scale(scale.sx, scale.sy)))));\n\n\t        this.attr('transform', V.matrixToTransformString(transform.matrix));\n\n\t        return this;\n\t    };\n\n\t    VPrototype.animateAlongPath = function(attrs, path) {\n\n\t        path = V.toNode(path);\n\n\t        var id = V.ensureId(path);\n\t        var animateMotion = V('animateMotion', attrs);\n\t        var mpath = V('mpath', { 'xlink:href': '#' + id });\n\n\t        animateMotion.append(mpath);\n\n\t        this.append(animateMotion);\n\t        try {\n\t            animateMotion.node.beginElement();\n\t        } catch (e) {\n\t            // Fallback for IE 9.\n\t            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n\t            if (document.documentElement.getAttribute('smiling') === 'fake') {\n\t                /* global getTargets:true, Animator:true, animators:true id2anim:true */\n\t                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n\t                var animation = animateMotion.node;\n\t                animation.animators = [];\n\n\t                var animationID = animation.getAttribute('id');\n\t                if (animationID) { id2anim[animationID] = animation; }\n\n\t                var targets = getTargets(animation);\n\t                for (var i = 0, len = targets.length; i < len; i++) {\n\t                    var target = targets[i];\n\t                    var animator = new Animator(animation, target, i);\n\t                    animators.push(animator);\n\t                    animation.animators[i] = animator;\n\t                    animator.register();\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\n\t    VPrototype.hasClass = function(className) {\n\n\t        return new RegExp('(\\\\s|^)' + className + '(\\\\s|$)').test(this.node.getAttribute('class'));\n\t    };\n\n\t    VPrototype.addClass = function(className) {\n\n\t        if (className && !this.hasClass(className)) {\n\t            var prevClasses = this.node.getAttribute('class') || '';\n\t            this.node.setAttribute('class', (prevClasses + ' ' + className).trim());\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.removeClass = function(className) {\n\n\t        if (className && this.hasClass(className)) {\n\t            var newClasses = this.node.getAttribute('class').replace(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)', 'g'), '$2');\n\t            this.node.setAttribute('class', newClasses);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    VPrototype.toggleClass = function(className, toAdd) {\n\n\t        var toRemove = V.isUndefined(toAdd) ? this.hasClass(className) : !toAdd;\n\n\t        if (toRemove) {\n\t            this.removeClass(className);\n\t        } else {\n\t            this.addClass(className);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    // Interpolate path by discrete points. The precision of the sampling\n\t    // is controlled by `interval`. In other words, `sample()` will generate\n\t    // a point on the path starting at the beginning of the path going to the end\n\t    // every `interval` pixels.\n\t    // The sampler can be very useful for e.g. finding intersection between two\n\t    // paths (finding the two closest points from two samples).\n\t    VPrototype.sample = function(interval) {\n\n\t        interval = interval || 1;\n\t        var node = this.node;\n\t        var length = node.getTotalLength();\n\t        var samples = [];\n\t        var distance = 0;\n\t        var sample;\n\t        while (distance < length) {\n\t            sample = node.getPointAtLength(distance);\n\t            samples.push({ x: sample.x, y: sample.y, distance: distance });\n\t            distance += interval;\n\t        }\n\t        return samples;\n\t    };\n\n\t    VPrototype.convertToPath = function() {\n\n\t        var path = V('path');\n\t        path.attr(this.attr());\n\t        var d = this.convertToPathData();\n\t        if (d) {\n\t            path.attr('d', d);\n\t        }\n\t        return path;\n\t    };\n\n\t    VPrototype.convertToPathData = function() {\n\n\t        var tagName = this.tagName();\n\n\t        switch (tagName) {\n\t            case 'PATH':\n\t                return this.attr('d');\n\t            case 'LINE':\n\t                return V.convertLineToPathData(this.node);\n\t            case 'POLYGON':\n\t                return V.convertPolygonToPathData(this.node);\n\t            case 'POLYLINE':\n\t                return V.convertPolylineToPathData(this.node);\n\t            case 'ELLIPSE':\n\t                return V.convertEllipseToPathData(this.node);\n\t            case 'CIRCLE':\n\t                return V.convertCircleToPathData(this.node);\n\t            case 'RECT':\n\t                return V.convertRectToPathData(this.node);\n\t        }\n\n\t        throw new Error(tagName + ' cannot be converted to PATH.');\n\t    };\n\n\t    V.prototype.toGeometryShape = function() {\n\t        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n\t        switch (this.tagName()) {\n\n\t            case 'RECT':\n\t                x = parseFloat(this.attr('x')) || 0;\n\t                y = parseFloat(this.attr('y')) || 0;\n\t                width = parseFloat(this.attr('width')) || 0;\n\t                height = parseFloat(this.attr('height')) || 0;\n\t                return new Rect(x, y, width, height);\n\n\t            case 'CIRCLE':\n\t                cx = parseFloat(this.attr('cx')) || 0;\n\t                cy = parseFloat(this.attr('cy')) || 0;\n\t                r = parseFloat(this.attr('r')) || 0;\n\t                return new Ellipse({ x: cx, y: cy }, r, r);\n\n\t            case 'ELLIPSE':\n\t                cx = parseFloat(this.attr('cx')) || 0;\n\t                cy = parseFloat(this.attr('cy')) || 0;\n\t                rx = parseFloat(this.attr('rx')) || 0;\n\t                ry = parseFloat(this.attr('ry')) || 0;\n\t                return new Ellipse({ x: cx, y: cy }, rx, ry);\n\n\t            case 'POLYLINE':\n\t                points = V.getPointsFromSvgNode(this);\n\t                return new Polyline(points);\n\n\t            case 'POLYGON':\n\t                points = V.getPointsFromSvgNode(this);\n\t                if (points.length > 1) { points.push(points[0]); }\n\t                return new Polyline(points);\n\n\t            case 'PATH':\n\t                d = this.attr('d');\n\t                if (!Path.isDataSupported(d)) { d = V.normalizePathData(d); }\n\t                return new Path(d);\n\n\t            case 'LINE':\n\t                x1 = parseFloat(this.attr('x1')) || 0;\n\t                y1 = parseFloat(this.attr('y1')) || 0;\n\t                x2 = parseFloat(this.attr('x2')) || 0;\n\t                y2 = parseFloat(this.attr('y2')) || 0;\n\t                return new Line({ x: x1, y: y1 }, { x: x2, y: y2 });\n\t        }\n\n\t        // Anything else is a rectangle\n\t        return this.getBBox();\n\t    };\n\n\t    // Find the intersection of a line starting in the center\n\t    // of the SVG `node` ending in the point `ref`.\n\t    // `target` is an SVG element to which `node`s transformations are relative to.\n\t    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n\t    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n\t    // an intersection is found. Returns `undefined` otherwise.\n\t    VPrototype.findIntersection = function(ref, target) {\n\n\t        var svg = this.svg().node;\n\t        target = target || svg;\n\t        var bbox = this.getBBox({ target: target });\n\t        var center = bbox.center();\n\n\t        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) { return undefined; }\n\n\t        var spot;\n\t        var tagName = this.tagName();\n\n\t        // Little speed up optimization for `<rect>` element. We do not do conversion\n\t        // to path element and sampling but directly calculate the intersection through\n\t        // a transformed geometrical rectangle.\n\t        if (tagName === 'RECT') {\n\n\t            var gRect = new Rect(\n\t                parseFloat(this.attr('x') || 0),\n\t                parseFloat(this.attr('y') || 0),\n\t                parseFloat(this.attr('width')),\n\t                parseFloat(this.attr('height'))\n\t            );\n\t            // Get the rect transformation matrix with regards to the SVG document.\n\t            var rectMatrix = this.getTransformToElement(target);\n\t            // Decompose the matrix to find the rotation angle.\n\t            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n\t            // Now we want to rotate the rectangle back so that we\n\t            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n\t            var resetRotation = svg.createSVGTransform();\n\t            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n\t            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n\t            spot = (new Rect(rect)).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\n\t        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\n\t            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\n\t            var samples = pathNode.sample();\n\t            var minDistance = Infinity;\n\t            var closestSamples = [];\n\n\t            var i, sample, gp, centerDistance, refDistance, distance;\n\n\t            for (i = 0; i < samples.length; i++) {\n\n\t                sample = samples[i];\n\t                // Convert the sample point in the local coordinate system to the global coordinate system.\n\t                gp = V.createSVGPoint(sample.x, sample.y);\n\t                gp = gp.matrixTransform(this.getTransformToElement(target));\n\t                sample = new Point(gp);\n\t                centerDistance = sample.distance(center);\n\t                // Penalize a higher distance to the reference point by 10%.\n\t                // This gives better results. This is due to\n\t                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n\t                refDistance = sample.distance(ref) * 1.1;\n\t                distance = centerDistance + refDistance;\n\n\t                if (distance < minDistance) {\n\t                    minDistance = distance;\n\t                    closestSamples = [{ sample: sample, refDistance: refDistance }];\n\t                } else if (distance < minDistance + 1) {\n\t                    closestSamples.push({ sample: sample, refDistance: refDistance });\n\t                }\n\t            }\n\n\t            closestSamples.sort(function(a, b) {\n\t                return a.refDistance - b.refDistance;\n\t            });\n\n\t            if (closestSamples[0]) {\n\t                spot = closestSamples[0].sample;\n\t            }\n\t        }\n\n\t        return spot;\n\t    };\n\n\t    /**\n\t     * @private\n\t     * @param {string} name\n\t     * @param {string} value\n\t     * @returns {Vectorizer}\n\t     */\n\t    VPrototype.setAttribute = function(name, value) {\n\n\t        var el = this.node;\n\n\t        if (value === null) {\n\t            this.removeAttr(name);\n\t            return this;\n\t        }\n\n\t        var qualifiedName = V.qualifyAttr(name);\n\n\t        if (qualifiedName.ns) {\n\t            // Attribute names can be namespaced. E.g. `image` elements\n\t            // have a `xlink:href` attribute to set the source of the image.\n\t            el.setAttributeNS(qualifiedName.ns, name, value);\n\t        } else if (name === 'id') {\n\t            el.id = value;\n\t        } else {\n\t            el.setAttribute(name, value);\n\t        }\n\n\t        return this;\n\t    };\n\n\t    // Create an SVG document element.\n\t    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n\t    V.createSvgDocument = function(content) {\n\n\t        if (content) {\n\t            var XMLString = \"<svg xmlns=\\\"\" + (ns.svg) + \"\\\" xmlns:xlink=\\\"\" + (ns.xlink) + \"\\\" version=\\\"\" + SVGVersion + \"\\\">\" + content + \"</svg>\";\n\t            var ref = V.parseXML(XMLString, { async: false });\n\t            var documentElement = ref.documentElement;\n\t            return documentElement;\n\t        }\n\n\t        var svg = document.createElementNS(ns.svg, 'svg');\n\t        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n\t        svg.setAttribute('version', SVGVersion);\n\t        return svg;\n\t    };\n\n\t    V.createSVGStyle = function(stylesheet) {\n\t        var ref = V('style', { type: 'text/css' }, [\n\t            V.createCDATASection(stylesheet)\n\t        ]);\n\t        var node = ref.node;\n\t        return node;\n\t    },\n\n\t    V.createCDATASection = function(data) {\n\t        if ( data === void 0 ) data = '';\n\n\t        var xml = document.implementation.createDocument(null, 'xml', null);\n\t        return xml.createCDATASection(data);\n\t    };\n\n\t    V.idCounter = 0;\n\n\t    // A function returning a unique identifier for this client session with every call.\n\t    V.uniqueId = function() {\n\n\t        return 'v-' + (++V.idCounter);\n\t    };\n\n\t    V.toNode = function(el) {\n\n\t        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\n\t    };\n\n\t    V.ensureId = function(node) {\n\n\t        node = V.toNode(node);\n\t        return node.id || (node.id = V.uniqueId());\n\t    };\n\n\t    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n\t    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n\t    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n\t    // when you want to compare the actual DOM text content without having to add the unicode character in\n\t    // the place of all spaces.\n\t    V.sanitizeText = function(text) {\n\n\t        return (text || '').replace(/ /g, '\\u00A0');\n\t    };\n\n\t    V.isUndefined = function(value) {\n\n\t        return typeof value === 'undefined';\n\t    };\n\n\t    V.isString = function(value) {\n\n\t        return typeof value === 'string';\n\t    };\n\n\t    V.isObject = function(value) {\n\n\t        return value && (typeof value === 'object');\n\t    };\n\n\t    V.isArray = Array.isArray;\n\n\t    V.parseXML = function(data, opt) {\n\n\t        opt = opt || {};\n\n\t        var xml;\n\n\t        try {\n\t            var parser = new DOMParser();\n\n\t            if (!V.isUndefined(opt.async)) {\n\t                parser.async = opt.async;\n\t            }\n\n\t            xml = parser.parseFromString(data, 'text/xml');\n\t        } catch (error) {\n\t            xml = undefined;\n\t        }\n\n\t        if (!xml || xml.getElementsByTagName('parsererror').length) {\n\t            throw new Error('Invalid XML: ' + data);\n\t        }\n\n\t        return xml;\n\t    };\n\n\t    /**\n\t     * @param {string} name\n\t     * @returns {{ns: string|null, local: string}} namespace and attribute name\n\t     */\n\t    V.qualifyAttr = function(name) {\n\n\t        if (name.indexOf(':') !== -1) {\n\t            var combinedKey = name.split(':');\n\t            return {\n\t                ns: ns[combinedKey[0]],\n\t                local: combinedKey[1]\n\t            };\n\t        }\n\n\t        return {\n\t            ns: null,\n\t            local: name\n\t        };\n\t    };\n\n\t    V.transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi;\n\t    V.transformSeparatorRegex = /[ ,]+/;\n\t    V.transformationListRegex = /^(\\w+)\\((.*)\\)/;\n\n\t    V.transformStringToMatrix = function(transform) {\n\n\t        var transformationMatrix = V.createSVGMatrix();\n\t        var matches = transform && transform.match(V.transformRegex);\n\t        if (!matches) {\n\t            return transformationMatrix;\n\t        }\n\n\t        for (var i = 0, n = matches.length; i < n; i++) {\n\t            var transformationString = matches[i];\n\n\t            var transformationMatch = transformationString.match(V.transformationListRegex);\n\t            if (transformationMatch) {\n\t                var sx, sy, tx, ty, angle;\n\t                var ctm = V.createSVGMatrix();\n\t                var args = transformationMatch[2].split(V.transformSeparatorRegex);\n\t                switch (transformationMatch[1].toLowerCase()) {\n\t                    case 'scale':\n\t                        sx = parseFloat(args[0]);\n\t                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\n\t                        ctm = ctm.scaleNonUniform(sx, sy);\n\t                        break;\n\t                    case 'translate':\n\t                        tx = parseFloat(args[0]);\n\t                        ty = parseFloat(args[1]);\n\t                        ctm = ctm.translate(tx, ty);\n\t                        break;\n\t                    case 'rotate':\n\t                        angle = parseFloat(args[0]);\n\t                        tx = parseFloat(args[1]) || 0;\n\t                        ty = parseFloat(args[2]) || 0;\n\t                        if (tx !== 0 || ty !== 0) {\n\t                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n\t                        } else {\n\t                            ctm = ctm.rotate(angle);\n\t                        }\n\t                        break;\n\t                    case 'skewx':\n\t                        angle = parseFloat(args[0]);\n\t                        ctm = ctm.skewX(angle);\n\t                        break;\n\t                    case 'skewy':\n\t                        angle = parseFloat(args[0]);\n\t                        ctm = ctm.skewY(angle);\n\t                        break;\n\t                    case 'matrix':\n\t                        ctm.a = parseFloat(args[0]);\n\t                        ctm.b = parseFloat(args[1]);\n\t                        ctm.c = parseFloat(args[2]);\n\t                        ctm.d = parseFloat(args[3]);\n\t                        ctm.e = parseFloat(args[4]);\n\t                        ctm.f = parseFloat(args[5]);\n\t                        break;\n\t                    default:\n\t                        continue;\n\t                }\n\n\t                transformationMatrix = transformationMatrix.multiply(ctm);\n\t            }\n\n\t        }\n\t        return transformationMatrix;\n\t    };\n\n\t    V.matrixToTransformString = function(matrix) {\n\t        matrix || (matrix = true);\n\n\t        return 'matrix(' +\n\t            (matrix.a !== undefined ? matrix.a : 1) + ',' +\n\t            (matrix.b !== undefined ? matrix.b : 0) + ',' +\n\t            (matrix.c !== undefined ? matrix.c : 0) + ',' +\n\t            (matrix.d !== undefined ? matrix.d : 1) + ',' +\n\t            (matrix.e !== undefined ? matrix.e : 0) + ',' +\n\t            (matrix.f !== undefined ? matrix.f : 0) +\n\t            ')';\n\t    };\n\n\t    V.parseTransformString = function(transform) {\n\n\t        var translate, rotate, scale;\n\n\t        if (transform) {\n\n\t            var separator = V.transformSeparatorRegex;\n\n\t            // Allow reading transform string with a single matrix\n\t            if (transform.trim().indexOf('matrix') >= 0) {\n\n\t                var matrix = V.transformStringToMatrix(transform);\n\t                var decomposedMatrix = V.decomposeMatrix(matrix);\n\n\t                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n\t                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n\t                rotate = [decomposedMatrix.rotation];\n\n\t                var transformations = [];\n\t                if (translate[0] !== 0 || translate[1] !== 0) {\n\t                    transformations.push('translate(' + translate + ')');\n\t                }\n\t                if (scale[0] !== 1 || scale[1] !== 1) {\n\t                    transformations.push('scale(' + scale + ')');\n\t                }\n\t                if (rotate[0] !== 0) {\n\t                    transformations.push('rotate(' + rotate + ')');\n\t                }\n\t                transform = transformations.join(' ');\n\n\t            } else {\n\n\t                var translateMatch = transform.match(/translate\\((.*?)\\)/);\n\t                if (translateMatch) {\n\t                    translate = translateMatch[1].split(separator);\n\t                }\n\t                var rotateMatch = transform.match(/rotate\\((.*?)\\)/);\n\t                if (rotateMatch) {\n\t                    rotate = rotateMatch[1].split(separator);\n\t                }\n\t                var scaleMatch = transform.match(/scale\\((.*?)\\)/);\n\t                if (scaleMatch) {\n\t                    scale = scaleMatch[1].split(separator);\n\t                }\n\t            }\n\t        }\n\n\t        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\n\n\t        return {\n\t            value: transform,\n\t            translate: {\n\t                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\n\t                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\n\t            },\n\t            rotate: {\n\t                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\n\t                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\n\t                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\n\t            },\n\t            scale: {\n\t                sx: sx,\n\t                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\n\t            }\n\t        };\n\t    };\n\n\t    V.deltaTransformPoint = function(matrix, point) {\n\n\t        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n\t        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n\t        return { x: dx, y: dy };\n\t    };\n\n\t    V.decomposeMatrix = function(matrix) {\n\n\t        // @see https://gist.github.com/2052247\n\n\t        // calculate delta transform point\n\t        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\n\t        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\n\n\t        // calculate skew\n\t        var skewX = ((180 / PI) * atan2(px.y, px.x) - 90);\n\t        var skewY = ((180 / PI) * atan2(py.y, py.x));\n\n\t        return {\n\n\t            translateX: matrix.e,\n\t            translateY: matrix.f,\n\t            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n\t            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n\t            skewX: skewX,\n\t            skewY: skewY,\n\t            rotation: skewX // rotation is the same as skew x\n\t        };\n\t    };\n\n\t    // Return the `scale` transformation from the following equation:\n\t    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t    V.matrixToScale = function(matrix) {\n\n\t        var a, b, c, d;\n\t        if (matrix) {\n\t            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n\t            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n\t            b = matrix.b;\n\t            c = matrix.c;\n\t        } else {\n\t            a = d = 1;\n\t        }\n\t        return {\n\t            sx: b ? sqrt(a * a + b * b) : a,\n\t            sy: c ? sqrt(c * c + d * d) : d\n\t        };\n\t    };\n\n\t    // Return the `rotate` transformation from the following equation:\n\t    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t    V.matrixToRotate = function(matrix) {\n\n\t        var p = { x: 0, y: 1 };\n\t        if (matrix) {\n\t            p = V.deltaTransformPoint(matrix, p);\n\t        }\n\n\t        return {\n\t            angle: normalizeAngle(toDeg(atan2(p.y, p.x)) - 90)\n\t        };\n\t    };\n\n\t    // Return the `translate` transformation from the following equation:\n\t    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\t    V.matrixToTranslate = function(matrix) {\n\n\t        return {\n\t            tx: (matrix && matrix.e) || 0,\n\t            ty: (matrix && matrix.f) || 0\n\t        };\n\t    };\n\n\t    V.isV = function(object) {\n\n\t        return object instanceof V;\n\t    };\n\n\t    // For backwards compatibility:\n\t    V.isVElement = V.isV;\n\n\t    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n\t    V.isSVGGraphicsElement = function(node) {\n\t        if (!node) { return false; }\n\t        node = V.toNode(node);\n\t        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n\t        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n\t    };\n\n\t    var svgDocument = V('svg').node;\n\n\t    V.createSVGMatrix = function(matrix) {\n\n\t        var svgMatrix = svgDocument.createSVGMatrix();\n\t        for (var component in matrix) {\n\t            svgMatrix[component] = matrix[component];\n\t        }\n\n\t        return svgMatrix;\n\t    };\n\n\t    V.createSVGTransform = function(matrix) {\n\n\t        if (!V.isUndefined(matrix)) {\n\n\t            if (!(matrix instanceof SVGMatrix)) {\n\t                matrix = V.createSVGMatrix(matrix);\n\t            }\n\n\t            return svgDocument.createSVGTransformFromMatrix(matrix);\n\t        }\n\n\t        return svgDocument.createSVGTransform();\n\t    };\n\n\t    V.createSVGPoint = function(x, y) {\n\n\t        var p = svgDocument.createSVGPoint();\n\t        p.x = x;\n\t        p.y = y;\n\t        return p;\n\t    };\n\n\t    V.transformRect = function(r, matrix) {\n\n\t        var p = svgDocument.createSVGPoint();\n\n\t        p.x = r.x;\n\t        p.y = r.y;\n\t        var corner1 = p.matrixTransform(matrix);\n\n\t        p.x = r.x + r.width;\n\t        p.y = r.y;\n\t        var corner2 = p.matrixTransform(matrix);\n\n\t        p.x = r.x + r.width;\n\t        p.y = r.y + r.height;\n\t        var corner3 = p.matrixTransform(matrix);\n\n\t        p.x = r.x;\n\t        p.y = r.y + r.height;\n\t        var corner4 = p.matrixTransform(matrix);\n\n\t        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n\t        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n\t        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n\t        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\n\t        return new Rect(minX, minY, maxX - minX, maxY - minY);\n\t    };\n\n\t    V.transformPoint = function(p, matrix) {\n\n\t        return new Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n\t    };\n\n\t    V.transformLine = function(l, matrix) {\n\n\t        return new Line(\n\t            V.transformPoint(l.start, matrix),\n\t            V.transformPoint(l.end, matrix)\n\t        );\n\t    };\n\n\t    V.transformPolyline = function(p, matrix) {\n\n\t        var inPoints = (p instanceof Polyline) ? p.points : p;\n\t        if (!V.isArray(inPoints)) { inPoints = []; }\n\t        var outPoints = [];\n\t        for (var i = 0, n = inPoints.length; i < n; i++) { outPoints[i] = V.transformPoint(inPoints[i], matrix); }\n\t        return new Polyline(outPoints);\n\t    };\n\n\t    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n\t    // an object (`{ fill: 'blue', stroke: 'red' }`).\n\t    V.styleToObject = function(styleString) {\n\t        var ret = {};\n\t        var styles = styleString.split(';');\n\t        for (var i = 0; i < styles.length; i++) {\n\t            var style = styles[i];\n\t            var pair = style.split('=');\n\t            ret[pair[0].trim()] = pair[1].trim();\n\t        }\n\t        return ret;\n\t    };\n\n\t    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n\t    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n\n\t        var svgArcMax = 2 * PI - 1e-6;\n\t        var r0 = innerRadius;\n\t        var r1 = outerRadius;\n\t        var a0 = startAngle;\n\t        var a1 = endAngle;\n\t        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n\t        var df = da < PI ? '0' : '1';\n\t        var c0 = cos(a0);\n\t        var s0 = sin(a0);\n\t        var c1 = cos(a1);\n\t        var s1 = sin(a1);\n\n\t        return (da >= svgArcMax)\n\t            ? (r0\n\t                ? 'M0,' + r1\n\t                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n\t                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n\t                + 'M0,' + r0\n\t                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\n\t                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\n\t                + 'Z'\n\t                : 'M0,' + r1\n\t                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n\t                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n\t                + 'Z')\n\t            : (r0\n\t                ? 'M' + r1 * c0 + ',' + r1 * s0\n\t                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n\t                + 'L' + r0 * c1 + ',' + r0 * s1\n\t                + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\n\t                + 'Z'\n\t                : 'M' + r1 * c0 + ',' + r1 * s0\n\t                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n\t                + 'L0,0'\n\t                + 'Z');\n\t    };\n\n\t    // Merge attributes from object `b` with attributes in object `a`.\n\t    // Note that this modifies the object `a`.\n\t    // Also important to note that attributes are merged but CSS classes are concatenated.\n\t    V.mergeAttrs = function(a, b) {\n\n\t        for (var attr in b) {\n\n\t            if (attr === 'class') {\n\t                // Concatenate classes.\n\t                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n\t            } else if (attr === 'style') {\n\t                // `style` attribute can be an object.\n\t                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n\t                    // `style` stored in `a` is an object.\n\t                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n\t                } else if (V.isObject(a[attr])) {\n\t                    // `style` in `a` is an object but it's a string in `b`.\n\t                    // Convert the style represented as a string to an object in `b`.\n\t                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n\t                } else if (V.isObject(b[attr])) {\n\t                    // `style` in `a` is a string, in `b` it's an object.\n\t                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n\t                } else {\n\t                    // Both styles are strings.\n\t                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n\t                }\n\t            } else {\n\t                a[attr] = b[attr];\n\t            }\n\t        }\n\n\t        return a;\n\t    };\n\n\t    V.annotateString = function(t, annotations, opt) {\n\n\t        annotations = annotations || [];\n\t        opt = opt || {};\n\n\t        var offset = opt.offset || 0;\n\t        var compacted = [];\n\t        var batch;\n\t        var ret = [];\n\t        var item;\n\t        var prev;\n\n\t        for (var i = 0; i < t.length; i++) {\n\n\t            item = ret[i] = t[i];\n\n\t            for (var j = 0; j < annotations.length; j++) {\n\n\t                var annotation = annotations[j];\n\t                var start = annotation.start + offset;\n\t                var end = annotation.end + offset;\n\n\t                if (i >= start && i < end) {\n\t                    // Annotation applies.\n\t                    if (V.isObject(item)) {\n\t                        // There is more than one annotation to be applied => Merge attributes.\n\t                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n\t                    } else {\n\t                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\n\t                    }\n\t                    if (opt.includeAnnotationIndices) {\n\t                        (item.annotations || (item.annotations = [])).push(j);\n\t                    }\n\t                }\n\t            }\n\n\t            prev = ret[i - 1];\n\n\t            if (!prev) {\n\n\t                batch = item;\n\n\t            } else if (V.isObject(item) && V.isObject(prev)) {\n\t                // Both previous item and the current one are annotations. If the attributes\n\t                // didn't change, merge the text.\n\t                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n\t                    batch.t += item.t;\n\t                } else {\n\t                    compacted.push(batch);\n\t                    batch = item;\n\t                }\n\n\t            } else if (V.isObject(item)) {\n\t                // Previous item was a string, current item is an annotation.\n\t                compacted.push(batch);\n\t                batch = item;\n\n\t            } else if (V.isObject(prev)) {\n\t                // Previous item was an annotation, current item is a string.\n\t                compacted.push(batch);\n\t                batch = item;\n\n\t            } else {\n\t                // Both previous and current item are strings.\n\t                batch = (batch || '') + item;\n\t            }\n\t        }\n\n\t        if (batch) {\n\t            compacted.push(batch);\n\t        }\n\n\t        return compacted;\n\t    };\n\n\t    V.findAnnotationsAtIndex = function(annotations, index) {\n\n\t        var found = [];\n\n\t        if (annotations) {\n\n\t            annotations.forEach(function(annotation) {\n\n\t                if (annotation.start < index && index <= annotation.end) {\n\t                    found.push(annotation);\n\t                }\n\t            });\n\t        }\n\n\t        return found;\n\t    };\n\n\t    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n\n\t        var found = [];\n\n\t        if (annotations) {\n\n\t            annotations.forEach(function(annotation) {\n\n\t                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\n\t                    found.push(annotation);\n\t                }\n\t            });\n\t        }\n\n\t        return found;\n\t    };\n\n\t    // Shift all the text annotations after character `index` by `offset` positions.\n\t    V.shiftAnnotations = function(annotations, index, offset) {\n\n\t        if (annotations) {\n\n\t            annotations.forEach(function(annotation) {\n\n\t                if (annotation.start < index && annotation.end >= index) {\n\t                    annotation.end += offset;\n\t                } else if (annotation.start >= index) {\n\t                    annotation.start += offset;\n\t                    annotation.end += offset;\n\t                }\n\t            });\n\t        }\n\n\t        return annotations;\n\t    };\n\n\t    V.convertLineToPathData = function(line) {\n\n\t        line = V(line);\n\t        var d = [\n\t            'M', line.attr('x1'), line.attr('y1'),\n\t            'L', line.attr('x2'), line.attr('y2')\n\t        ].join(' ');\n\t        return d;\n\t    };\n\n\t    V.convertPolygonToPathData = function(polygon) {\n\n\t        var points = V.getPointsFromSvgNode(polygon);\n\t        if (points.length === 0) { return null; }\n\n\t        return V.svgPointsToPath(points) + ' Z';\n\t    };\n\n\t    V.convertPolylineToPathData = function(polyline) {\n\n\t        var points = V.getPointsFromSvgNode(polyline);\n\t        if (points.length === 0) { return null; }\n\n\t        return V.svgPointsToPath(points);\n\t    };\n\n\t    V.svgPointsToPath = function(points) {\n\n\t        for (var i = 0, n = points.length; i < n; i++) {\n\t            points[i] = points[i].x + ' ' + points[i].y;\n\t        }\n\n\t        return 'M ' + points.join(' L');\n\t    };\n\n\t    V.getPointsFromSvgNode = function(node) {\n\n\t        node = V.toNode(node);\n\t        var points = [];\n\t        var nodePoints = node.points;\n\t        if (nodePoints) {\n\t            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n\t                points.push(nodePoints.getItem(i));\n\t            }\n\t        }\n\n\t        return points;\n\t    };\n\n\t    V.KAPPA = 0.551784;\n\n\t    V.convertCircleToPathData = function(circle) {\n\n\t        circle = V(circle);\n\t        var cx = parseFloat(circle.attr('cx')) || 0;\n\t        var cy = parseFloat(circle.attr('cy')) || 0;\n\t        var r = parseFloat(circle.attr('r'));\n\t        var cd = r * V.KAPPA; // Control distance.\n\n\t        var d = [\n\t            'M', cx, cy - r,    // Move to the first point.\n\t            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n\t            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n\t            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n\t            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n\t            'Z'\n\t        ].join(' ');\n\t        return d;\n\t    };\n\n\t    V.convertEllipseToPathData = function(ellipse) {\n\n\t        ellipse = V(ellipse);\n\t        var cx = parseFloat(ellipse.attr('cx')) || 0;\n\t        var cy = parseFloat(ellipse.attr('cy')) || 0;\n\t        var rx = parseFloat(ellipse.attr('rx'));\n\t        var ry = parseFloat(ellipse.attr('ry')) || rx;\n\t        var cdx = rx * V.KAPPA; // Control distance x.\n\t        var cdy = ry * V.KAPPA; // Control distance y.\n\n\t        var d = [\n\t            'M', cx, cy - ry,    // Move to the first point.\n\t            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n\t            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n\t            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n\t            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n\t            'Z'\n\t        ].join(' ');\n\t        return d;\n\t    };\n\n\t    V.convertRectToPathData = function(rect) {\n\n\t        rect = V(rect);\n\n\t        return V.rectToPath({\n\t            x: parseFloat(rect.attr('x')) || 0,\n\t            y: parseFloat(rect.attr('y')) || 0,\n\t            width: parseFloat(rect.attr('width')) || 0,\n\t            height: parseFloat(rect.attr('height')) || 0,\n\t            rx: parseFloat(rect.attr('rx')) || 0,\n\t            ry: parseFloat(rect.attr('ry')) || 0\n\t        });\n\t    };\n\n\t    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n\t    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n\t    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n\t    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n\t    // that has only `rx` and `ry` attributes).\n\t    V.rectToPath = function(r) {\n\n\t        var d;\n\t        var x = r.x;\n\t        var y = r.y;\n\t        var width = r.width;\n\t        var height = r.height;\n\t        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n\t        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n\t        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n\t        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n\t        if (topRx || bottomRx || topRy || bottomRy) {\n\t            d = [\n\t                'M', x, y + topRy,\n\t                'v', height - topRy - bottomRy,\n\t                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\n\t                'h', width - 2 * bottomRx,\n\t                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\n\t                'v', -(height - bottomRy - topRy),\n\t                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\n\t                'h', -(width - 2 * topRx),\n\t                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\n\t                'Z'\n\t            ];\n\t        } else {\n\t            d = [\n\t                'M', x, y,\n\t                'H', x + width,\n\t                'V', y + height,\n\t                'H', x,\n\t                'V', y,\n\t                'Z'\n\t            ];\n\t        }\n\n\t        return d.join(' ');\n\t    };\n\n\t    // Take a path data string\n\t    // Return a normalized path data string\n\t    // If data cannot be parsed, return 'M 0 0'\n\t    // Adapted from Rappid normalizePath polyfill\n\t    // Highly inspired by Raphael Library (www.raphael.com)\n\t    V.normalizePathData = (function() {\n\n\t        var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n\t        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n\t        var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\n\t        var math = Math;\n\t        var PI = math.PI;\n\t        var sin = math.sin;\n\t        var cos = math.cos;\n\t        var tan = math.tan;\n\t        var asin = math.asin;\n\t        var sqrt = math.sqrt;\n\t        var abs = math.abs;\n\n\t        function q2c(x1, y1, ax, ay, x2, y2) {\n\n\t            var _13 = 1 / 3;\n\t            var _23 = 2 / 3;\n\t            return [(_13 * x1) + (_23 * ax), (_13 * y1) + (_23 * ay), (_13 * x2) + (_23 * ax), (_13 * y2) + (_23 * ay), x2, y2];\n\t        }\n\n\t        function rotate(x, y, rad) {\n\n\t            var X = (x * cos(rad)) - (y * sin(rad));\n\t            var Y = (x * sin(rad)) + (y * cos(rad));\n\t            return { x: X, y: Y };\n\t        }\n\n\t        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t            // for more information of where this math came from visit:\n\t            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t            var _120 = (PI * 120) / 180;\n\t            var rad = (PI / 180) * (+angle || 0);\n\t            var res = [];\n\t            var xy;\n\n\t            if (!recursive) {\n\t                xy = rotate(x1, y1, -rad);\n\t                x1 = xy.x;\n\t                y1 = xy.y;\n\n\t                xy = rotate(x2, y2, -rad);\n\t                x2 = xy.x;\n\t                y2 = xy.y;\n\n\t                var x = (x1 - x2) / 2;\n\t                var y = (y1 - y2) / 2;\n\t                var h = ((x * x) / (rx * rx)) + ((y * y) / (ry * ry));\n\n\t                if (h > 1) {\n\t                    h = sqrt(h);\n\t                    rx = h * rx;\n\t                    ry = h * ry;\n\t                }\n\n\t                var rx2 = rx * rx;\n\t                var ry2 = ry * ry;\n\n\t                var k = ((large_arc_flag == sweep_flag) ? -1 : 1) * sqrt(abs(((rx2 * ry2) - (rx2 * y * y) - (ry2 * x * x)) / ((rx2 * y * y) + (ry2 * x * x))));\n\n\t                var cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n\t                var cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n\n\t                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n\t                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\n\t                f1 = ((x1 < cx) ? (PI - f1) : f1);\n\t                f2 = ((x2 < cx) ? (PI - f2) : f2);\n\n\t                if (f1 < 0) { f1 = (PI * 2) + f1; }\n\t                if (f2 < 0) { f2 = (PI * 2) + f2; }\n\n\t                if (sweep_flag && (f1 > f2)) { f1 = f1 - (PI * 2); }\n\t                if (!sweep_flag && (f2 > f1)) { f2 = f2 - (PI * 2); }\n\n\t            } else {\n\t                f1 = recursive[0];\n\t                f2 = recursive[1];\n\t                cx = recursive[2];\n\t                cy = recursive[3];\n\t            }\n\n\t            var df = f2 - f1;\n\t            if (abs(df) > _120) {\n\t                var f2old = f2;\n\t                var x2old = x2;\n\t                var y2old = y2;\n\t                f2 = f1 + (_120 * ((sweep_flag && (f2 > f1)) ? 1 : -1));\n\t                x2 = cx + (rx * cos(f2));\n\t                y2 = cy + (ry * sin(f2));\n\t                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t            }\n\n\t            df = f2 - f1;\n\n\t            var c1 = cos(f1);\n\t            var s1 = sin(f1);\n\t            var c2 = cos(f2);\n\t            var s2 = sin(f2);\n\t            var t = tan(df / 4);\n\t            var hx = (4 / 3) * (rx * t);\n\t            var hy = (4 / 3) * (ry * t);\n\t            var m1 = [x1, y1];\n\t            var m2 = [x1 + (hx * s1), y1 - (hy * c1)];\n\t            var m3 = [x2 + (hx * s2), y2 - (hy * c2)];\n\t            var m4 = [x2, y2];\n\n\t            m2[0] = (2 * m1[0]) - m2[0];\n\t            m2[1] = (2 * m1[1]) - m2[1];\n\n\t            if (recursive) {\n\t                return [m2, m3, m4].concat(res);\n\t            } else {\n\t                res = [m2, m3, m4].concat(res).join().split(',');\n\t                var newres = [];\n\t                var ii = res.length;\n\t                for (var i = 0; i < ii; i++) {\n\t                    newres[i] = (i % 2) ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t                }\n\t                return newres;\n\t            }\n\t        }\n\n\t        function parsePathString(pathString) {\n\n\t            if (!pathString) { return null; }\n\n\t            var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\t            var data = [];\n\n\t            String(pathString).replace(pathCommand, function(a, b, c) {\n\n\t                var params = [];\n\t                var name = b.toLowerCase();\n\t                c.replace(pathValues, function(a, b) {\n\t                    if (b) { params.push(+b); }\n\t                });\n\n\t                if ((name === 'm') && (params.length > 2)) {\n\t                    data.push([b].concat(params.splice(0, 2)));\n\t                    name = 'l';\n\t                    b = ((b === 'm') ? 'l' : 'L');\n\t                }\n\n\t                while (params.length >= paramCounts[name]) {\n\t                    data.push([b].concat(params.splice(0, paramCounts[name])));\n\t                    if (!paramCounts[name]) { break; }\n\t                }\n\t            });\n\n\t            return data;\n\t        }\n\n\t        function pathToAbsolute(pathArray) {\n\n\t            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) { // rough assumption\n\t                pathArray = parsePathString(pathArray);\n\t            }\n\n\t            // if invalid string, return 'M 0 0'\n\t            if (!pathArray || !pathArray.length) { return [['M', 0, 0]]; }\n\n\t            var res = [];\n\t            var x = 0;\n\t            var y = 0;\n\t            var mx = 0;\n\t            var my = 0;\n\t            var start = 0;\n\t            var pa0;\n\n\t            var ii = pathArray.length;\n\t            for (var i = start; i < ii; i++) {\n\n\t                var r = [];\n\t                res.push(r);\n\n\t                var pa = pathArray[i];\n\t                pa0 = pa[0];\n\n\t                if (pa0 != pa0.toUpperCase()) {\n\t                    r[0] = pa0.toUpperCase();\n\n\t                    var jj;\n\t                    var j;\n\t                    switch (r[0]) {\n\t                        case 'A':\n\t                            r[1] = pa[1];\n\t                            r[2] = pa[2];\n\t                            r[3] = pa[3];\n\t                            r[4] = pa[4];\n\t                            r[5] = pa[5];\n\t                            r[6] = +pa[6] + x;\n\t                            r[7] = +pa[7] + y;\n\t                            break;\n\n\t                        case 'V':\n\t                            r[1] = +pa[1] + y;\n\t                            break;\n\n\t                        case 'H':\n\t                            r[1] = +pa[1] + x;\n\t                            break;\n\n\t                        case 'M':\n\t                            mx = +pa[1] + x;\n\t                            my = +pa[2] + y;\n\n\t                            jj = pa.length;\n\t                            for (j = 1; j < jj; j++) {\n\t                                r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                            }\n\t                            break;\n\n\t                        default:\n\t                            jj = pa.length;\n\t                            for (j = 1; j < jj; j++) {\n\t                                r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                            }\n\t                            break;\n\t                    }\n\t                } else {\n\t                    var kk = pa.length;\n\t                    for (var k = 0; k < kk; k++) {\n\t                        r[k] = pa[k];\n\t                    }\n\t                }\n\n\t                switch (r[0]) {\n\t                    case 'Z':\n\t                        x = +mx;\n\t                        y = +my;\n\t                        break;\n\n\t                    case 'H':\n\t                        x = r[1];\n\t                        break;\n\n\t                    case 'V':\n\t                        y = r[1];\n\t                        break;\n\n\t                    case 'M':\n\t                        mx = r[r.length - 2];\n\t                        my = r[r.length - 1];\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                        break;\n\n\t                    default:\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                        break;\n\t                }\n\t            }\n\n\t            return res;\n\t        }\n\n\t        function normalize(path) {\n\n\t            var p = pathToAbsolute(path);\n\t            var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };\n\n\t            function processPath(path, d, pcom) {\n\n\t                var nx, ny;\n\n\t                if (!path) { return ['C', d.x, d.y, d.x, d.y, d.x, d.y]; }\n\n\t                if (!(path[0] in { T: 1, Q: 1 })) {\n\t                    d.qx = null;\n\t                    d.qy = null;\n\t                }\n\n\t                switch (path[0]) {\n\t                    case 'M':\n\t                        d.X = path[1];\n\t                        d.Y = path[2];\n\t                        break;\n\n\t                    case 'A':\n\t                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n\t                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n\t                            // \"If either rx or ry is 0, then this arc is treated as a\n\t                            // straight line segment (a \"lineto\") joining the endpoints.\"\n\t                            path = ['L', path[6], path[7]];\n\t                        } else {\n\t                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n\t                        }\n\t                        break;\n\n\t                    case 'S':\n\t                        if (pcom === 'C' || pcom === 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\n\t                            nx = (d.x * 2) - d.bx;          // And reflect the previous\n\t                            ny = (d.y * 2) - d.by;          // command's control point relative to the current point.\n\t                        } else {                            // or some else or nothing\n\t                            nx = d.x;\n\t                            ny = d.y;\n\t                        }\n\t                        path = ['C', nx, ny].concat(path.slice(1));\n\t                        break;\n\n\t                    case 'T':\n\t                        if (pcom === 'Q' || pcom === 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\n\t                            d.qx = (d.x * 2) - d.qx;        // And make a reflection similar\n\t                            d.qy = (d.y * 2) - d.qy;        // to case 'S'.\n\t                        } else {                            // or something else or nothing\n\t                            d.qx = d.x;\n\t                            d.qy = d.y;\n\t                        }\n\t                        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t                        break;\n\n\t                    case 'Q':\n\t                        d.qx = path[1];\n\t                        d.qy = path[2];\n\t                        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t                        break;\n\n\t                    case 'H':\n\t                        path = ['L'].concat(path[1], d.y);\n\t                        break;\n\n\t                    case 'V':\n\t                        path = ['L'].concat(d.x, path[1]);\n\t                        break;\n\n\t                    case 'L':\n\t                        break;\n\n\t                    case 'Z':\n\t                        break;\n\t                }\n\n\t                return path;\n\t            }\n\n\t            function fixArc(pp, i) {\n\n\t                if (pp[i].length > 7) {\n\n\t                    pp[i].shift();\n\t                    var pi = pp[i];\n\n\t                    while (pi.length) {\n\t                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n\t                        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n\t                    }\n\n\t                    pp.splice(i, 1);\n\t                    ii = p.length;\n\t                }\n\t            }\n\n\t            var pcoms = []; // path commands of original path p\n\t            var pfirst = ''; // temporary holder for original path command\n\t            var pcom = ''; // holder for previous path command of original path\n\n\t            var ii = p.length;\n\t            for (var i = 0; i < ii; i++) {\n\t                if (p[i]) { pfirst = p[i][0]; } // save current path command\n\n\t                if (pfirst !== 'C') { // C is not saved yet, because it may be result of conversion\n\t                    pcoms[i] = pfirst; // Save current path command\n\t                    if (i > 0) { pcom = pcoms[i - 1]; } // Get previous path command pcom\n\t                }\n\n\t                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n\t                if (pcoms[i] !== 'A' && pfirst === 'C') { pcoms[i] = 'C'; } // 'A' is the only command\n\t                // which may produce multiple 'C's\n\t                // so we have to make sure that 'C' is also 'C' in original path\n\n\t                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n\t                var seg = p[i];\n\t                var seglen = seg.length;\n\n\t                attrs.x = seg[seglen - 2];\n\t                attrs.y = seg[seglen - 1];\n\n\t                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n\t                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n\t            }\n\n\t            // make sure normalized path data string starts with an M segment\n\t            if (!p[0][0] || p[0][0] !== 'M') {\n\t                p.unshift(['M', 0, 0]);\n\t            }\n\n\t            return p;\n\t        }\n\n\t        return function(pathData) {\n\t            return normalize(pathData).join(',').split(',').join(' ');\n\t        };\n\t    })();\n\n\t    V.namespace = ns;\n\n\t    V.g = g;\n\n\t    return V;\n\n\t})();\n\n\tvar config = {\n\t    // When set to `true` the cell selectors could be defined as CSS selectors.\n\t    // If not, only JSON Markup selectors are taken into account.\n\t    // export let useCSSSelectors = true;\n\t    useCSSSelectors: true,\n\t    // The class name prefix config is for advanced use only.\n\t    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n\t    // export let classNamePrefix = 'joint-';\n\t    // export let defaultTheme = 'default';\n\t    classNamePrefix: 'joint-',\n\t    defaultTheme: 'default'\n\t};\n\n\tvar addClassNamePrefix = function(className) {\n\n\t    if (!className) { return className; }\n\n\t    return className.toString().split(' ').map(function(_className) {\n\n\t        if (_className.substr(0, config.classNamePrefix.length) !== config.classNamePrefix) {\n\t            _className = config.classNamePrefix + _className;\n\t        }\n\n\t        return _className;\n\n\t    }).join(' ');\n\t};\n\n\tvar removeClassNamePrefix = function(className) {\n\n\t    if (!className) { return className; }\n\n\t    return className.toString().split(' ').map(function(_className) {\n\n\t        if (_className.substr(0, config.classNamePrefix.length) === config.classNamePrefix) {\n\t            _className = _className.substr(config.classNamePrefix.length);\n\t        }\n\n\t        return _className;\n\n\t    }).join(' ');\n\t};\n\n\tvar parseDOMJSON = function(json, namespace) {\n\n\t    var selectors = {};\n\t    var groupSelectors = {};\n\t    var svgNamespace = V.namespace.svg;\n\n\t    var ns = namespace || svgNamespace;\n\t    var fragment = document.createDocumentFragment();\n\t    var queue = [json, fragment, ns];\n\t    while (queue.length > 0) {\n\t        ns = queue.pop();\n\t        var parentNode = queue.pop();\n\t        var siblingsDef = queue.pop();\n\t        for (var i = 0, n = siblingsDef.length; i < n; i++) {\n\t            var nodeDef = siblingsDef[i];\n\t            // TagName\n\t            if (!nodeDef.hasOwnProperty('tagName')) { throw new Error('json-dom-parser: missing tagName'); }\n\t            var tagName = nodeDef.tagName;\n\t            // Namespace URI\n\t            if (nodeDef.hasOwnProperty('namespaceURI')) { ns = nodeDef.namespaceURI; }\n\t            var node = document.createElementNS(ns, tagName);\n\t            var svg = (ns === svgNamespace);\n\n\t            var wrapper = (svg) ? V : $;\n\t            // Attributes\n\t            var attributes = nodeDef.attributes;\n\t            if (attributes) { wrapper(node).attr(attributes); }\n\t            // Style\n\t            var style = nodeDef.style;\n\t            if (style) { $(node).css(style); }\n\t            // ClassName\n\t            if (nodeDef.hasOwnProperty('className')) {\n\t                var className = nodeDef.className;\n\t                if (svg) {\n\t                    node.className.baseVal = className;\n\t                } else {\n\t                    node.className = className;\n\t                }\n\t            }\n\t            // TextContent\n\t            if (nodeDef.hasOwnProperty('textContent')) {\n\t                node.textContent = nodeDef.textContent;\n\t            }\n\t            // Selector\n\t            if (nodeDef.hasOwnProperty('selector')) {\n\t                var nodeSelector = nodeDef.selector;\n\t                if (selectors[nodeSelector]) { throw new Error('json-dom-parser: selector must be unique'); }\n\t                selectors[nodeSelector] = node;\n\t                wrapper(node).attr('joint-selector', nodeSelector);\n\t            }\n\t            // Groups\n\t            if (nodeDef.hasOwnProperty('groupSelector')) {\n\t                var nodeGroups = nodeDef.groupSelector;\n\t                if (!Array.isArray(nodeGroups)) { nodeGroups = [nodeGroups]; }\n\t                for (var j = 0, m = nodeGroups.length; j < m; j++) {\n\t                    var nodeGroup = nodeGroups[j];\n\t                    var group = groupSelectors[nodeGroup];\n\t                    if (!group) { group = groupSelectors[nodeGroup] = []; }\n\t                    group.push(node);\n\t                }\n\t            }\n\t            parentNode.appendChild(node);\n\t            // Children\n\t            var childrenDef = nodeDef.children;\n\t            if (Array.isArray(childrenDef)) { queue.push(childrenDef, node, ns); }\n\t        }\n\t    }\n\t    return {\n\t        fragment: fragment,\n\t        selectors: selectors,\n\t        groupSelectors: groupSelectors\n\t    };\n\t};\n\n\t// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\n\tvar hashCode = function(str) {\n\n\t    var hash = 0;\n\t    if (str.length === 0) { return hash; }\n\t    for (var i = 0; i < str.length; i++) {\n\t        var c = str.charCodeAt(i);\n\t        hash = ((hash << 5) - hash) + c;\n\t        hash = hash & hash; // Convert to 32bit integer\n\t    }\n\t    return hash;\n\t};\n\n\tvar getByPath = function(obj, path, delimiter) {\n\n\t    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t    var key;\n\t    var i = 0;\n\t    var length = keys.length;\n\t    while (i < length) {\n\t        key = keys[i++];\n\t        if (Object(obj) === obj && key in obj) {\n\t            obj = obj[key];\n\t        } else {\n\t            return undefined;\n\t        }\n\t    }\n\t    return obj;\n\t};\n\n\tvar isGetSafe = function(obj, key) {\n\t    // Prevent prototype pollution\n\t    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n\t    if (key === 'constructor' && typeof obj[key] === 'function') {\n\t        return false;\n\t    }\n\t    if (key === '__proto__') {\n\t        return false;\n\t    }\n\t    return true;\n\t};\n\n\tvar setByPath = function(obj, path, value, delimiter) {\n\n\t    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t    var last = keys.length - 1;\n\t    var diver = obj;\n\t    var i = 0;\n\n\t    for (; i < last; i++) {\n\t        var key = keys[i];\n\t        if (!isGetSafe(diver, key)) { return obj; }\n\t        var value$1 = diver[key];\n\t        // diver creates an empty object if there is no nested object under such a key.\n\t        // This means that one can populate an empty nested object with setByPath().\n\t        diver = value$1 || (diver[key] = {});\n\t    }\n\n\t    diver[keys[last]] = value;\n\n\t    return obj;\n\t};\n\n\tvar unsetByPath = function(obj, path, delimiter) {\n\n\t    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n\t    var last = keys.length - 1;\n\t    var diver = obj;\n\t    var i = 0;\n\n\t    for (; i < last; i++) {\n\t        var key = keys[i];\n\t        if (!isGetSafe(diver, key)) { return obj; }\n\t        var value = diver[key];\n\t        if (!value) { return obj; }\n\t        diver = value;\n\t    }\n\n\t    delete diver[keys[last]];\n\n\t    return obj;\n\t};\n\n\tvar flattenObject = function(obj, delim, stop) {\n\n\t    delim = delim || '/';\n\t    var ret = {};\n\n\t    for (var key in obj) {\n\n\t        if (!obj.hasOwnProperty(key)) { continue; }\n\n\t        var shouldGoDeeper = typeof obj[key] === 'object';\n\t        if (shouldGoDeeper && stop && stop(obj[key])) {\n\t            shouldGoDeeper = false;\n\t        }\n\n\t        if (shouldGoDeeper) {\n\n\t            var flatObject = flattenObject(obj[key], delim, stop);\n\n\t            for (var flatKey in flatObject) {\n\t                if (!flatObject.hasOwnProperty(flatKey)) { continue; }\n\t                ret[key + delim + flatKey] = flatObject[flatKey];\n\t            }\n\n\t        } else {\n\n\t            ret[key] = obj[key];\n\t        }\n\t    }\n\n\t    return ret;\n\t};\n\n\tvar uuid = function() {\n\n\t    // credit: http://stackoverflow.com/posts/2117523/revisions\n\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t        var r = (Math.random() * 16) | 0;\n\t        var v = (c === 'x') ? r : (r & 0x3 | 0x8);\n\t        return v.toString(16);\n\t    });\n\t};\n\n\t// Generate global unique id for obj and store it as a property of the object.\n\tvar guid = function(obj) {\n\n\t    guid.id = guid.id || 1;\n\t    obj.id = (obj.id === undefined ? 'j_' + guid.id++ : obj.id);\n\t    return obj.id;\n\t};\n\n\tvar toKebabCase = function(string) {\n\n\t    return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n\t};\n\n\tvar normalizeEvent = function(evt) {\n\n\t    var normalizedEvent = evt;\n\t    var touchEvt = evt.originalEvent && evt.originalEvent.changedTouches && evt.originalEvent.changedTouches[0];\n\t    if (touchEvt) {\n\t        for (var property in evt) {\n\t            // copy all the properties from the input event that are not\n\t            // defined on the touch event (functions included).\n\t            if (touchEvt[property] === undefined) {\n\t                touchEvt[property] = evt[property];\n\t            }\n\t        }\n\t        normalizedEvent = touchEvt;\n\t    }\n\n\t    // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n\t    var target = normalizedEvent.target;\n\t    if (target) {\n\t        var useElement = target.correspondingUseElement;\n\t        if (useElement) { normalizedEvent.target = useElement; }\n\t    }\n\n\t    return normalizedEvent;\n\t};\n\n\tvar nextFrame = (function() {\n\n\t    var raf;\n\n\t    if (typeof window !== 'undefined') {\n\n\t        raf = window.requestAnimationFrame ||\n\t            window.webkitRequestAnimationFrame ||\n\t            window.mozRequestAnimationFrame ||\n\t            window.oRequestAnimationFrame ||\n\t            window.msRequestAnimationFrame;\n\t    }\n\n\t    if (!raf) {\n\n\t        var lastTime = 0;\n\n\t        raf = function(callback) {\n\n\t            var currTime = new Date().getTime();\n\t            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t            var id = setTimeout(function() {\n\t                callback(currTime + timeToCall);\n\t            }, timeToCall);\n\n\t            lastTime = currTime + timeToCall;\n\n\t            return id;\n\t        };\n\t    }\n\n\t    return function(callback, context) {\n\t        var rest = [], len = arguments.length - 2;\n\t        while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];\n\n\t        return (context !== undefined)\n\t            ? raf(callback.bind.apply(callback, [ context ].concat( rest )))\n\t            : raf(callback);\n\t    };\n\n\t})();\n\n\tvar cancelFrame = (function() {\n\n\t    var caf;\n\t    var client = typeof window != 'undefined';\n\n\t    if (client) {\n\n\t        caf = window.cancelAnimationFrame ||\n\t            window.webkitCancelAnimationFrame ||\n\t            window.webkitCancelRequestAnimationFrame ||\n\t            window.msCancelAnimationFrame ||\n\t            window.msCancelRequestAnimationFrame ||\n\t            window.oCancelAnimationFrame ||\n\t            window.oCancelRequestAnimationFrame ||\n\t            window.mozCancelAnimationFrame ||\n\t            window.mozCancelRequestAnimationFrame;\n\t    }\n\n\t    caf = caf || clearTimeout;\n\n\t    return client ? caf.bind(window) : caf;\n\n\t})();\n\n\t/**\n\t * @deprecated\n\t */\n\tvar shapePerimeterConnectionPoint = function(linkView, view, magnet, reference) {\n\n\t    var bbox;\n\t    var spot;\n\n\t    if (!magnet) {\n\n\t        // There is no magnet, try to make the best guess what is the\n\t        // wrapping SVG element. This is because we want this \"smart\"\n\t        // connection points to work out of the box without the\n\t        // programmer to put magnet marks to any of the subelements.\n\t        // For example, we want the function to work on basic.Path elements\n\t        // without any special treatment of such elements.\n\t        // The code below guesses the wrapping element based on\n\t        // one simple assumption. The wrapping elemnet is the\n\t        // first child of the scalable group if such a group exists\n\t        // or the first child of the rotatable group if not.\n\t        // This makese sense because usually the wrapping element\n\t        // is below any other sub element in the shapes.\n\t        var scalable = view.$('.scalable')[0];\n\t        var rotatable = view.$('.rotatable')[0];\n\n\t        if (scalable && scalable.firstChild) {\n\n\t            magnet = scalable.firstChild;\n\n\t        } else if (rotatable && rotatable.firstChild) {\n\n\t            magnet = rotatable.firstChild;\n\t        }\n\t    }\n\n\t    if (magnet) {\n\n\t        spot = V(magnet).findIntersection(reference, linkView.paper.cells);\n\t        if (!spot) {\n\t            bbox = V(magnet).getBBox({ target: linkView.paper.cells });\n\t        }\n\n\t    } else {\n\n\t        bbox = view.model.getBBox();\n\t        spot = bbox.intersectionWithLineFromCenterToPoint(reference);\n\t    }\n\t    return spot || bbox.center();\n\t};\n\n\tvar isPercentage = function(val) {\n\n\t    return isString(val) && val.slice(-1) === '%';\n\t};\n\n\tvar parseCssNumeric = function(val, restrictUnits) {\n\n\t    function getUnit(validUnitExp) {\n\n\t        // one or more numbers, followed by\n\t        // any number of (\n\t        //  `.`, followed by\n\t        //  one or more numbers\n\t        // ), followed by\n\t        // `validUnitExp`, followed by\n\t        // end of string\n\t        var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\n\t        if (!matches) { return null; }\n\t        return matches[1];\n\t    }\n\n\t    var number = parseFloat(val);\n\n\t    // if `val` cannot be parsed as a number, return `null`\n\t    if (Number.isNaN(number)) { return null; }\n\n\t    // else: we know `output.value`\n\t    var output = {};\n\t    output.value = number;\n\n\t    // determine the unit\n\t    var validUnitExp;\n\t    if (restrictUnits == null) {\n\t        // no restriction\n\t        // accept any unit, as well as no unit\n\t        validUnitExp = '[A-Za-z]*';\n\n\t    } else if (Array.isArray(restrictUnits)) {\n\t        // if this is an empty array, top restriction - return `null`\n\t        if (restrictUnits.length === 0) { return null; }\n\n\t        // else: restriction - an array of valid unit strings\n\t        validUnitExp = restrictUnits.join('|');\n\n\t    } else if (isString(restrictUnits)) {\n\t        // restriction - a single valid unit string\n\t        validUnitExp = restrictUnits;\n\t    }\n\t    var unit = getUnit(validUnitExp);\n\n\t    // if we found no matches for `restrictUnits`, return `null`\n\t    if (unit === null) { return null; }\n\n\t    // else: we know the unit\n\t    output.unit = unit;\n\t    return output;\n\t};\n\n\tvar breakText = function(text, size, styles, opt) {\n\t    if ( styles === void 0 ) styles = {};\n\t    if ( opt === void 0 ) opt = {};\n\n\n\t    var width = size.width;\n\t    var height = size.height;\n\n\t    var svgDocument = opt.svgDocument || V('svg').node;\n\t    var textSpan = V('tspan').node;\n\t    var textElement = V('text').attr(styles).append(textSpan).node;\n\t    var textNode = document.createTextNode('');\n\n\t    // Prevent flickering\n\t    textElement.style.opacity = 0;\n\t    // Prevent FF from throwing an uncaught exception when `getBBox()`\n\t    // called on element that is not in the render tree (is not measurable).\n\t    // <tspan>.getComputedTextLength() returns always 0 in this case.\n\t    // Note that the `textElement` resp. `textSpan` can become hidden\n\t    // when it's appended to the DOM and a `display: none` CSS stylesheet\n\t    // rule gets applied.\n\t    textElement.style.display = 'block';\n\t    textSpan.style.display = 'block';\n\n\t    textSpan.appendChild(textNode);\n\t    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n\t    if (!opt.svgDocument) {\n\n\t        document.body.appendChild(svgDocument);\n\t    }\n\n\t    var separator = opt.separator || ' ';\n\t    var eol = opt.eol || '\\n';\n\t    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d]/;\n\t    var maxLineCount = opt.maxLineCount;\n\t    if (!isNumber(maxLineCount)) { maxLineCount = Infinity; }\n\n\t    var words = text.split(separator);\n\t    var full = [];\n\t    var lines = [];\n\t    var p, h;\n\t    var lineHeight;\n\n\t    for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\n\t        var word = words[i];\n\n\t        if (!word) { continue; }\n\n\t        var isEol = false;\n\t        if (eol && word.indexOf(eol) >= 0) {\n\t            // word contains end-of-line character\n\t            if (word.length > 1) {\n\t                // separate word and continue cycle\n\t                var eolWords = word.split(eol);\n\t                for (var j = 0, jl = eolWords.length - 1; j < jl; j++) {\n\t                    eolWords.splice(2 * j + 1, 0, eol);\n\t                }\n\t                words.splice.apply(words, [ i, 1 ].concat( eolWords.filter(function (word) { return word !== ''; }) ));\n\t                i--;\n\t                len = words.length;\n\t                continue;\n\t            } else {\n\t                // creates a new line\n\t                lines[++l] = '';\n\t                isEol = true;\n\t            }\n\t        }\n\n\t        if (!isEol) {\n\t            textNode.data = lines[l] ? lines[l] + ' ' + word : word;\n\n\t            if (textSpan.getComputedTextLength() <= width) {\n\n\t                // the current line fits\n\t                lines[l] = textNode.data;\n\n\t                if (p || h) {\n\t                // We were partitioning. Put rest of the word onto next line\n\t                    full[l++] = true;\n\n\t                    // cancel partitioning and splitting by hyphens\n\t                    p = 0;\n\t                    h = 0;\n\t                }\n\n\t            } else {\n\n\t                if (!lines[l] || p) {\n\n\t                    var partition = !!p;\n\n\t                    p = word.length - 1;\n\n\t                    if (partition || !p) {\n\n\t                        // word has only one character.\n\t                        if (!p) {\n\n\t                            if (!lines[l]) {\n\n\t                                // we won't fit this text within our rect\n\t                                lines = [];\n\n\t                                break;\n\t                            }\n\n\t                            // partitioning didn't help on the non-empty line\n\t                            // try again, but this time start with a new line\n\n\t                            // cancel partitions created\n\t                            words.splice(i, 2, word + words[i + 1]);\n\n\t                            // adjust word length\n\t                            len--;\n\n\t                            full[l++] = true;\n\t                            i--;\n\n\t                            continue;\n\t                        }\n\n\t                        // move last letter to the beginning of the next word\n\t                        words[i] = word.substring(0, p);\n\t                        words[i + 1] = word.substring(p) + words[i + 1];\n\n\t                    } else {\n\n\t                        if (h) {\n\t                        // cancel splitting and put the words together again\n\t                            words.splice(i, 2, words[i] + words[i + 1]);\n\t                            h = 0;\n\t                        } else {\n\t                            var hyphenIndex = word.search(hyphen);\n\t                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n\t                                h = hyphenIndex + 1;\n\t                                p = 0;\n\t                            }\n\n\t                            // We initiate partitioning or splitting\n\t                            // split the long word into two words\n\t                            words.splice(i, 1, word.substring(0, h || p), word.substring(h|| p));\n\t                            // adjust words length\n\t                            len++;\n\n\t                        }\n\n\t                        if (l && !full[l - 1]) {\n\t                        // if the previous line is not full, try to fit max part of\n\t                        // the current word there\n\t                            l--;\n\t                        }\n\t                    }\n\n\t                    i--;\n\n\t                    continue;\n\t                }\n\n\t                l++;\n\t                i--;\n\t            }\n\t        }\n\t        var lastL = null;\n\n\t        if (lines.length > maxLineCount) {\n\n\t            lastL = maxLineCount - 1;\n\n\t        } else if (height !== undefined) {\n\n\t            // if size.height is defined we have to check whether the height of the entire\n\t            // text exceeds the rect height\n\n\t            if (lineHeight === undefined) {\n\n\t                var heightValue;\n\n\t                // use the same defaults as in V.prototype.text\n\t                if (styles.lineHeight === 'auto') {\n\t                    heightValue = { value: 1.5, unit: 'em' };\n\t                } else {\n\t                    heightValue = parseCssNumeric(styles.lineHeight, ['em']) || { value: 1, unit: 'em' };\n\t                }\n\n\t                lineHeight = heightValue.value;\n\t                if (heightValue.unit === 'em') {\n\t                    lineHeight *= textElement.getBBox().height;\n\t                }\n\t            }\n\n\t            if (lineHeight * lines.length > height) {\n\n\t                // remove overflowing lines\n\t                lastL = Math.floor(height / lineHeight) - 1;\n\t            }\n\t        }\n\n\t        if (lastL !== null) {\n\n\t            lines.splice(lastL + 1);\n\n\t            // add ellipsis\n\t            var ellipsis = opt.ellipsis;\n\t            if (!ellipsis || lastL < 0) { break; }\n\t            if (typeof ellipsis !== 'string') { ellipsis = '\\u2026'; }\n\n\t            var lastLine = lines[lastL];\n\t            if (!lastLine && !isEol) { break; }\n\t            var k = lastLine.length;\n\t            var lastLineWithOmission, lastChar, separatorChar;\n\t            do {\n\t                lastChar = lastLine[k];\n\t                lastLineWithOmission = lastLine.substring(0, k);\n\t                if (!lastChar) {\n\t                    separatorChar = (typeof separator === 'string') ? separator : ' ';\n\t                    lastLineWithOmission += separatorChar;\n\t                } else if (lastChar.match(separator)) {\n\t                    lastLineWithOmission += lastChar;\n\t                }\n\t                lastLineWithOmission += ellipsis;\n\t                textNode.data = lastLineWithOmission;\n\t                if (textSpan.getComputedTextLength() <= width) {\n\t                    lines[lastL] = lastLineWithOmission;\n\t                    break;\n\t                }\n\t                k--;\n\t            } while (k >= 0);\n\t            break;\n\t        }\n\t    }\n\n\t    if (opt.svgDocument) {\n\n\t        // svg document was provided, remove the text element only\n\t        svgDocument.removeChild(textElement);\n\n\t    } else {\n\n\t        // clean svg document\n\t        document.body.removeChild(svgDocument);\n\t    }\n\n\t    return lines.join(eol);\n\t};\n\n\t// Sanitize HTML\n\t// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n\t// Parses a string into an array of DOM nodes.\n\t// Then outputs it back as a string.\n\tvar sanitizeHTML = function(html) {\n\n\t    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n\n\t    // If documentContext (second parameter) is not specified or given as `null` or `undefined`, a new document is used.\n\t    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n\n\t    // If keepScripts (last parameter) is `false`, scripts are not executed.\n\t    var output = $($.parseHTML('<div>' + html + '</div>', null, false));\n\n\t    output.find('*').each(function() { // for all nodes\n\t        var currentNode = this;\n\n\t        $.each(currentNode.attributes, function() { // for all attributes in each node\n\t            var currentAttribute = this;\n\n\t            var attrName = currentAttribute.name;\n\t            var attrValue = currentAttribute.value;\n\n\t            // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n\t            // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n\t            if (attrName.startsWith('on') || attrValue.startsWith('javascript:') || attrValue.startsWith('data:') || attrValue.startsWith('vbscript:')) {\n\t                $(currentNode).removeAttr(attrName);\n\t            }\n\t        });\n\t    });\n\n\t    return output.html();\n\t};\n\n\t// Download `blob` as file with `fileName`.\n\t// Does not work in IE9.\n\tvar downloadBlob = function(blob, fileName) {\n\n\t    if (window.navigator.msSaveBlob) { // requires IE 10+\n\t        // pulls up a save dialog\n\t        window.navigator.msSaveBlob(blob, fileName);\n\n\t    } else { // other browsers\n\t        // downloads directly in Chrome and Safari\n\n\t        // presents a save/open dialog in Firefox\n\t        // Firefox bug: `from` field in save dialog always shows `from:blob:`\n\t        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n\t        var url = window.URL.createObjectURL(blob);\n\t        var link = document.createElement('a');\n\n\t        link.href = url;\n\t        link.download = fileName;\n\t        document.body.appendChild(link);\n\n\t        link.click();\n\n\t        document.body.removeChild(link);\n\t        window.URL.revokeObjectURL(url); // mark the url for garbage collection\n\t    }\n\t};\n\n\t// Download `dataUri` as file with `fileName`.\n\t// Does not work in IE9.\n\tvar downloadDataUri = function(dataUri, fileName) {\n\n\t    var blob = dataUriToBlob(dataUri);\n\t    downloadBlob(blob, fileName);\n\t};\n\n\t// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\n\tvar dataUriToBlob = function(dataUri) {\n\n\t    // first, make sure there are no newlines in the data uri\n\t    dataUri = dataUri.replace(/\\s/g, '');\n\t    dataUri = decodeURIComponent(dataUri);\n\n\t    var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n\t    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n\t    var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n\t    var data = dataUri.slice(firstCommaIndex + 1);\n\t    var decodedString;\n\t    if (dataTypeString.indexOf('base64') >= 0) { // data may be encoded in base64\n\t        decodedString = atob(data); // decode data\n\t    } else {\n\t        // convert the decoded string to UTF-8\n\t        decodedString = unescape(encodeURIComponent(data));\n\t    }\n\t    // write the bytes of the string to a typed array\n\t    var ia = new Uint8Array(decodedString.length);\n\t    for (var i = 0; i < decodedString.length; i++) {\n\t        ia[i] = decodedString.charCodeAt(i);\n\t    }\n\n\t    return new Blob([ia], { type: mimeString }); // return the typed array as Blob\n\t};\n\n\t// Read an image at `url` and return it as base64-encoded data uri.\n\t// The mime type of the image is inferred from the `url` file extension.\n\t// If data uri is provided as `url`, it is returned back unchanged.\n\t// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n\t// Works with IE9.\n\tvar imageToDataUri = function(url, callback) {\n\n\t    if (!url || url.substr(0, 'data:'.length) === 'data:') {\n\t        // No need to convert to data uri if it is already in data uri.\n\n\t        // This not only convenient but desired. For example,\n\t        // IE throws a security error if data:image/svg+xml is used to render\n\t        // an image to the canvas and an attempt is made to read out data uri.\n\t        // Now if our image is already in data uri, there is no need to render it to the canvas\n\t        // and so we can bypass this error.\n\n\t        // Keep the async nature of the function.\n\t        return setTimeout(function() {\n\t            callback(null, url);\n\t        }, 0);\n\t    }\n\n\t    // chrome, IE10+\n\t    var modernHandler = function(xhr, callback) {\n\n\t        if (xhr.status === 200) {\n\n\t            var reader = new FileReader();\n\n\t            reader.onload = function(evt) {\n\t                var dataUri = evt.target.result;\n\t                callback(null, dataUri);\n\t            };\n\n\t            reader.onerror = function() {\n\t                callback(new Error('Failed to load image ' + url));\n\t            };\n\n\t            reader.readAsDataURL(xhr.response);\n\t        } else {\n\t            callback(new Error('Failed to load image ' + url));\n\t        }\n\t    };\n\n\t    var legacyHandler = function(xhr, callback) {\n\n\t        var Uint8ToString = function(u8a) {\n\t            var CHUNK_SZ = 0x8000;\n\t            var c = [];\n\t            for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n\t                c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n\t            }\n\t            return c.join('');\n\t        };\n\n\t        if (xhr.status === 200) {\n\n\t            var bytes = new Uint8Array(xhr.response);\n\n\t            var suffix = (url.split('.').pop()) || 'png';\n\t            var map = {\n\t                'svg': 'svg+xml'\n\t            };\n\t            var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n\t            var b64encoded = meta + btoa(Uint8ToString(bytes));\n\t            callback(null, b64encoded);\n\t        } else {\n\t            callback(new Error('Failed to load image ' + url));\n\t        }\n\t    };\n\n\t    var xhr = new XMLHttpRequest();\n\n\t    xhr.open('GET', url, true);\n\t    xhr.addEventListener('error', function() {\n\t        callback(new Error('Failed to load image ' + url));\n\t    });\n\n\t    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\n\t    xhr.addEventListener('load', function() {\n\t        if (window.FileReader) {\n\t            modernHandler(xhr, callback);\n\t        } else {\n\t            legacyHandler(xhr, callback);\n\t        }\n\t    });\n\n\t    xhr.send();\n\t};\n\n\tvar getElementBBox = function(el) {\n\n\t    var $el = $(el);\n\t    if ($el.length === 0) {\n\t        throw new Error('Element not found');\n\t    }\n\n\t    var element = $el[0];\n\t    var doc = element.ownerDocument;\n\t    var clientBBox = element.getBoundingClientRect();\n\n\t    var strokeWidthX = 0;\n\t    var strokeWidthY = 0;\n\n\t    // Firefox correction\n\t    if (element.ownerSVGElement) {\n\n\t        var vel = V(element);\n\t        var bbox = vel.getBBox({ target: vel.svg() });\n\n\t        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n\t        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n\t        strokeWidthX = (clientBBox.width - bbox.width);\n\t        strokeWidthY = (clientBBox.height - bbox.height);\n\t    }\n\n\t    return {\n\t        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n\t        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n\t        width: clientBBox.width - strokeWidthX,\n\t        height: clientBBox.height - strokeWidthY\n\t    };\n\t};\n\n\n\t// Highly inspired by the jquery.sortElements plugin by Padolsey.\n\t// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n\tvar sortElements = function(elements, comparator) {\n\n\t    var $elements = $(elements);\n\t    var placements = $elements.map(function() {\n\n\t        var sortElement = this;\n\t        var parentNode = sortElement.parentNode;\n\t        // Since the element itself will change position, we have\n\t        // to have some way of storing it's original position in\n\t        // the DOM. The easiest way is to have a 'flag' node:\n\t        var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\n\t        return function() {\n\n\t            if (parentNode === this) {\n\t                throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n\t            }\n\n\t            // Insert before flag:\n\t            parentNode.insertBefore(this, nextSibling);\n\t            // Remove flag:\n\t            parentNode.removeChild(nextSibling);\n\t        };\n\t    });\n\n\t    return Array.prototype.sort.call($elements, comparator).each(function(i) {\n\t        placements[i].call(this);\n\t    });\n\t};\n\n\t// Sets attributes on the given element and its descendants based on the selector.\n\t// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\n\tvar setAttributesBySelector = function(element, attrs) {\n\n\t    var $element = $(element);\n\n\t    forIn(attrs, function(attrs, selector) {\n\t        var $elements = $element.find(selector).addBack().filter(selector);\n\t        // Make a special case for setting classes.\n\t        // We do not want to overwrite any existing class.\n\t        if (has$2(attrs, 'class')) {\n\t            $elements.addClass(attrs['class']);\n\t            attrs = omit(attrs, 'class');\n\t        }\n\t        $elements.attr(attrs);\n\t    });\n\t};\n\n\t// Return a new object with all four sides (top, right, bottom, left) in it.\n\t// Value of each side is taken from the given argument (either number or object).\n\t// Default value for a side is 0.\n\t// Examples:\n\t// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n\t// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n\t// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n\t// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n\t// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n\tvar normalizeSides = function(box) {\n\n\t    if (Object(box) !== box) { // `box` is not an object\n\t        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n\t        if (isFinite(box)) { val = +box; } // actually also accepts string numbers (e.g. '100')\n\n\t        return { top: val, right: val, bottom: val, left: val };\n\t    }\n\n\t    // `box` is an object\n\t    var top, right, bottom, left;\n\t    top = right = bottom = left = 0;\n\n\t    if (isFinite(box.vertical)) { top = bottom = +box.vertical; }\n\t    if (isFinite(box.horizontal)) { right = left = +box.horizontal; }\n\n\t    if (isFinite(box.top)) { top = +box.top; } // overwrite vertical\n\t    if (isFinite(box.right)) { right = +box.right; } // overwrite horizontal\n\t    if (isFinite(box.bottom)) { bottom = +box.bottom; } // overwrite vertical\n\t    if (isFinite(box.left)) { left = +box.left; } // overwrite horizontal\n\n\t    return { top: top, right: right, bottom: bottom, left: left };\n\t};\n\n\tvar timing = {\n\n\t    linear: function(t) {\n\t        return t;\n\t    },\n\n\t    quad: function(t) {\n\t        return t * t;\n\t    },\n\n\t    cubic: function(t) {\n\t        return t * t * t;\n\t    },\n\n\t    inout: function(t) {\n\t        if (t <= 0) { return 0; }\n\t        if (t >= 1) { return 1; }\n\t        var t2 = t * t;\n\t        var t3 = t2 * t;\n\t        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n\t    },\n\n\t    exponential: function(t) {\n\t        return Math.pow(2, 10 * (t - 1));\n\t    },\n\n\t    bounce: function(t) {\n\t        for (var a = 0, b = 1; 1; a += b, b /= 2) {\n\t            if (t >= (7 - 4 * a) / 11) {\n\t                var q = (11 - 6 * a - 11 * t) / 4;\n\t                return -q * q + b * b;\n\t            }\n\t        }\n\t    },\n\n\t    reverse: function(f) {\n\t        return function(t) {\n\t            return 1 - f(1 - t);\n\t        };\n\t    },\n\n\t    reflect: function(f) {\n\t        return function(t) {\n\t            return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n\t        };\n\t    },\n\n\t    clamp: function(f, n, x) {\n\t        n = n || 0;\n\t        x = x || 1;\n\t        return function(t) {\n\t            var r = f(t);\n\t            return r < n ? n : r > x ? x : r;\n\t        };\n\t    },\n\n\t    back: function(s) {\n\t        if (!s) { s = 1.70158; }\n\t        return function(t) {\n\t            return t * t * ((s + 1) * t - s);\n\t        };\n\t    },\n\n\t    elastic: function(x) {\n\t        if (!x) { x = 1.5; }\n\t        return function(t) {\n\t            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n\t        };\n\t    }\n\t};\n\n\tvar interpolate = {\n\n\t    number: function(a, b) {\n\t        var d = b - a;\n\t        return function(t) {\n\t            return a + d * t;\n\t        };\n\t    },\n\n\t    object: function(a, b) {\n\t        var s = Object.keys(a);\n\t        return function(t) {\n\t            var i, p;\n\t            var r = {};\n\t            for (i = s.length - 1; i != -1; i--) {\n\t                p = s[i];\n\t                r[p] = a[p] + (b[p] - a[p]) * t;\n\t            }\n\t            return r;\n\t        };\n\t    },\n\n\t    hexColor: function(a, b) {\n\n\t        var ca = parseInt(a.slice(1), 16);\n\t        var cb = parseInt(b.slice(1), 16);\n\t        var ra = ca & 0x0000ff;\n\t        var rd = (cb & 0x0000ff) - ra;\n\t        var ga = ca & 0x00ff00;\n\t        var gd = (cb & 0x00ff00) - ga;\n\t        var ba = ca & 0xff0000;\n\t        var bd = (cb & 0xff0000) - ba;\n\n\t        return function(t) {\n\n\t            var r = (ra + rd * t) & 0x000000ff;\n\t            var g = (ga + gd * t) & 0x0000ff00;\n\t            var b = (ba + bd * t) & 0x00ff0000;\n\n\t            return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n\t        };\n\t    },\n\n\t    unit: function(a, b) {\n\n\t        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n\t        var ma = r.exec(a);\n\t        var mb = r.exec(b);\n\t        var p = mb[1].indexOf('.');\n\t        var f = p > 0 ? mb[1].length - p - 1 : 0;\n\t        a = +ma[1];\n\t        var d = +mb[1] - a;\n\t        var u = ma[2];\n\n\t        return function(t) {\n\t            return (a + d * t).toFixed(f) + u;\n\t        };\n\t    }\n\t};\n\n\t// SVG filters.\n\t// (values in parentheses are default values)\n\tvar filter = {\n\n\t    // `color` ... outline color ('blue')\n\t    // `width`... outline width (1)\n\t    // `opacity` ... outline opacity (1)\n\t    // `margin` ... gap between outline and the element (2)\n\t    outline: function(args) {\n\n\t        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n\t        var margin = Number.isFinite(args.margin) ? args.margin : 2;\n\t        var width = Number.isFinite(args.width) ? args.width : 1;\n\n\t        return template(tpl)({\n\t            color: args.color || 'blue',\n\t            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n\t            outerRadius: margin + width,\n\t            innerRadius: margin\n\t        });\n\t    },\n\n\t    // `color` ... color ('red')\n\t    // `width`... width (1)\n\t    // `blur` ... blur (0)\n\t    // `opacity` ... opacity (1)\n\t    highlight: function(args) {\n\n\t        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\n\t        return template(tpl)({\n\t            color: args.color || 'red',\n\t            width: Number.isFinite(args.width) ? args.width : 1,\n\t            blur: Number.isFinite(args.blur) ? args.blur : 0,\n\t            opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n\t        });\n\t    },\n\n\t    // `x` ... horizontal blur (2)\n\t    // `y` ... vertical blur (optional)\n\t    blur: function(args) {\n\n\t        var x = Number.isFinite(args.x) ? args.x : 2;\n\n\t        return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n\t            stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n\t        });\n\t    },\n\n\t    // `dx` ... horizontal shift (0)\n\t    // `dy` ... vertical shift (0)\n\t    // `blur` ... blur (4)\n\t    // `color` ... color ('black')\n\t    // `opacity` ... opacity (1)\n\t    dropShadow: function(args) {\n\n\t        var tpl = 'SVGFEDropShadowElement' in window\n\t            ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>'\n\t            : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n\t        return template(tpl)({\n\t            dx: args.dx || 0,\n\t            dy: args.dy || 0,\n\t            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n\t            color: args.color || 'black',\n\t            blur: Number.isFinite(args.blur) ? args.blur : 4\n\t        });\n\t    },\n\n\t    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n\t    grayscale: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n\t            a: 0.2126 + 0.7874 * (1 - amount),\n\t            b: 0.7152 - 0.7152 * (1 - amount),\n\t            c: 0.0722 - 0.0722 * (1 - amount),\n\t            d: 0.2126 - 0.2126 * (1 - amount),\n\t            e: 0.7152 + 0.2848 * (1 - amount),\n\t            f: 0.0722 - 0.0722 * (1 - amount),\n\t            g: 0.2126 - 0.2126 * (1 - amount),\n\t            h: 0.0722 + 0.9278 * (1 - amount)\n\t        });\n\t    },\n\n\t    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n\t    sepia: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n\t            a: 0.393 + 0.607 * (1 - amount),\n\t            b: 0.769 - 0.769 * (1 - amount),\n\t            c: 0.189 - 0.189 * (1 - amount),\n\t            d: 0.349 - 0.349 * (1 - amount),\n\t            e: 0.686 + 0.314 * (1 - amount),\n\t            f: 0.168 - 0.168 * (1 - amount),\n\t            g: 0.272 - 0.272 * (1 - amount),\n\t            h: 0.534 - 0.534 * (1 - amount),\n\t            i: 0.131 + 0.869 * (1 - amount)\n\t        });\n\t    },\n\n\t    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n\t    saturate: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n\t            amount: 1 - amount\n\t        });\n\t    },\n\n\t    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n\t    hueRotate: function(args) {\n\n\t        return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n\t            angle: args.angle || 0\n\t        });\n\t    },\n\n\t    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n\t    invert: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n\t            amount: amount,\n\t            amount2: 1 - amount\n\t        });\n\t    },\n\n\t    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n\t    brightness: function(args) {\n\n\t        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n\t            amount: Number.isFinite(args.amount) ? args.amount : 1\n\t        });\n\t    },\n\n\t    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n\t    contrast: function(args) {\n\n\t        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n\t        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n\t            amount: amount,\n\t            amount2: .5 - amount / 2\n\t        });\n\t    }\n\t};\n\n\tvar format = {\n\n\t    // Formatting numbers via the Python Format Specification Mini-language.\n\t    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n\t    // Heavilly inspired by the D3.js library implementation.\n\t    number: function(specifier, value, locale) {\n\n\t        locale = locale || {\n\n\t            currency: ['$', ''],\n\t            decimal: '.',\n\t            thousands: ',',\n\t            grouping: [3]\n\t        };\n\n\t        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n\t        // [[fill]align][sign][symbol][0][width][,][.precision][type]\n\t        var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\n\t        var match = re.exec(specifier);\n\t        var fill = match[1] || ' ';\n\t        var align = match[2] || '>';\n\t        var sign = match[3] || '';\n\t        var symbol = match[4] || '';\n\t        var zfill = match[5];\n\t        var width = +match[6];\n\t        var comma = match[7];\n\t        var precision = match[8];\n\t        var type = match[9];\n\t        var scale = 1;\n\t        var prefix = '';\n\t        var suffix = '';\n\t        var integer = false;\n\n\t        if (precision) { precision = +precision.substring(1); }\n\n\t        if (zfill || fill === '0' && align === '=') {\n\t            zfill = fill = '0';\n\t            align = '=';\n\t            if (comma) { width -= Math.floor((width - 1) / 4); }\n\t        }\n\n\t        switch (type) {\n\t            case 'n':\n\t                comma = true;\n\t                type = 'g';\n\t                break;\n\t            case '%':\n\t                scale = 100;\n\t                suffix = '%';\n\t                type = 'f';\n\t                break;\n\t            case 'p':\n\t                scale = 100;\n\t                suffix = '%';\n\t                type = 'r';\n\t                break;\n\t            case 'b':\n\t            case 'o':\n\t            case 'x':\n\t            case 'X':\n\t                if (symbol === '#') { prefix = '0' + type.toLowerCase(); }\n\t                break;\n\t            case 'c':\n\t            case 'd':\n\t                integer = true;\n\t                precision = 0;\n\t                break;\n\t            case 's':\n\t                scale = -1;\n\t                type = 'r';\n\t                break;\n\t        }\n\n\t        if (symbol === '$') {\n\t            prefix = locale.currency[0];\n\t            suffix = locale.currency[1];\n\t        }\n\n\t        // If no precision is specified for `'r'`, fallback to general notation.\n\t        if (type == 'r' && !precision) { type = 'g'; }\n\n\t        // Ensure that the requested precision is in the supported range.\n\t        if (precision != null) {\n\t            if (type == 'g') { precision = Math.max(1, Math.min(21, precision)); }\n\t            else if (type == 'e' || type == 'f') { precision = Math.max(0, Math.min(20, precision)); }\n\t        }\n\n\t        var zcomma = zfill && comma;\n\n\t        // Return the empty string for floats formatted as ints.\n\t        if (integer && (value % 1)) { return ''; }\n\n\t        // Convert negative to positive, and record the sign prefix.\n\t        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\n\t        var fullSuffix = suffix;\n\n\t        // Apply the scale, computing it from the value's exponent for si format.\n\t        // Preserve the existing suffix, if any, such as the currency symbol.\n\t        if (scale < 0) {\n\t            var unit = this.prefix(value, precision);\n\t            value = unit.scale(value);\n\t            fullSuffix = unit.symbol + suffix;\n\t        } else {\n\t            value *= scale;\n\t        }\n\n\t        // Convert to the desired precision.\n\t        value = this.convert(type, value, precision);\n\n\t        // Break the value into the integer part (before) and decimal part (after).\n\t        var i = value.lastIndexOf('.');\n\t        var before = i < 0 ? value : value.substring(0, i);\n\t        var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\n\t        function formatGroup(value) {\n\n\t            var i = value.length;\n\t            var t = [];\n\t            var j = 0;\n\t            var g = locale.grouping[0];\n\t            while (i > 0 && g > 0) {\n\t                t.push(value.substring(i -= g, i + g));\n\t                g = locale.grouping[j = (j + 1) % locale.grouping.length];\n\t            }\n\t            return t.reverse().join(locale.thousands);\n\t        }\n\n\t        // If the fill character is not `'0'`, grouping is applied before padding.\n\t        if (!zfill && comma && locale.grouping) {\n\n\t            before = formatGroup(before);\n\t        }\n\n\t        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n\t        var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n\t        // If the fill character is `'0'`, grouping is applied after padding.\n\t        if (zcomma) { before = formatGroup(padding + before); }\n\n\t        // Apply prefix.\n\t        negative += prefix;\n\n\t        // Rejoin integer and decimal parts.\n\t        value = before + after;\n\n\t        return (align === '<' ? negative + value + padding\n\t            : align === '>' ? padding + negative + value\n\t                : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length)\n\t                    : negative + (zcomma ? value : padding + value)) + fullSuffix;\n\t    },\n\n\t    // Formatting string via the Python Format string.\n\t    // See https://docs.python.org/2/library/string.html#format-string-syntax)\n\t    string: function(formatString, value) {\n\n\t        var fieldDelimiterIndex;\n\t        var fieldDelimiter = '{';\n\t        var endPlaceholder = false;\n\t        var formattedStringArray = [];\n\n\t        while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\n\t            var pieceFormattedString, formatSpec, fieldName;\n\n\t            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\n\t            if (endPlaceholder) {\n\t                formatSpec = pieceFormattedString.split(':');\n\t                fieldName = formatSpec.shift().split('.');\n\t                pieceFormattedString = value;\n\n\t                for (var i = 0; i < fieldName.length; i++)\n\t                    { pieceFormattedString = pieceFormattedString[fieldName[i]]; }\n\n\t                if (formatSpec.length)\n\t                    { pieceFormattedString = this.number(formatSpec, pieceFormattedString); }\n\t            }\n\n\t            formattedStringArray.push(pieceFormattedString);\n\n\t            formatString = formatString.slice(fieldDelimiterIndex + 1);\n\t            endPlaceholder = !endPlaceholder;\n\t            fieldDelimiter = (endPlaceholder) ? '}' : '{';\n\t        }\n\t        formattedStringArray.push(formatString);\n\n\t        return formattedStringArray.join('');\n\t    },\n\n\t    convert: function(type, value, precision) {\n\n\t        switch (type) {\n\t            case 'b':\n\t                return value.toString(2);\n\t            case 'c':\n\t                return String.fromCharCode(value);\n\t            case 'o':\n\t                return value.toString(8);\n\t            case 'x':\n\t                return value.toString(16);\n\t            case 'X':\n\t                return value.toString(16).toUpperCase();\n\t            case 'g':\n\t                return value.toPrecision(precision);\n\t            case 'e':\n\t                return value.toExponential(precision);\n\t            case 'f':\n\t                return value.toFixed(precision);\n\t            case 'r':\n\t                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n\t            default:\n\t                return value + '';\n\t        }\n\t    },\n\n\t    round: function(value, precision) {\n\n\t        return precision\n\t            ? Math.round(value * (precision = Math.pow(10, precision))) / precision\n\t            : Math.round(value);\n\t    },\n\n\t    precision: function(value, precision) {\n\n\t        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n\t    },\n\n\t    prefix: function(value, precision) {\n\n\t        var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function(d, i) {\n\t            var k = Math.pow(10, Math.abs(8 - i) * 3);\n\t            return {\n\t                scale: i > 8 ? function(d) {\n\t                    return d / k;\n\t                } : function(d) {\n\t                    return d * k;\n\t                },\n\t                symbol: d\n\t            };\n\t        });\n\n\t        var i = 0;\n\t        if (value) {\n\t            if (value < 0) { value *= -1; }\n\t            if (precision) { value = this.round(value, this.precision(value, precision)); }\n\t            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n\t            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n\t        }\n\t        return prefixes[8 + i / 3];\n\t    }\n\t};\n\n\t/*\n\t    Pre-compile the HTML to be used as a template.\n\t*/\n\tvar template = function(html) {\n\n\t    /*\n\t        Must support the variation in templating syntax found here:\n\t        https://lodash.com/docs#template\n\t    */\n\t    var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\n\t    return function(data) {\n\n\t        data = data || {};\n\n\t        return html.replace(regex, function(match) {\n\n\t            var args = Array.from(arguments);\n\t            var attr = args.slice(1, 4).find(function(_attr) {\n\t                return !!_attr;\n\t            });\n\n\t            var attrArray = attr.split('.');\n\t            var value = data[attrArray.shift()];\n\n\t            while (value !== undefined && attrArray.length) {\n\t                value = value[attrArray.shift()];\n\t            }\n\n\t            return value !== undefined ? value : '';\n\t        });\n\t    };\n\t};\n\n\t/**\n\t * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n\t */\n\tvar toggleFullScreen = function(el) {\n\n\t    var topDocument = window.top.document;\n\t    el = el || topDocument.body;\n\n\t    function prefixedResult(el, prop) {\n\n\t        var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n\t        for (var i = 0; i < prefixes.length; i++) {\n\t            var prefix = prefixes[i];\n\t            var propName = prefix ? (prefix + prop) : (prop.substr(0, 1).toLowerCase() + prop.substr(1));\n\t            if (el[propName] !== undefined) {\n\t                return isFunction(el[propName]) ? el[propName]() : el[propName];\n\t            }\n\t        }\n\t    }\n\n\t    if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n\t        prefixedResult(topDocument, 'ExitFullscreen') || // Spec.\n\t        prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n\t    } else {\n\t        prefixedResult(el, 'RequestFullscreen') || // Spec.\n\t        prefixedResult(el, 'RequestFullScreen'); // Firefox\n\t    }\n\t};\n\n\t// Deprecated\n\t// Copy all the properties to the first argument from the following arguments.\n\t// All the properties will be overwritten by the properties from the following\n\t// arguments. Inherited properties are ignored.\n\tvar mixin = _.assign;\n\n\t// Deprecated\n\t// Copy all properties to the first argument from the following\n\t// arguments only in case if they don't exists in the first argument.\n\t// All the function propererties in the first argument will get\n\t// additional property base pointing to the extenders same named\n\t// property function's call method.\n\tvar supplement = _.defaults;\n\n\t// Same as `mixin()` but deep version.\n\tvar deepMixin = mixin;\n\n\t// Deprecated\n\t// Same as `supplement()` but deep version.\n\tvar deepSupplement = _.defaultsDeep;\n\n\t// Replacements for deprecated functions\n\tvar assign = _.assign;\n\tvar defaults = _.defaults;\n\t// no better-named replacement for `deepMixin`\n\tvar defaultsDeep = _.defaultsDeep;\n\n\t// Lodash 3 vs 4 incompatible\n\tvar invoke = _.invokeMap || _.invoke;\n\tvar sortedIndex = _.sortedIndexBy || _.sortedIndex;\n\tvar uniq = _.uniqBy || _.uniq;\n\n\tvar clone = _.clone;\n\tvar cloneDeep = _.cloneDeep;\n\tvar isEmpty = _.isEmpty;\n\tvar isEqual = _.isEqual;\n\tvar isFunction = _.isFunction;\n\tvar isPlainObject = _.isPlainObject;\n\tvar toArray = _.toArray;\n\tvar debounce = _.debounce;\n\tvar groupBy = _.groupBy;\n\tvar sortBy = _.sortBy;\n\tvar flattenDeep = _.flattenDeep;\n\tvar without = _.without;\n\tvar difference = _.difference;\n\tvar intersection = _.intersection;\n\tvar union = _.union;\n\tvar has$2 = _.has;\n\tvar result = _.result;\n\tvar omit = _.omit;\n\tvar pick = _.pick;\n\tvar bindAll = _.bindAll;\n\tvar forIn = _.forIn;\n\tvar camelCase = _.camelCase;\n\tvar uniqueId = _.uniqueId;\n\n\tvar merge = function() {\n\t    if (_.mergeWith) {\n\t        var args = Array.from(arguments);\n\t        var last = args[args.length - 1];\n\n\t        var customizer = isFunction(last) ? last : noop;\n\t        args.push(function(a, b) {\n\t            var customResult = customizer(a, b);\n\t            if (customResult !== undefined) {\n\t                return customResult;\n\t            }\n\n\t            if (Array.isArray(a) && !Array.isArray(b)) {\n\t                return b;\n\t            }\n\t        });\n\n\t        return _.mergeWith.apply(this, args);\n\t    }\n\t    return _.merge.apply(this, arguments);\n\t};\n\n\tvar isBoolean = function(value) {\n\t    var toString = Object.prototype.toString;\n\t    return value === true || value === false || (!!value && typeof value === 'object' && toString.call(value) === '[object Boolean]');\n\t};\n\n\tvar isObject$1 = function(value) {\n\t    return !!value && (typeof value === 'object' || typeof value === 'function');\n\t};\n\n\tvar isNumber = function(value) {\n\t    var toString = Object.prototype.toString;\n\t    return typeof value === 'number' || (!!value && typeof value === 'object' && toString.call(value) === '[object Number]');\n\t};\n\n\tvar isString = function(value) {\n\t    var toString = Object.prototype.toString;\n\t    return typeof value === 'string' || (!!value && typeof value === 'object' && toString.call(value) === '[object String]');\n\t};\n\n\tvar noop = function() {\n\t};\n\n\t// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n\t// of clones is exactly the same as the `cells.length`.\n\t// This function simply clones all the `cells`. However, it also reconstructs\n\t// all the `source/target` and `parent/embed` references within the `cells`.\n\t// This is the main difference from the `cell.clone()` method. The\n\t// `cell.clone()` method works on one single cell only.\n\t// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n\t// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n\t// the source and target of the link `L2` is changed to point to `A2` and `B2`.\n\tfunction cloneCells(cells) {\n\n\t    cells = uniq(cells);\n\n\t    // A map of the form [original cell ID] -> [clone] helping\n\t    // us to reconstruct references for source/target and parent/embeds.\n\t    // This is also the returned value.\n\t    var cloneMap = toArray(cells).reduce(function(map, cell) {\n\t        map[cell.id] = cell.clone();\n\t        return map;\n\t    }, {});\n\n\t    toArray(cells).forEach(function(cell) {\n\n\t        var clone = cloneMap[cell.id];\n\t        // assert(clone exists)\n\n\t        if (clone.isLink()) {\n\t            var source = clone.source();\n\t            var target = clone.target();\n\t            if (source.id && cloneMap[source.id]) {\n\t                // Source points to an element and the element is among the clones.\n\t                // => Update the source of the cloned link.\n\t                clone.prop('source/id', cloneMap[source.id].id);\n\t            }\n\t            if (target.id && cloneMap[target.id]) {\n\t                // Target points to an element and the element is among the clones.\n\t                // => Update the target of the cloned link.\n\t                clone.prop('target/id', cloneMap[target.id].id);\n\t            }\n\t        }\n\n\t        // Find the parent of the original cell\n\t        var parent = cell.get('parent');\n\t        if (parent && cloneMap[parent]) {\n\t            clone.set('parent', cloneMap[parent].id);\n\t        }\n\n\t        // Find the embeds of the original cell\n\t        var embeds = toArray(cell.get('embeds')).reduce(function(newEmbeds, embed) {\n\t            // Embedded cells that are not being cloned can not be carried\n\t            // over with other embedded cells.\n\t            if (cloneMap[embed]) {\n\t                newEmbeds.push(cloneMap[embed].id);\n\t            }\n\t            return newEmbeds;\n\t        }, []);\n\n\t        if (!isEmpty(embeds)) {\n\t            clone.set('embeds', embeds);\n\t        }\n\t    });\n\n\t    return cloneMap;\n\t}\n\n\tfunction setWrapper(attrName, dimension) {\n\t    return function(value, refBBox) {\n\t        var isValuePercentage = isPercentage(value);\n\t        value = parseFloat(value);\n\t        if (isValuePercentage) {\n\t            value /= 100;\n\t        }\n\n\t        var attrs = {};\n\t        if (isFinite(value)) {\n\t            var attrValue = (isValuePercentage || value >= 0 && value <= 1)\n\t                ? value * refBBox[dimension]\n\t                : Math.max(value + refBBox[dimension], 0);\n\t            attrs[attrName] = attrValue;\n\t        }\n\n\t        return attrs;\n\t    };\n\t}\n\n\tfunction positionWrapper(axis, dimension, origin) {\n\t    return function(value, refBBox) {\n\t        var valuePercentage = isPercentage(value);\n\t        value = parseFloat(value);\n\t        if (valuePercentage) {\n\t            value /= 100;\n\t        }\n\n\t        var delta;\n\t        if (isFinite(value)) {\n\t            var refOrigin = refBBox[origin]();\n\t            if (valuePercentage || value > 0 && value < 1) {\n\t                delta = refOrigin[axis] + refBBox[dimension] * value;\n\t            } else {\n\t                delta = refOrigin[axis] + value;\n\t            }\n\t        }\n\n\t        var point = Point();\n\t        point[axis] = delta || 0;\n\t        return point;\n\t    };\n\t}\n\n\tfunction offsetWrapper(axis, dimension, corner) {\n\t    return function(value, nodeBBox) {\n\t        var delta;\n\t        if (value === 'middle') {\n\t            delta = nodeBBox[dimension] / 2;\n\t        } else if (value === corner) {\n\t            delta = nodeBBox[dimension];\n\t        } else if (isFinite(value)) {\n\t            // TODO: or not to do a breaking change?\n\t            delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\n\t        } else if (isPercentage(value)) {\n\t            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n\t        } else {\n\t            delta = 0;\n\t        }\n\n\t        var point = Point();\n\t        point[axis] = -(nodeBBox[axis] + delta);\n\t        return point;\n\t    };\n\t}\n\n\tfunction shapeWrapper(shapeConstructor, opt) {\n\t    var cacheName = 'joint-shape';\n\t    var resetOffset = opt && opt.resetOffset;\n\t    return function(value, refBBox, node) {\n\t        var $node = $(node);\n\t        var cache = $node.data(cacheName);\n\t        if (!cache || cache.value !== value) {\n\t            // only recalculate if value has changed\n\t            var cachedShape = shapeConstructor(value);\n\t            cache = {\n\t                value: value,\n\t                shape: cachedShape,\n\t                shapeBBox: cachedShape.bbox()\n\t            };\n\t            $node.data(cacheName, cache);\n\t        }\n\n\t        var shape = cache.shape.clone();\n\t        var shapeBBox = cache.shapeBBox.clone();\n\t        var shapeOrigin = shapeBBox.origin();\n\t        var refOrigin = refBBox.origin();\n\n\t        shapeBBox.x = refOrigin.x;\n\t        shapeBBox.y = refOrigin.y;\n\n\t        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n\t        // `maxRectScaleToFit` can give Infinity if width or height is 0\n\t        var sx = (shapeBBox.width === 0 || refBBox.width === 0) ? 1 : fitScale.sx;\n\t        var sy = (shapeBBox.height === 0 || refBBox.height === 0) ? 1 : fitScale.sy;\n\n\t        shape.scale(sx, sy, shapeOrigin);\n\t        if (resetOffset) {\n\t            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n\t        }\n\n\t        return shape;\n\t    };\n\t}\n\n\t// `d` attribute for SVGPaths\n\tfunction dWrapper(opt) {\n\t    function pathConstructor(value) {\n\t        return new Path(V.normalizePathData(value));\n\t    }\n\n\t    var shape = shapeWrapper(pathConstructor, opt);\n\t    return function(value, refBBox, node) {\n\t        var path = shape(value, refBBox, node);\n\t        return {\n\t            d: path.serialize()\n\t        };\n\t    };\n\t}\n\n\t// `points` attribute for SVGPolylines and SVGPolygons\n\tfunction pointsWrapper(opt) {\n\t    var shape = shapeWrapper(Polyline, opt);\n\t    return function(value, refBBox, node) {\n\t        var polyline = shape(value, refBBox, node);\n\t        return {\n\t            points: polyline.serialize()\n\t        };\n\t    };\n\t}\n\n\tfunction atConnectionWrapper(method, opt) {\n\t    var zeroVector = new Point(1, 0);\n\t    return function(value) {\n\t        var p, angle;\n\t        var tangent = this[method](value);\n\t        if (tangent) {\n\t            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n\t            p = tangent.start;\n\t        } else {\n\t            p = this.path.start;\n\t            angle = 0;\n\t        }\n\t        if (angle === 0) { return { transform: 'translate(' + p.x + ',' + p.y + ')' }; }\n\t        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n\t    };\n\t}\n\n\tfunction isTextInUse(_value, _node, attrs) {\n\t    return (attrs.text !== undefined);\n\t}\n\n\tfunction isLinkView() {\n\t    return this.model.isLink();\n\t}\n\n\tfunction contextMarker(context) {\n\t    var marker = {};\n\t    // Stroke\n\t    // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n\t    // (for which 'fill' attribute is set to 'none').\n\t    var stroke = context.stroke;\n\t    if (typeof stroke === 'string') {\n\t        marker['stroke'] = stroke;\n\t        marker['fill'] = stroke;\n\t    }\n\t    // Opacity\n\t    // Again the context 'fill-opacity' is ignored.\n\t    var strokeOpacity = context.strokeOpacity;\n\t    if (strokeOpacity === undefined) { strokeOpacity = context['stroke-opacity']; }\n\t    if (strokeOpacity === undefined) { strokeOpacity = context.opacity; }\n\t    if (strokeOpacity !== undefined) {\n\t        marker['stroke-opacity'] = strokeOpacity;\n\t        marker['fill-opacity'] = strokeOpacity;\n\t    }\n\t    return marker;\n\t}\n\n\tvar attributesNS = {\n\n\t    xlinkHref: {\n\t        set: 'xlink:href'\n\t    },\n\n\t    xlinkShow: {\n\t        set: 'xlink:show'\n\t    },\n\n\t    xlinkRole: {\n\t        set: 'xlink:role'\n\t    },\n\n\t    xlinkType: {\n\t        set: 'xlink:type'\n\t    },\n\n\t    xlinkArcrole: {\n\t        set: 'xlink:arcrole'\n\t    },\n\n\t    xlinkTitle: {\n\t        set: 'xlink:title'\n\t    },\n\n\t    xlinkActuate: {\n\t        set: 'xlink:actuate'\n\t    },\n\n\t    xmlSpace: {\n\t        set: 'xml:space'\n\t    },\n\n\t    xmlBase: {\n\t        set: 'xml:base'\n\t    },\n\n\t    xmlLang: {\n\t        set: 'xml:lang'\n\t    },\n\n\t    preserveAspectRatio: {\n\t        set: 'preserveAspectRatio'\n\t    },\n\n\t    requiredExtension: {\n\t        set: 'requiredExtension'\n\t    },\n\n\t    requiredFeatures: {\n\t        set: 'requiredFeatures'\n\t    },\n\n\t    systemLanguage: {\n\t        set: 'systemLanguage'\n\t    },\n\n\t    externalResourcesRequired: {\n\t        set: 'externalResourceRequired'\n\t    },\n\n\t    filter: {\n\t        qualify: isPlainObject,\n\t        set: function(filter) {\n\t            return 'url(#' + this.paper.defineFilter(filter) + ')';\n\t        }\n\t    },\n\n\t    fill: {\n\t        qualify: isPlainObject,\n\t        set: function(fill) {\n\t            return 'url(#' + this.paper.defineGradient(fill) + ')';\n\t        }\n\t    },\n\n\t    stroke: {\n\t        qualify: isPlainObject,\n\t        set: function(stroke) {\n\t            return 'url(#' + this.paper.defineGradient(stroke) + ')';\n\t        }\n\t    },\n\n\t    sourceMarker: {\n\t        qualify: isPlainObject,\n\t        set: function(marker, refBBox, node, attrs) {\n\t            marker = assign(contextMarker(attrs), marker);\n\t            return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\n\t        }\n\t    },\n\n\t    targetMarker: {\n\t        qualify: isPlainObject,\n\t        set: function(marker, refBBox, node, attrs) {\n\t            marker = assign(contextMarker(attrs), { 'transform': 'rotate(180)' }, marker);\n\t            return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\n\t        }\n\t    },\n\n\t    vertexMarker: {\n\t        qualify: isPlainObject,\n\t        set: function(marker, refBBox, node, attrs) {\n\t            marker = assign(contextMarker(attrs), marker);\n\t            return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\n\t        }\n\t    },\n\n\t    text: {\n\t        qualify: function(_text, _node, attrs) {\n\t            return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n\t        },\n\t        set: function(text, _refBBox, node, attrs) {\n\t            var $node = $(node);\n\t            var cacheName = 'joint-text';\n\t            var cache = $node.data(cacheName);\n\t            var textAttrs = pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty');\n\t            var fontSize = textAttrs.fontSize = attrs['font-size'] || attrs['fontSize'];\n\t            var textHash = JSON.stringify([text, textAttrs]);\n\t            // Update the text only if there was a change in the string\n\t            // or any of its attributes.\n\t            if (cache === undefined || cache !== textHash) {\n\t                // Chrome bug:\n\t                // Tspans positions defined as `em` are not updated\n\t                // when container `font-size` change.\n\t                if (fontSize) { node.setAttribute('font-size', fontSize); }\n\t                // Text Along Path Selector\n\t                var textPath = textAttrs.textPath;\n\t                if (isObject$1(textPath)) {\n\t                    var pathSelector = textPath.selector;\n\t                    if (typeof pathSelector === 'string') {\n\t                        var pathNode = this.findBySelector(pathSelector)[0];\n\t                        if (pathNode instanceof SVGPathElement) {\n\t                            textAttrs.textPath = assign({ 'xlink:href': '#' + pathNode.id }, textPath);\n\t                        }\n\t                    }\n\t                }\n\t                V(node).text('' + text, textAttrs);\n\t                $node.data(cacheName, textHash);\n\t            }\n\t        }\n\t    },\n\n\t    textWrap: {\n\t        qualify: isPlainObject,\n\t        set: function(value, refBBox, node, attrs) {\n\t            // option `width`\n\t            var width = value.width || 0;\n\t            if (isPercentage(width)) {\n\t                refBBox.width *= parseFloat(width) / 100;\n\t            } else if (width <= 0) {\n\t                refBBox.width += width;\n\t            } else {\n\t                refBBox.width = width;\n\t            }\n\t            // option `height`\n\t            var height = value.height || 0;\n\t            if (isPercentage(height)) {\n\t                refBBox.height *= parseFloat(height) / 100;\n\t            } else if (height <= 0) {\n\t                refBBox.height += height;\n\t            } else {\n\t                refBBox.height = height;\n\t            }\n\t            // option `text`\n\t            var wrappedText;\n\t            var text = value.text;\n\t            if (text === undefined) { text = attrs.text; }\n\t            if (text !== undefined) {\n\t                wrappedText = breakText('' + text, refBBox, {\n\t                    'font-weight': attrs['font-weight'] || attrs.fontWeight,\n\t                    'font-size': attrs['font-size'] || attrs.fontSize,\n\t                    'font-family': attrs['font-family'] || attrs.fontFamily,\n\t                    'lineHeight': attrs.lineHeight,\n\t                    'letter-spacing': 'letter-spacing' in attrs ? attrs['letter-spacing'] : attrs.letterSpacing\n\t                }, {\n\t                    // Provide an existing SVG Document here\n\t                    // instead of creating a temporary one over again.\n\t                    svgDocument: this.paper.svg,\n\t                    ellipsis: value.ellipsis,\n\t                    hyphen: value.hyphen,\n\t                    maxLineCount: value.maxLineCount\n\t                });\n\t            } else {\n\t                wrappedText = '';\n\t            }\n\t            attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n\t        }\n\t    },\n\n\t    title: {\n\t        qualify: function(title, node) {\n\t            // HTMLElement title is specified via an attribute (i.e. not an element)\n\t            return node instanceof SVGElement;\n\t        },\n\t        set: function(title, refBBox, node) {\n\t            var $node = $(node);\n\t            var cacheName = 'joint-title';\n\t            var cache = $node.data(cacheName);\n\t            if (cache === undefined || cache !== title) {\n\t                $node.data(cacheName, title);\n\t                // Generally <title> element should be the first child element of its parent.\n\t                var firstChild = node.firstChild;\n\t                if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {\n\t                    // Update an existing title\n\t                    firstChild.textContent = title;\n\t                } else {\n\t                    // Create a new title\n\t                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n\t                    titleNode.textContent = title;\n\t                    node.insertBefore(titleNode, firstChild);\n\t                }\n\t            }\n\t        }\n\t    },\n\n\t    lineHeight: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    textVerticalAnchor: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    textPath: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    annotations: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    eol: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    displayEmpty: {\n\t        qualify: isTextInUse\n\t    },\n\n\t    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n\t    port: {\n\t        set: function(port) {\n\t            return (port === null || port.id === undefined) ? port : port.id;\n\t        }\n\t    },\n\n\t    // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n\t    style: {\n\t        qualify: isPlainObject,\n\t        set: function(styles, refBBox, node) {\n\t            $(node).css(styles);\n\t        }\n\t    },\n\n\t    html: {\n\t        set: function(html, refBBox, node) {\n\t            $(node).html(html + '');\n\t        }\n\t    },\n\n\t    ref: {\n\t        // We do not set `ref` attribute directly on an element.\n\t        // The attribute itself does not qualify for relative positioning.\n\t    },\n\n\t    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n\t    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n\t    // otherwise, `refX` is the left coordinate of the bounding box\n\n\t    refX: {\n\t        position: positionWrapper('x', 'width', 'origin')\n\t    },\n\n\t    refY: {\n\t        position: positionWrapper('y', 'height', 'origin')\n\t    },\n\n\t    // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n\t    // coordinate of the reference element.\n\n\t    refDx: {\n\t        position: positionWrapper('x', 'width', 'corner')\n\t    },\n\n\t    refDy: {\n\t        position: positionWrapper('y', 'height', 'corner')\n\t    },\n\n\t    // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n\t    // the reference element size\n\t    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n\t    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n\t    refWidth: {\n\t        set: setWrapper('width', 'width')\n\t    },\n\n\t    refHeight: {\n\t        set: setWrapper('height', 'height')\n\t    },\n\n\t    refRx: {\n\t        set: setWrapper('rx', 'width')\n\t    },\n\n\t    refRy: {\n\t        set: setWrapper('ry', 'height')\n\t    },\n\n\t    refRInscribed: {\n\t        set: (function(attrName) {\n\t            var widthFn = setWrapper(attrName, 'width');\n\t            var heightFn = setWrapper(attrName, 'height');\n\t            return function(value, refBBox) {\n\t                var fn = (refBBox.height > refBBox.width) ? widthFn : heightFn;\n\t                return fn(value, refBBox);\n\t            };\n\t        })('r')\n\t    },\n\n\t    refRCircumscribed: {\n\t        set: function(value, refBBox) {\n\t            var isValuePercentage = isPercentage(value);\n\t            value = parseFloat(value);\n\t            if (isValuePercentage) {\n\t                value /= 100;\n\t            }\n\n\t            var diagonalLength = Math.sqrt((refBBox.height * refBBox.height) + (refBBox.width * refBBox.width));\n\n\t            var rValue;\n\t            if (isFinite(value)) {\n\t                if (isValuePercentage || value >= 0 && value <= 1) { rValue = value * diagonalLength; }\n\t                else { rValue = Math.max(value + diagonalLength, 0); }\n\t            }\n\n\t            return { r: rValue };\n\t        }\n\t    },\n\n\t    refCx: {\n\t        set: setWrapper('cx', 'width')\n\t    },\n\n\t    refCy: {\n\t        set: setWrapper('cy', 'height')\n\t    },\n\n\t    // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n\t    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n\n\t    xAlignment: {\n\t        offset: offsetWrapper('x', 'width', 'right')\n\t    },\n\n\t    // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n\t    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n\n\t    yAlignment: {\n\t        offset: offsetWrapper('y', 'height', 'bottom')\n\t    },\n\n\t    resetOffset: {\n\t        offset: function(val, nodeBBox) {\n\t            return (val)\n\t                ? { x: -nodeBBox.x, y: -nodeBBox.y }\n\t                : { x: 0, y: 0 };\n\t        }\n\n\t    },\n\n\t    refDResetOffset: {\n\t        set: dWrapper({ resetOffset: true })\n\t    },\n\n\t    refDKeepOffset: {\n\t        set: dWrapper({ resetOffset: false })\n\t    },\n\n\t    refPointsResetOffset: {\n\t        set: pointsWrapper({ resetOffset: true })\n\t    },\n\n\t    refPointsKeepOffset: {\n\t        set: pointsWrapper({ resetOffset: false })\n\t    },\n\n\t    // LinkView Attributes\n\n\t    connection: {\n\t        qualify: isLinkView,\n\t        set: function(ref) {\n\t            var stubs = ref.stubs; if ( stubs === void 0 ) stubs = 0;\n\n\t            var d;\n\t            if (isFinite(stubs) && stubs !== 0) {\n\t                var offset;\n\t                if (stubs < 0) {\n\t                    offset = (this.getConnectionLength() + stubs) / 2;\n\t                } else {\n\t                    offset = stubs;\n\t                }\n\t                var path = this.getConnection();\n\t                var sourceParts = path.divideAtLength(offset);\n\t                var targetParts = path.divideAtLength(-offset);\n\t                if (sourceParts && targetParts) {\n\t                    d = (sourceParts[0].serialize()) + \" \" + (targetParts[1].serialize());\n\t                }\n\t            }\n\n\t            return { d: d || this.getSerializedConnection() };\n\t        }\n\t    },\n\n\t    atConnectionLengthKeepGradient: {\n\t        qualify: isLinkView,\n\t        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n\t    },\n\n\t    atConnectionLengthIgnoreGradient: {\n\t        qualify: isLinkView,\n\t        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n\t    },\n\n\t    atConnectionRatioKeepGradient: {\n\t        qualify: isLinkView,\n\t        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n\t    },\n\n\t    atConnectionRatioIgnoreGradient: {\n\t        qualify: isLinkView,\n\t        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n\t    }\n\t};\n\n\t// Aliases\n\tattributesNS.refR = attributesNS.refRInscribed;\n\tattributesNS.refD = attributesNS.refDResetOffset;\n\tattributesNS.refPoints = attributesNS.refPointsResetOffset;\n\tattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\n\tattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;\n\n\t// This allows to combine both absolute and relative positioning\n\t// refX: 50%, refX2: 20\n\tattributesNS.refX2 = attributesNS.refX;\n\tattributesNS.refY2 = attributesNS.refY;\n\tattributesNS.refWidth2 = attributesNS.refWidth;\n\tattributesNS.refHeight2 = attributesNS.refHeight;\n\n\t// Aliases for backwards compatibility\n\tattributesNS['ref-x'] = attributesNS.refX;\n\tattributesNS['ref-y'] = attributesNS.refY;\n\tattributesNS['ref-dy'] = attributesNS.refDy;\n\tattributesNS['ref-dx'] = attributesNS.refDx;\n\tattributesNS['ref-width'] = attributesNS.refWidth;\n\tattributesNS['ref-height'] = attributesNS.refHeight;\n\tattributesNS['x-alignment'] = attributesNS.xAlignment;\n\tattributesNS['y-alignment'] = attributesNS.yAlignment;\n\n\tvar attributes = attributesNS;\n\n\t// Cell base model.\n\t// --------------------------\n\n\tvar Cell = Backbone.Model.extend({\n\n\t    // This is the same as Backbone.Model with the only difference that is uses util.merge\n\t    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n\t    constructor: function(attributes, options) {\n\n\t        var defaults;\n\t        var attrs = attributes || {};\n\t        this.cid = uniqueId('c');\n\t        this.attributes = {};\n\t        if (options && options.collection) { this.collection = options.collection; }\n\t        if (options && options.parse) { attrs = this.parse(attrs, options) || {}; }\n\t        if ((defaults = result(this, 'defaults'))) {\n\t            //<custom code>\n\t            // Replaced the call to _.defaults with util.merge.\n\t            attrs = merge({}, defaults, attrs);\n\t            //</custom code>\n\t        }\n\t        this.set(attrs, options);\n\t        this.changed = {};\n\t        this.initialize.apply(this, arguments);\n\t    },\n\n\t    translate: function(dx, dy, opt) {\n\n\t        throw new Error('Must define a translate() method.');\n\t    },\n\n\t    toJSON: function() {\n\n\t        var defaultAttrs = this.constructor.prototype.defaults.attrs || {};\n\t        var attrs = this.attributes.attrs;\n\t        var finalAttrs = {};\n\n\t        // Loop through all the attributes and\n\t        // omit the default attributes as they are implicitly reconstructable by the cell 'type'.\n\t        forIn(attrs, function(attr, selector) {\n\n\t            var defaultAttr = defaultAttrs[selector];\n\n\t            forIn(attr, function(value, name) {\n\n\t                // attr is mainly flat though it might have one more level (consider the `style` attribute).\n\t                // Check if the `value` is object and if yes, go one level deep.\n\t                if (isObject$1(value) && !Array.isArray(value)) {\n\n\t                    forIn(value, function(value2, name2) {\n\n\t                        if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n\n\t                            finalAttrs[selector] = finalAttrs[selector] || {};\n\t                            (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n\t                        }\n\t                    });\n\n\t                } else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n\t                    // `value` is not an object, default attribute for such a selector does not exist\n\t                    // or it is different than the attribute value set on the model.\n\n\t                    finalAttrs[selector] = finalAttrs[selector] || {};\n\t                    finalAttrs[selector][name] = value;\n\t                }\n\t            });\n\t        });\n\n\t        var attributes = cloneDeep(omit(this.attributes, 'attrs'));\n\t        attributes.attrs = finalAttrs;\n\n\t        return attributes;\n\t    },\n\n\t    initialize: function(options) {\n\n\t        if (!options || !options.id) {\n\n\t            this.set('id', this.generateId(), { silent: true });\n\t        }\n\n\t        this._transitionIds = {};\n\n\t        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n\t        this.processPorts();\n\t        this.on('change:attrs', this.processPorts, this);\n\t    },\n\n\t    generateId: function() {\n\t        return uuid();\n\t    },\n\n\t    /**\n\t     * @deprecated\n\t     */\n\t    processPorts: function() {\n\n\t        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n\t        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n\t        // set to that port, we remove those links as well (to follow the same behaviour as\n\t        // with a removed element).\n\n\t        var previousPorts = this.ports;\n\n\t        // Collect ports from the `attrs` object.\n\t        var ports = {};\n\t        forIn(this.get('attrs'), function(attrs, selector) {\n\n\t            if (attrs && attrs.port) {\n\n\t                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n\t                if (attrs.port.id !== undefined) {\n\t                    ports[attrs.port.id] = attrs.port;\n\t                } else {\n\t                    ports[attrs.port] = { id: attrs.port };\n\t                }\n\t            }\n\t        });\n\n\t        // Collect ports that have been removed (compared to the previous ports) - if any.\n\t        // Use hash table for quick lookup.\n\t        var removedPorts = {};\n\t        forIn(previousPorts, function(port, id) {\n\n\t            if (!ports[id]) { removedPorts[id] = true; }\n\t        });\n\n\t        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n\t        if (this.graph && !isEmpty(removedPorts)) {\n\n\t            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\n\t            inboundLinks.forEach(function(link) {\n\n\t                if (removedPorts[link.get('target').port]) { link.remove(); }\n\t            });\n\n\t            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\n\t            outboundLinks.forEach(function(link) {\n\n\t                if (removedPorts[link.get('source').port]) { link.remove(); }\n\t            });\n\t        }\n\n\t        // Update the `ports` object.\n\t        this.ports = ports;\n\t    },\n\n\t    remove: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        // Store the graph in a variable because `this.graph` won't be accessible\n\t        // after `this.trigger('remove', ...)` down below.\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        var collection = ref.collection;\n\t        if (!graph) {\n\t            // The collection is a common Backbone collection (not the graph collection).\n\t            if (collection) { collection.remove(this, opt); }\n\t            return this;\n\t        }\n\n\t        graph.startBatch('remove');\n\n\t        // First, unembed this cell from its parent cell if there is one.\n\t        var parentCell = this.getParentCell();\n\t        if (parentCell) {\n\t            parentCell.unembed(this, opt);\n\t        }\n\n\t        // Remove also all the cells, which were embedded into this cell\n\t        var embeddedCells = this.getEmbeddedCells();\n\t        for (var i = 0, n = embeddedCells.length; i < n; i++) {\n\t            var embed = embeddedCells[i];\n\t            if (embed) {\n\t                embed.remove(opt);\n\t            }\n\t        }\n\n\t        this.trigger('remove', this, graph.attributes.cells, opt);\n\n\t        graph.stopBatch('remove');\n\n\t        return this;\n\t    },\n\n\t    toFront: function(opt) {\n\n\t        var graph = this.graph;\n\t        if (graph) {\n\n\t            opt = opt || {};\n\n\t            var z = graph.maxZIndex();\n\n\t            var cells;\n\n\t            if (opt.deep) {\n\t                cells = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n\t                cells.unshift(this);\n\t            } else {\n\t                cells = [this];\n\t            }\n\n\t            z = z - cells.length + 1;\n\n\t            var collection = graph.get('cells');\n\t            var shouldUpdate = (collection.indexOf(this) !== (collection.length - cells.length));\n\t            if (!shouldUpdate) {\n\t                shouldUpdate = cells.some(function(cell, index) {\n\t                    return cell.get('z') !== z + index;\n\t                });\n\t            }\n\n\t            if (shouldUpdate) {\n\t                this.startBatch('to-front');\n\n\t                z = z + cells.length;\n\n\t                cells.forEach(function(cell, index) {\n\t                    cell.set('z', z + index, opt);\n\t                });\n\n\t                this.stopBatch('to-front');\n\t            }\n\t        }\n\n\t        return this;\n\t    },\n\n\t    toBack: function(opt) {\n\n\t        var graph = this.graph;\n\t        if (graph) {\n\n\t            opt = opt || {};\n\n\t            var z = graph.minZIndex();\n\n\t            var cells;\n\n\t            if (opt.deep) {\n\t                cells = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n\t                cells.unshift(this);\n\t            } else {\n\t                cells = [this];\n\t            }\n\n\t            var collection = graph.get('cells');\n\t            var shouldUpdate = (collection.indexOf(this) !== 0);\n\t            if (!shouldUpdate) {\n\t                shouldUpdate = cells.some(function(cell, index) {\n\t                    return cell.get('z') !== z + index;\n\t                });\n\t            }\n\n\t            if (shouldUpdate) {\n\t                this.startBatch('to-back');\n\n\t                z -= cells.length;\n\n\t                cells.forEach(function(cell, index) {\n\t                    cell.set('z', z + index, opt);\n\t                });\n\n\t                this.stopBatch('to-back');\n\t            }\n\t        }\n\n\t        return this;\n\t    },\n\n\t    parent: function(parent, opt) {\n\n\t        // getter\n\t        if (parent === undefined) { return this.get('parent'); }\n\t        // setter\n\t        return this.set('parent', parent, opt);\n\t    },\n\n\t    embed: function(cell, opt) {\n\n\t        if (this === cell || this.isEmbeddedIn(cell)) {\n\n\t            throw new Error('Recursive embedding not allowed.');\n\n\t        } else {\n\n\t            this.startBatch('embed');\n\n\t            var embeds = assign([], this.get('embeds'));\n\n\t            // We keep all element ids after link ids.\n\t            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n\n\t            cell.parent(this.id, opt);\n\t            this.set('embeds', uniq(embeds), opt);\n\n\t            this.stopBatch('embed');\n\t        }\n\n\t        return this;\n\t    },\n\n\t    unembed: function(cell, opt) {\n\n\t        this.startBatch('unembed');\n\n\t        cell.unset('parent', opt);\n\t        this.set('embeds', without(this.get('embeds'), cell.id), opt);\n\n\t        this.stopBatch('unembed');\n\n\t        return this;\n\t    },\n\n\t    getParentCell: function() {\n\n\t        // unlike link.source/target, cell.parent stores id directly as a string\n\t        var parentId = this.parent();\n\t        var graph = this.graph;\n\n\t        return (parentId && graph && graph.getCell(parentId)) || null;\n\t    },\n\n\t    // Return an array of ancestor cells.\n\t    // The array is ordered from the parent of the cell\n\t    // to the most distant ancestor.\n\t    getAncestors: function() {\n\n\t        var ancestors = [];\n\n\t        if (!this.graph) {\n\t            return ancestors;\n\t        }\n\n\t        var parentCell = this.getParentCell();\n\t        while (parentCell) {\n\t            ancestors.push(parentCell);\n\t            parentCell = parentCell.getParentCell();\n\t        }\n\n\t        return ancestors;\n\t    },\n\n\t    getEmbeddedCells: function(opt) {\n\n\t        opt = opt || {};\n\n\t        // Cell models can only be retrieved when this element is part of a collection.\n\t        // There is no way this element knows about other cells otherwise.\n\t        // This also means that calling e.g. `translate()` on an element with embeds before\n\t        // adding it to a graph does not translate its embeds.\n\t        if (this.graph) {\n\n\t            var cells;\n\n\t            if (opt.deep) {\n\n\t                if (opt.breadthFirst) {\n\n\t                    // breadthFirst algorithm\n\t                    cells = [];\n\t                    var queue = this.getEmbeddedCells();\n\n\t                    while (queue.length > 0) {\n\n\t                        var parent = queue.shift();\n\t                        cells.push(parent);\n\t                        queue.push.apply(queue, parent.getEmbeddedCells());\n\t                    }\n\n\t                } else {\n\n\t                    // depthFirst algorithm\n\t                    cells = this.getEmbeddedCells();\n\t                    cells.forEach(function(cell) {\n\t                        cells.push.apply(cells, cell.getEmbeddedCells(opt));\n\t                    });\n\t                }\n\n\t            } else {\n\n\t                cells = toArray(this.get('embeds')).map(this.graph.getCell, this.graph);\n\t            }\n\n\t            return cells;\n\t        }\n\t        return [];\n\t    },\n\n\t    isEmbeddedIn: function(cell, opt) {\n\n\t        var cellId = isString(cell) ? cell : cell.id;\n\t        var parentId = this.parent();\n\n\t        opt = defaults({ deep: true }, opt);\n\n\t        // See getEmbeddedCells().\n\t        if (this.graph && opt.deep) {\n\n\t            while (parentId) {\n\t                if (parentId === cellId) {\n\t                    return true;\n\t                }\n\t                parentId = this.graph.getCell(parentId).parent();\n\t            }\n\n\t            return false;\n\n\t        } else {\n\n\t            // When this cell is not part of a collection check\n\t            // at least whether it's a direct child of given cell.\n\t            return parentId === cellId;\n\t        }\n\t    },\n\n\t    // Whether or not the cell is embedded in any other cell.\n\t    isEmbedded: function() {\n\n\t        return !!this.parent();\n\t    },\n\n\t    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n\t    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n\t    // Deep cloning clones the cell and all its embedded cells recursively.\n\t    clone: function(opt) {\n\n\t        opt = opt || {};\n\n\t        if (!opt.deep) {\n\t            // Shallow cloning.\n\n\t            var clone = Backbone.Model.prototype.clone.apply(this, arguments);\n\t            // We don't want the clone to have the same ID as the original.\n\t            clone.set('id', this.generateId());\n\t            // A shallow cloned element does not carry over the original embeds.\n\t            clone.unset('embeds');\n\t            // And can not be embedded in any cell\n\t            // as the clone is not part of the graph.\n\t            clone.unset('parent');\n\n\t            return clone;\n\n\t        } else {\n\t            // Deep cloning.\n\n\t            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n\t            return toArray(cloneCells([this].concat(this.getEmbeddedCells({ deep: true }))));\n\t        }\n\t    },\n\n\t    // A convenient way to set nested properties.\n\t    // This method merges the properties you'd like to set with the ones\n\t    // stored in the cell and makes sure change events are properly triggered.\n\t    // You can either set a nested property with one object\n\t    // or use a property path.\n\t    // The most simple use case is:\n\t    // `cell.prop('name/first', 'John')` or\n\t    // `cell.prop({ name: { first: 'John' } })`.\n\t    // Nested arrays are supported too:\n\t    // `cell.prop('series/0/data/0/degree', 50)` or\n\t    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n\t    prop: function(props, value, opt) {\n\n\t        var delim = '/';\n\t        var _isString = isString(props);\n\n\t        if (_isString || Array.isArray(props)) {\n\t            // Get/set an attribute by a special path syntax that delimits\n\t            // nested objects by the colon character.\n\n\t            if (arguments.length > 1) {\n\n\t                var path;\n\t                var pathArray;\n\n\t                if (_isString) {\n\t                    path = props;\n\t                    pathArray = path.split('/');\n\t                } else {\n\t                    path = props.join(delim);\n\t                    pathArray = props.slice();\n\t                }\n\n\t                var property = pathArray[0];\n\t                var pathArrayLength = pathArray.length;\n\n\t                opt = opt || {};\n\t                opt.propertyPath = path;\n\t                opt.propertyValue = value;\n\t                opt.propertyPathArray = pathArray;\n\n\t                if (pathArrayLength === 1) {\n\t                    // Property is not nested. We can simply use `set()`.\n\t                    return this.set(property, value, opt);\n\t                }\n\n\t                var update = {};\n\t                // Initialize the nested object. Subobjects are either arrays or objects.\n\t                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n\t                // Note that this imposes a limitation on object keys one can use with Inspector.\n\t                // Pure integer keys will cause issues and are therefore not allowed.\n\t                var initializer = update;\n\t                var prevProperty = property;\n\n\t                for (var i = 1; i < pathArrayLength; i++) {\n\t                    var pathItem = pathArray[i];\n\t                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n\t                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n\t                    prevProperty = pathItem;\n\t                }\n\n\t                // Fill update with the `value` on `path`.\n\t                update = setByPath(update, pathArray, value, '/');\n\n\t                var baseAttributes = merge({}, this.attributes);\n\t                // if rewrite mode enabled, we replace value referenced by path with\n\t                // the new one (we don't merge).\n\t                opt.rewrite && unsetByPath(baseAttributes, path, '/');\n\n\t                // Merge update with the model attributes.\n\t                var attributes = merge(baseAttributes, update);\n\t                // Finally, set the property to the updated attributes.\n\t                return this.set(property, attributes[property], opt);\n\n\t            } else {\n\n\t                return getByPath(this.attributes, props, delim);\n\t            }\n\t        }\n\n\t        return this.set(merge({}, this.attributes, props), value);\n\t    },\n\n\t    // A convenient way to unset nested properties\n\t    removeProp: function(path, opt) {\n\n\t        opt = opt || {};\n\n\t        var pathArray = Array.isArray(path) ? path : path.split('/');\n\n\t        // Once a property is removed from the `attrs` attribute\n\t        // the cellView will recognize a `dirty` flag and re-render itself\n\t        // in order to remove the attribute from SVG element.\n\t        var property = pathArray[0];\n\t        if (property === 'attrs') { opt.dirty = true; }\n\n\t        if (pathArray.length === 1) {\n\t            // A top level property\n\t            return this.unset(path, opt);\n\t        }\n\n\t        // A nested property\n\t        var nestedPath = pathArray.slice(1);\n\t        var propertyValue = cloneDeep(this.get(property));\n\n\t        unsetByPath(propertyValue, nestedPath, '/');\n\n\t        return this.set(property, propertyValue, opt);\n\t    },\n\n\t    // A convenient way to set nested attributes.\n\t    attr: function(attrs, value, opt) {\n\n\t        var args = Array.from(arguments);\n\t        if (args.length === 0) {\n\t            return this.get('attrs');\n\t        }\n\n\t        if (Array.isArray(attrs)) {\n\t            args[0] = ['attrs'].concat(attrs);\n\t        } else if (isString(attrs)) {\n\t            // Get/set an attribute by a special path syntax that delimits\n\t            // nested objects by the colon character.\n\t            args[0] = 'attrs/' + attrs;\n\n\t        } else {\n\n\t            args[0] = { 'attrs' : attrs };\n\t        }\n\n\t        return this.prop.apply(this, args);\n\t    },\n\n\t    // A convenient way to unset nested attributes\n\t    removeAttr: function(path, opt) {\n\n\t        if (Array.isArray(path)) {\n\n\t            return this.removeProp(['attrs'].concat(path));\n\t        }\n\n\t        return this.removeProp('attrs/' + path, opt);\n\t    },\n\n\t    transition: function(path, value, opt, delim) {\n\n\t        delim = delim || '/';\n\n\t        var defaults = {\n\t            duration: 100,\n\t            delay: 10,\n\t            timingFunction: timing.linear,\n\t            valueFunction: interpolate.number\n\t        };\n\n\t        opt = assign(defaults, opt);\n\n\t        var firstFrameTime = 0;\n\t        var interpolatingFunction;\n\n\t        var setter = function(runtime) {\n\n\t            var id, progress, propertyValue;\n\n\t            firstFrameTime = firstFrameTime || runtime;\n\t            runtime -= firstFrameTime;\n\t            progress = runtime / opt.duration;\n\n\t            if (progress < 1) {\n\t                this._transitionIds[path] = id = nextFrame(setter);\n\t            } else {\n\t                progress = 1;\n\t                delete this._transitionIds[path];\n\t            }\n\n\t            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\n\t            opt.transitionId = id;\n\n\t            this.prop(path, propertyValue, opt);\n\n\t            if (!id) { this.trigger('transition:end', this, path); }\n\n\t        }.bind(this);\n\n\t        var initiator = function(callback) {\n\n\t            this.stopTransitions(path);\n\n\t            interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n\n\t            this._transitionIds[path] = nextFrame(callback);\n\n\t            this.trigger('transition:start', this, path);\n\n\t        }.bind(this);\n\n\t        return setTimeout(initiator, opt.delay, setter);\n\t    },\n\n\t    getTransitions: function() {\n\n\t        return Object.keys(this._transitionIds);\n\t    },\n\n\t    stopTransitions: function(path, delim) {\n\n\t        delim = delim || '/';\n\n\t        var pathArray = path && path.split(delim);\n\n\t        Object.keys(this._transitionIds).filter(pathArray && function(key) {\n\n\t            return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n\n\t        }).forEach(function(key) {\n\n\t            cancelFrame(this._transitionIds[key]);\n\n\t            delete this._transitionIds[key];\n\n\t            this.trigger('transition:end', this, key);\n\n\t        }, this);\n\n\t        return this;\n\t    },\n\n\t    // A shorcut making it easy to create constructs like the following:\n\t    // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\n\t    addTo: function(graph, opt) {\n\n\t        graph.addCell(this, opt);\n\t        return this;\n\t    },\n\n\t    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n\t    // making it easy to create constructs like the following:\n\t    // `cell.findView(paper).highlight()`\n\t    findView: function(paper) {\n\n\t        return paper.findViewByModel(this);\n\t    },\n\n\t    isElement: function() {\n\n\t        return false;\n\t    },\n\n\t    isLink: function() {\n\n\t        return false;\n\t    },\n\n\t    startBatch: function(name, opt) {\n\n\t        if (this.graph) { this.graph.startBatch(name, assign({}, opt, { cell: this })); }\n\t        return this;\n\t    },\n\n\t    stopBatch: function(name, opt) {\n\n\t        if (this.graph) { this.graph.stopBatch(name, assign({}, opt, { cell: this })); }\n\t        return this;\n\t    },\n\n\t    getChangeFlag: function(attributes) {\n\n\t        var flag = 0;\n\t        if (!attributes) { return flag; }\n\t        for (var key in attributes) {\n\t            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) { continue; }\n\t            flag |= attributes[key];\n\t        }\n\t        return flag;\n\t    },\n\n\t    angle: function() {\n\n\t        // To be overridden.\n\t        return 0;\n\t    },\n\n\t    position: function() {\n\n\t        // To be overridden.\n\t        return new Point(0, 0);\n\t    },\n\n\t    getPointFromConnectedLink: function() {\n\n\t        // To be overridden\n\t        return new Point();\n\t    },\n\n\t    getBBox: function() {\n\n\t        // To be overridden\n\t        return new Rect(0, 0, 0, 0);\n\t    }\n\n\t}, {\n\n\t    getAttributeDefinition: function(attrName) {\n\n\t        var defNS = this.attributes;\n\t        var globalDefNS = attributes;\n\t        return (defNS && defNS[attrName]) || globalDefNS[attrName];\n\t    },\n\n\t    define: function(type, defaults, protoProps, staticProps) {\n\n\t        protoProps = assign({\n\t            defaults: defaultsDeep({ type: type }, defaults, this.prototype.defaults)\n\t        }, protoProps);\n\n\t        var Cell = this.extend(protoProps, staticProps);\n\t        // es5 backward compatibility\n\t        /* global joint: true */\n\t        if (typeof joint !== 'undefined' && has$2(joint, 'shapes')) {\n\t            setByPath(joint.shapes, type, Cell, '.');\n\t        }\n\t        /* global joint: false */\n\t        return Cell;\n\t    }\n\t});\n\n\tvar wrapWith = function(object, methods, wrapper) {\n\n\t    if (isString(wrapper)) {\n\n\t        if (!wrappers[wrapper]) {\n\t            throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n\t        }\n\n\t        wrapper = wrappers[wrapper];\n\t    }\n\n\t    if (!isFunction(wrapper)) {\n\t        throw new Error('Wrapper must be a function.');\n\t    }\n\n\t    toArray(methods).forEach(function(method) {\n\t        object[method] = wrapper(object[method]);\n\t    });\n\t};\n\n\tvar wrappers = {\n\n\t    cells: function(fn) {\n\n\t        return function() {\n\n\t            var args = Array.from(arguments);\n\t            var n = args.length;\n\t            var cells = n > 0 && args[0] || [];\n\t            var opt = n > 1 && args[n - 1] || {};\n\n\t            if (!Array.isArray(cells)) {\n\n\t                if (opt instanceof Cell) {\n\t                    cells = args;\n\t                } else if (cells instanceof Cell) {\n\t                    if (args.length > 1) {\n\t                        args.pop();\n\t                    }\n\t                    cells = args;\n\t                }\n\t            }\n\n\t            if (opt instanceof Cell) {\n\t                opt = {};\n\t            }\n\n\t            return fn.call(this, cells, opt);\n\t        };\n\t    }\n\n\t};\n\n\n\n\tvar index = ({\n\t\twrapWith: wrapWith,\n\t\twrappers: wrappers,\n\t\taddClassNamePrefix: addClassNamePrefix,\n\t\tremoveClassNamePrefix: removeClassNamePrefix,\n\t\tparseDOMJSON: parseDOMJSON,\n\t\thashCode: hashCode,\n\t\tgetByPath: getByPath,\n\t\tsetByPath: setByPath,\n\t\tunsetByPath: unsetByPath,\n\t\tflattenObject: flattenObject,\n\t\tuuid: uuid,\n\t\tguid: guid,\n\t\ttoKebabCase: toKebabCase,\n\t\tnormalizeEvent: normalizeEvent,\n\t\tnextFrame: nextFrame,\n\t\tcancelFrame: cancelFrame,\n\t\tshapePerimeterConnectionPoint: shapePerimeterConnectionPoint,\n\t\tisPercentage: isPercentage,\n\t\tparseCssNumeric: parseCssNumeric,\n\t\tbreakText: breakText,\n\t\tsanitizeHTML: sanitizeHTML,\n\t\tdownloadBlob: downloadBlob,\n\t\tdownloadDataUri: downloadDataUri,\n\t\tdataUriToBlob: dataUriToBlob,\n\t\timageToDataUri: imageToDataUri,\n\t\tgetElementBBox: getElementBBox,\n\t\tsortElements: sortElements,\n\t\tsetAttributesBySelector: setAttributesBySelector,\n\t\tnormalizeSides: normalizeSides,\n\t\ttiming: timing,\n\t\tinterpolate: interpolate,\n\t\tfilter: filter,\n\t\tformat: format,\n\t\ttemplate: template,\n\t\ttoggleFullScreen: toggleFullScreen,\n\t\tmixin: mixin,\n\t\tsupplement: supplement,\n\t\tdeepMixin: deepMixin,\n\t\tdeepSupplement: deepSupplement,\n\t\tassign: assign,\n\t\tdefaults: defaults,\n\t\tdefaultsDeep: defaultsDeep,\n\t\tinvoke: invoke,\n\t\tsortedIndex: sortedIndex,\n\t\tuniq: uniq,\n\t\tclone: clone,\n\t\tcloneDeep: cloneDeep,\n\t\tisEmpty: isEmpty,\n\t\tisEqual: isEqual,\n\t\tisFunction: isFunction,\n\t\tisPlainObject: isPlainObject,\n\t\ttoArray: toArray,\n\t\tdebounce: debounce,\n\t\tgroupBy: groupBy,\n\t\tsortBy: sortBy,\n\t\tflattenDeep: flattenDeep,\n\t\twithout: without,\n\t\tdifference: difference,\n\t\tintersection: intersection,\n\t\tunion: union,\n\t\thas: has$2,\n\t\tresult: result,\n\t\tomit: omit,\n\t\tpick: pick,\n\t\tbindAll: bindAll,\n\t\tforIn: forIn,\n\t\tcamelCase: camelCase,\n\t\tuniqueId: uniqueId,\n\t\tmerge: merge,\n\t\tisBoolean: isBoolean,\n\t\tisObject: isObject$1,\n\t\tisNumber: isNumber,\n\t\tisString: isString,\n\t\tnoop: noop,\n\t\tcloneCells: cloneCells\n\t});\n\n\tfunction portTransformAttrs(point, angle, opt) {\n\n\t    var trans = point.toJSON();\n\n\t    trans.angle = angle || 0;\n\n\t    return defaults({}, opt, trans);\n\t}\n\n\tfunction lineLayout(ports, p1, p2) {\n\t    return ports.map(function(port, index, ports) {\n\t        var p = this.pointAt(((index + 0.5) / ports.length));\n\t        // `dx`,`dy` per port offset option\n\t        if (port.dx || port.dy) {\n\t            p.offset(port.dx || 0, port.dy || 0);\n\t        }\n\n\t        return portTransformAttrs(p.round(), 0, port);\n\t    }, line(p1, p2));\n\t}\n\n\tfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\n\t    var center = elBBox.center();\n\t    var ratio = elBBox.width / elBBox.height;\n\t    var p1 = elBBox.topMiddle();\n\n\t    var ellipse = Ellipse.fromRect(elBBox);\n\n\t    return ports.map(function(port, index, ports) {\n\n\t        var angle = startAngle + stepFn(index, ports.length);\n\t        var p2 = p1.clone()\n\t            .rotate(center, -angle)\n\t            .scale(ratio, 1, center);\n\n\t        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n\t        // `dx`,`dy` per port offset option\n\t        if (port.dx || port.dy) {\n\t            p2.offset(port.dx || 0, port.dy || 0);\n\t        }\n\n\t        // `dr` delta radius option\n\t        if (port.dr) {\n\t            p2.move(center, port.dr);\n\t        }\n\n\t        return portTransformAttrs(p2.round(), theta, port);\n\t    });\n\t}\n\n\t// Creates a point stored in arguments\n\tfunction argPoint(bbox, args) {\n\n\t    var x = args.x;\n\t    if (isString(x)) {\n\t        x = parseFloat(x) / 100 * bbox.width;\n\t    }\n\n\t    var y = args.y;\n\t    if (isString(y)) {\n\t        y = parseFloat(y) / 100 * bbox.height;\n\t    }\n\n\t    return point(x || 0, y || 0);\n\t}\n\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar absolute = function(ports, elBBox, opt) {\n\t    //TODO v.talas angle\n\t    return ports.map(argPoint.bind(null, elBBox));\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar fn = function(ports, elBBox, opt) {\n\t    return opt.fn(ports, elBBox, opt);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar line$1 = function(ports, elBBox, opt) {\n\n\t    var start = argPoint(elBBox, opt.start || elBBox.origin());\n\t    var end = argPoint(elBBox, opt.end || elBBox.corner());\n\n\t    return lineLayout(ports, start, end);\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar left = function(ports, elBBox, opt) {\n\t    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft());\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar right = function(ports, elBBox, opt) {\n\t    return lineLayout(ports, elBBox.topRight(), elBBox.corner());\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar top = function(ports, elBBox, opt) {\n\t    return lineLayout(ports, elBBox.origin(), elBBox.topRight());\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar bottom = function(ports, elBBox, opt) {\n\t    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner());\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar ellipseSpread = function(ports, elBBox, opt) {\n\n\t    var startAngle = opt.startAngle || 0;\n\t    var stepAngle = opt.step || 360 / ports.length;\n\n\t    return ellipseLayout(ports, elBBox, startAngle, function(index) {\n\t        return index * stepAngle;\n\t    });\n\t};\n\n\t/**\n\t * @param {Array<Object>} ports\n\t * @param {g.Rect} elBBox\n\t * @param {Object=} opt Group options\n\t * @returns {Array<g.Point>}\n\t */\n\tvar ellipse$1 = function(ports, elBBox, opt) {\n\n\t    var startAngle = opt.startAngle || 0;\n\t    var stepAngle = opt.step || 20;\n\n\t    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n\t        return (index + 0.5 - count / 2) * stepAngle;\n\t    });\n\t};\n\n\tvar Port = ({\n\t\tabsolute: absolute,\n\t\tfn: fn,\n\t\tline: line$1,\n\t\tleft: left,\n\t\tright: right,\n\t\ttop: top,\n\t\tbottom: bottom,\n\t\tellipseSpread: ellipseSpread,\n\t\tellipse: ellipse$1\n\t});\n\n\tfunction labelAttributes(opt1, opt2) {\n\n\t    return defaultsDeep({}, opt1, opt2, {\n\t        x: 0,\n\t        y: 0,\n\t        angle: 0,\n\t        attrs: {\n\t            '.': {\n\t                y: '0',\n\t                'text-anchor': 'start'\n\t            }\n\t        }\n\t    });\n\t}\n\n\tfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n\n\t    opt = defaults({}, opt, { offset: 15 });\n\t    var angle = elBBox.center().theta(portPosition);\n\t    var x = getBBoxAngles(elBBox);\n\n\t    var tx, ty, y, textAnchor;\n\t    var offset = opt.offset;\n\t    var orientAngle = 0;\n\n\t    if (angle < x[1] || angle > x[2]) {\n\t        y = '.3em';\n\t        tx = offset;\n\t        ty = 0;\n\t        textAnchor = 'start';\n\t    } else if (angle < x[0]) {\n\t        y = '0';\n\t        tx = 0;\n\t        ty = -offset;\n\t        if (autoOrient) {\n\t            orientAngle = -90;\n\t            textAnchor = 'start';\n\t        } else {\n\t            textAnchor = 'middle';\n\t        }\n\t    } else if (angle < x[3]) {\n\t        y = '.3em';\n\t        tx = -offset;\n\t        ty = 0;\n\t        textAnchor = 'end';\n\t    } else {\n\t        y = '.6em';\n\t        tx = 0;\n\t        ty = offset;\n\t        if (autoOrient) {\n\t            orientAngle = 90;\n\t            textAnchor = 'start';\n\t        } else {\n\t            textAnchor = 'middle';\n\t        }\n\t    }\n\n\t    var round = Math.round;\n\t    return labelAttributes({\n\t        x: round(tx),\n\t        y: round(ty),\n\t        angle: orientAngle,\n\t        attrs: {\n\t            '.': {\n\t                y: y,\n\t                'text-anchor': textAnchor\n\t            }\n\t        }\n\t    });\n\t}\n\n\tfunction getBBoxAngles(elBBox) {\n\n\t    var center = elBBox.center();\n\n\t    var tl = center.theta(elBBox.origin());\n\t    var bl = center.theta(elBBox.bottomLeft());\n\t    var br = center.theta(elBBox.corner());\n\t    var tr = center.theta(elBBox.topRight());\n\n\t    return [tl, tr, br, bl];\n\t}\n\n\tfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n\n\t    var angle = elBBox.center().theta(portPosition);\n\t    opt = defaults({}, opt, { offset: 15 });\n\n\t    var tx, ty, y, textAnchor;\n\t    var offset = opt.offset;\n\t    var orientAngle = 0;\n\n\t    var bBoxAngles = getBBoxAngles(elBBox);\n\n\t    if (angle < bBoxAngles[1] || angle > bBoxAngles[2]) {\n\t        y = '.3em';\n\t        tx = -offset;\n\t        ty = 0;\n\t        textAnchor = 'end';\n\t    } else if (angle < bBoxAngles[0]) {\n\t        y = '.6em';\n\t        tx = 0;\n\t        ty = offset;\n\t        if (autoOrient) {\n\t            orientAngle = 90;\n\t            textAnchor = 'start';\n\t        } else {\n\t            textAnchor = 'middle';\n\t        }\n\t    } else if (angle < bBoxAngles[3]) {\n\t        y = '.3em';\n\t        tx = offset;\n\t        ty = 0;\n\t        textAnchor = 'start';\n\t    } else {\n\t        y = '0em';\n\t        tx = 0;\n\t        ty = -offset;\n\t        if (autoOrient) {\n\t            orientAngle = -90;\n\t            textAnchor = 'start';\n\t        } else {\n\t            textAnchor = 'middle';\n\t        }\n\t    }\n\n\t    var round = Math.round;\n\t    return labelAttributes({\n\t        x: round(tx),\n\t        y: round(ty),\n\t        angle: orientAngle,\n\t        attrs: {\n\t            '.': {\n\t                y: y,\n\t                'text-anchor': textAnchor\n\t            }\n\t        }\n\t    });\n\t}\n\n\tfunction radialLayout(portCenterOffset, autoOrient, opt) {\n\n\t    opt = defaults({}, opt, { offset: 20 });\n\n\t    var origin = point(0, 0);\n\t    var angle = -portCenterOffset.theta(origin);\n\t    var orientAngle = angle;\n\t    var offset = portCenterOffset.clone()\n\t        .move(origin, opt.offset)\n\t        .difference(portCenterOffset)\n\t        .round();\n\n\t    var y = '.3em';\n\t    var textAnchor;\n\n\t    if ((angle + 90) % 180 === 0) {\n\t        textAnchor = autoOrient ? 'end' : 'middle';\n\t        if (!autoOrient && angle === -270) {\n\t            y = '0em';\n\t        }\n\t    } else if (angle > -270 && angle < -90) {\n\t        textAnchor = 'start';\n\t        orientAngle = angle - 180;\n\t    } else {\n\t        textAnchor = 'end';\n\t    }\n\n\t    var round = Math.round;\n\t    return labelAttributes({\n\t        x: round(offset.x),\n\t        y: round(offset.y),\n\t        angle: autoOrient ? orientAngle : 0,\n\t        attrs: {\n\t            '.': {\n\t                y: y,\n\t                'text-anchor': textAnchor\n\t            }\n\t        }\n\t    });\n\t}\n\n\tvar manual = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, elBBox);\n\t};\n\n\tvar left$1 = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, { x: -15, attrs: { '.': { y: '.3em', 'text-anchor': 'end' }}});\n\t};\n\n\tvar right$1 = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, { x: 15, attrs: { '.': { y: '.3em', 'text-anchor': 'start' }}});\n\t};\n\n\tvar top$1 = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, { y: -15, attrs: { '.': { 'text-anchor': 'middle' }}});\n\t};\n\n\tvar bottom$1 = function(portPosition, elBBox, opt) {\n\t    return labelAttributes(opt, { y: 15, attrs: { '.': { y: '.6em', 'text-anchor': 'middle' }}});\n\t};\n\n\tvar outsideOriented = function(portPosition, elBBox, opt) {\n\t    return outsideLayout(portPosition, elBBox, true, opt);\n\t};\n\n\tvar outside = function(portPosition, elBBox, opt) {\n\t    return outsideLayout(portPosition, elBBox, false, opt);\n\t};\n\n\tvar insideOriented = function(portPosition, elBBox, opt) {\n\t    return insideLayout(portPosition, elBBox, true, opt);\n\t};\n\n\tvar inside = function(portPosition, elBBox, opt) {\n\t    return insideLayout(portPosition, elBBox, false, opt);\n\t};\n\n\tvar radial = function(portPosition, elBBox, opt) {\n\t    return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n\t};\n\n\tvar radialOriented = function(portPosition, elBBox, opt) {\n\t    return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n\t};\n\n\tvar PortLabel = ({\n\t\tmanual: manual,\n\t\tleft: left$1,\n\t\tright: right$1,\n\t\ttop: top$1,\n\t\tbottom: bottom$1,\n\t\toutsideOriented: outsideOriented,\n\t\toutside: outside,\n\t\tinsideOriented: insideOriented,\n\t\tinside: inside,\n\t\tradial: radial,\n\t\tradialOriented: radialOriented\n\t});\n\n\t// Link base model.\n\t// --------------------------\n\n\tvar Link = Cell.extend({\n\n\t    // The default markup for links.\n\t    markup: [\n\t        '<path class=\"connection\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n\t        '<path class=\"marker-source\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n\t        '<path class=\"marker-target\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>',\n\t        '<path class=\"connection-wrap\" d=\"M 0 0 0 0\"/>',\n\t        '<g class=\"labels\"/>',\n\t        '<g class=\"marker-vertices\"/>',\n\t        '<g class=\"marker-arrowheads\"/>',\n\t        '<g class=\"link-tools\"/>'\n\t    ].join(''),\n\n\t    toolMarkup: [\n\t        '<g class=\"link-tool\">',\n\t        '<g class=\"tool-remove\" event=\"remove\">',\n\t        '<circle r=\"11\" />',\n\t        '<path transform=\"scale(.8) translate(-16, -16)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\" />',\n\t        '<title>Remove link.</title>',\n\t        '</g>',\n\t        '<g class=\"tool-options\" event=\"link:options\">',\n\t        '<circle r=\"11\" transform=\"translate(25)\"/>',\n\t        '<path fill=\"white\" transform=\"scale(.55) translate(29, -16)\" d=\"M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z\"/>',\n\t        '<title>Link options.</title>',\n\t        '</g>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    doubleToolMarkup: undefined,\n\n\t    // The default markup for showing/removing vertices. These elements are the children of the .marker-vertices element (see `this.markup`).\n\t    // Only .marker-vertex and .marker-vertex-remove element have special meaning. The former is used for\n\t    // dragging vertices (changing their position). The latter is used for removing vertices.\n\t    vertexMarkup: [\n\t        '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\n\t        '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\n\t        '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\n\t        '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\n\t        '<title>Remove vertex.</title>',\n\t        '</path>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    arrowheadMarkup: [\n\t        '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\n\t        '<path class=\"marker-arrowhead\" end=\"<%= end %>\" d=\"M 26 0 L 0 13 L 26 26 z\" />',\n\t        '</g>'\n\t    ].join(''),\n\n\t    // may be overwritten by user to change default label (its markup, attrs, position)\n\t    defaultLabel: undefined,\n\n\t    // deprecated\n\t    // may be overwritten by user to change default label markup\n\t    // lower priority than defaultLabel.markup\n\t    labelMarkup: undefined,\n\n\t    // private\n\t    _builtins: {\n\t        defaultLabel: {\n\t            // builtin default markup:\n\t            // used if neither defaultLabel.markup\n\t            // nor label.markup is set\n\t            markup: [\n\t                {\n\t                    tagName: 'rect',\n\t                    selector: 'rect' // faster than tagName CSS selector\n\t                }, {\n\t                    tagName: 'text',\n\t                    selector: 'text' // faster than tagName CSS selector\n\t                }\n\t            ],\n\t            // builtin default attributes:\n\t            // applied only if builtin default markup is used\n\t            attrs: {\n\t                text: {\n\t                    fill: '#000000',\n\t                    fontSize: 14,\n\t                    textAnchor: 'middle',\n\t                    yAlignment: 'middle',\n\t                    pointerEvents: 'none'\n\t                },\n\t                rect: {\n\t                    ref: 'text',\n\t                    fill: '#ffffff',\n\t                    rx: 3,\n\t                    ry: 3,\n\t                    refWidth: 1,\n\t                    refHeight: 1,\n\t                    refX: 0,\n\t                    refY: 0\n\t                }\n\t            },\n\t            // builtin default position:\n\t            // used if neither defaultLabel.position\n\t            // nor label.position is set\n\t            position: {\n\t                distance: 0.5\n\t            }\n\t        }\n\t    },\n\n\t    defaults: {\n\t        type: 'link',\n\t        source: {},\n\t        target: {}\n\t    },\n\n\t    isLink: function() {\n\n\t        return true;\n\t    },\n\n\t    disconnect: function(opt) {\n\n\t        return this.set({\n\t            source: { x: 0, y: 0 },\n\t            target: { x: 0, y: 0 }\n\t        }, opt);\n\t    },\n\n\t    source: function(source, args, opt) {\n\n\t        // getter\n\t        if (source === undefined) {\n\t            return clone(this.get('source'));\n\t        }\n\n\t        // setter\n\t        var setSource;\n\t        var setOpt;\n\n\t        // `source` is a cell\n\t        // take only its `id` and combine with `args`\n\t        var isCellProvided = source instanceof Cell;\n\t        if (isCellProvided) { // three arguments\n\t            setSource = clone(args) || {};\n\t            setSource.id = source.id;\n\t            setOpt = opt;\n\t            return this.set('source', setSource, setOpt);\n\t        }\n\n\t        // `source` is a point-like object\n\t        // for example, a g.Point\n\t        // take only its `x` and `y` and combine with `args`\n\t        var isPointProvided = !isPlainObject(source);\n\t        if (isPointProvided) { // three arguments\n\t            setSource = clone(args) || {};\n\t            setSource.x = source.x;\n\t            setSource.y = source.y;\n\t            setOpt = opt;\n\t            return this.set('source', setSource, setOpt);\n\t        }\n\n\t        // `source` is an object\n\t        // no checking\n\t        // two arguments\n\t        setSource = source;\n\t        setOpt = args;\n\t        return this.set('source', setSource, setOpt);\n\t    },\n\n\t    target: function(target, args, opt) {\n\n\t        // getter\n\t        if (target === undefined) {\n\t            return clone(this.get('target'));\n\t        }\n\n\t        // setter\n\t        var setTarget;\n\t        var setOpt;\n\n\t        // `target` is a cell\n\t        // take only its `id` argument and combine with `args`\n\t        var isCellProvided = target instanceof Cell;\n\t        if (isCellProvided) { // three arguments\n\t            setTarget = clone(args) || {};\n\t            setTarget.id = target.id;\n\t            setOpt = opt;\n\t            return this.set('target', setTarget, setOpt);\n\t        }\n\n\t        // `target` is a point-like object\n\t        // for example, a g.Point\n\t        // take only its `x` and `y` and combine with `args`\n\t        var isPointProvided = !isPlainObject(target);\n\t        if (isPointProvided) { // three arguments\n\t            setTarget = clone(args) || {};\n\t            setTarget.x = target.x;\n\t            setTarget.y = target.y;\n\t            setOpt = opt;\n\t            return this.set('target', setTarget, setOpt);\n\t        }\n\n\t        // `target` is an object\n\t        // no checking\n\t        // two arguments\n\t        setTarget = target;\n\t        setOpt = args;\n\t        return this.set('target', setTarget, setOpt);\n\t    },\n\n\t    router: function(name, args, opt) {\n\n\t        // getter\n\t        if (name === undefined) {\n\t            var router = this.get('router');\n\t            if (!router) {\n\t                if (this.get('manhattan')) { return { name: 'orthogonal' }; } // backwards compatibility\n\t                return null;\n\t            }\n\t            if (typeof router === 'object') { return clone(router); }\n\t            return router; // e.g. a function\n\t        }\n\n\t        // setter\n\t        var isRouterProvided = ((typeof name === 'object') || (typeof name === 'function'));\n\t        var localRouter = isRouterProvided ? name : { name: name, args: args };\n\t        var localOpt = isRouterProvided ? args : opt;\n\n\t        return this.set('router', localRouter, localOpt);\n\t    },\n\n\t    connector: function(name, args, opt) {\n\n\t        // getter\n\t        if (name === undefined) {\n\t            var connector = this.get('connector');\n\t            if (!connector) {\n\t                if (this.get('smooth')) { return { name: 'smooth' }; } // backwards compatibility\n\t                return null;\n\t            }\n\t            if (typeof connector === 'object') { return clone(connector); }\n\t            return connector; // e.g. a function\n\t        }\n\n\t        // setter\n\t        var isConnectorProvided = ((typeof name === 'object' || typeof name === 'function'));\n\t        var localConnector = isConnectorProvided ? name : { name: name, args: args };\n\t        var localOpt = isConnectorProvided ? args : opt;\n\n\t        return this.set('connector', localConnector, localOpt);\n\t    },\n\n\t    // Labels API\n\n\t    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n\t    label: function(idx, label, opt) {\n\n\t        var labels = this.labels();\n\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n\t        if (idx < 0) { idx = labels.length + idx; }\n\n\t        // getter\n\t        if (arguments.length <= 1) { return this.prop(['labels', idx]); }\n\t        // setter\n\t        return this.prop(['labels', idx], label, opt);\n\t    },\n\n\t    labels: function(labels, opt) {\n\n\t        // getter\n\t        if (arguments.length === 0) {\n\t            labels = this.get('labels');\n\t            if (!Array.isArray(labels)) { return []; }\n\t            return labels.slice();\n\t        }\n\t        // setter\n\t        if (!Array.isArray(labels)) { labels = []; }\n\t        return this.set('labels', labels, opt);\n\t    },\n\n\t    insertLabel: function(idx, label, opt) {\n\n\t        if (!label) { throw new Error('dia.Link: no label provided'); }\n\n\t        var labels = this.labels();\n\t        var n = labels.length;\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n\t        if (idx < 0) { idx = n + idx + 1; }\n\n\t        labels.splice(idx, 0, label);\n\t        return this.labels(labels, opt);\n\t    },\n\n\t    // convenience function\n\t    // add label to end of labels array\n\t    appendLabel: function(label, opt) {\n\n\t        return this.insertLabel(-1, label, opt);\n\t    },\n\n\t    removeLabel: function(idx, opt) {\n\n\t        var labels = this.labels();\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n\t        labels.splice(idx, 1);\n\t        return this.labels(labels, opt);\n\t    },\n\n\t    // Vertices API\n\n\t    vertex: function(idx, vertex, opt) {\n\n\t        var vertices = this.vertices();\n\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n\t        if (idx < 0) { idx = vertices.length + idx; }\n\n\t        // getter\n\t        if (arguments.length <= 1) { return this.prop(['vertices', idx]); }\n\n\t        // setter\n\t        var setVertex = this._normalizeVertex(vertex);\n\t        return this.prop(['vertices', idx], setVertex, opt);\n\t    },\n\n\t    vertices: function(vertices, opt) {\n\n\t        // getter\n\t        if (arguments.length === 0) {\n\t            vertices = this.get('vertices');\n\t            if (!Array.isArray(vertices)) { return []; }\n\t            return vertices.slice();\n\t        }\n\n\t        // setter\n\t        if (!Array.isArray(vertices)) { vertices = []; }\n\t        var setVertices = [];\n\t        for (var i = 0; i < vertices.length; i++) {\n\t            var vertex = vertices[i];\n\t            var setVertex = this._normalizeVertex(vertex);\n\t            setVertices.push(setVertex);\n\t        }\n\t        return this.set('vertices', setVertices, opt);\n\t    },\n\n\t    insertVertex: function(idx, vertex, opt) {\n\n\t        if (!vertex) { throw new Error('dia.Link: no vertex provided'); }\n\n\t        var vertices = this.vertices();\n\t        var n = vertices.length;\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n\t        if (idx < 0) { idx = n + idx + 1; }\n\n\t        var setVertex = this._normalizeVertex(vertex);\n\t        vertices.splice(idx, 0, setVertex);\n\t        return this.vertices(vertices, opt);\n\t    },\n\n\t    removeVertex: function(idx, opt) {\n\n\t        var vertices = this.vertices();\n\t        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n\t        vertices.splice(idx, 1);\n\t        return this.vertices(vertices, opt);\n\t    },\n\n\t    _normalizeVertex: function(vertex) {\n\n\t        // is vertex a point-like object?\n\t        // for example, a g.Point\n\t        var isPointProvided = !isPlainObject(vertex);\n\t        if (isPointProvided) { return { x: vertex.x, y: vertex.y }; }\n\n\t        // else: return vertex unchanged\n\t        return vertex;\n\t    },\n\n\t    // Transformations\n\n\t    translate: function(tx, ty, opt) {\n\n\t        // enrich the option object\n\t        opt = opt || {};\n\t        opt.translateBy = opt.translateBy || this.id;\n\t        opt.tx = tx;\n\t        opt.ty = ty;\n\n\t        return this.applyToPoints(function(p) {\n\t            return { x: (p.x || 0) + tx, y: (p.y || 0) + ty };\n\t        }, opt);\n\t    },\n\n\t    scale: function(sx, sy, origin, opt) {\n\n\t        return this.applyToPoints(function(p) {\n\t            return Point(p).scale(sx, sy, origin).toJSON();\n\t        }, opt);\n\t    },\n\n\t    applyToPoints: function(fn, opt) {\n\n\t        if (!isFunction(fn)) {\n\t            throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');\n\t        }\n\n\t        var attrs = {};\n\n\t        var ref = this.attributes;\n\t        var source = ref.source;\n\t        var target = ref.target;\n\t        if (!source.id) {\n\t            attrs.source = fn(source);\n\t        }\n\t        if (!target.id) {\n\t            attrs.target = fn(target);\n\t        }\n\n\t        var vertices = this.vertices();\n\t        if (vertices.length > 0) {\n\t            attrs.vertices = vertices.map(fn);\n\t        }\n\n\t        return this.set(attrs, opt);\n\t    },\n\n\t    getSourcePoint: function() {\n\t        var sourceCell = this.getSourceCell();\n\t        if (!sourceCell) { return new Point(this.source()); }\n\t        return sourceCell.getPointFromConnectedLink(this, 'source');\n\t    },\n\n\t    getTargetPoint: function() {\n\t        var targetCell = this.getTargetCell();\n\t        if (!targetCell) { return new Point(this.target()); }\n\t        return targetCell.getPointFromConnectedLink(this, 'target');\n\t    },\n\n\t    getPointFromConnectedLink: function(/* link, endType */) {\n\t        return this.getPolyline().pointAt(0.5);\n\t    },\n\n\t    getPolyline: function() {\n\t        var points = [\n\t            this.getSourcePoint() ].concat( this.vertices().map(Point),\n\t            [this.getTargetPoint()]\n\t        );\n\t        return new Polyline(points);\n\t    },\n\n\t    getBBox: function() {\n\t        return this.getPolyline().bbox();\n\t    },\n\n\t    reparent: function(opt) {\n\n\t        var newParent;\n\n\t        if (this.graph) {\n\n\t            var source = this.getSourceElement();\n\t            var target = this.getTargetElement();\n\t            var prevParent = this.getParentCell();\n\n\t            if (source && target) {\n\t                if (source === target || source.isEmbeddedIn(target)) {\n\t                    newParent = target;\n\t                } else if (target.isEmbeddedIn(source)) {\n\t                    newParent = source;\n\t                } else {\n\t                    newParent = this.graph.getCommonAncestor(source, target);\n\t                }\n\t            }\n\n\t            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n\t                // Unembed the link if source and target has no common ancestor\n\t                // or common ancestor changed\n\t                prevParent.unembed(this, opt);\n\t            }\n\n\t            if (newParent) {\n\t                newParent.embed(this, opt);\n\t            }\n\t        }\n\n\t        return newParent;\n\t    },\n\n\t    hasLoop: function(opt) {\n\n\t        opt = opt || {};\n\n\t        var ref = this.attributes;\n\t        var source = ref.source;\n\t        var target = ref.target;\n\t        var sourceId = source.id;\n\t        var targetId = target.id;\n\n\t        if (!sourceId || !targetId) {\n\t            // Link \"pinned\" to the paper does not have a loop.\n\t            return false;\n\t        }\n\n\t        var loop = sourceId === targetId;\n\n\t        // Note that there in the deep mode a link can have a loop,\n\t        // even if it connects only a parent and its embed.\n\t        // A loop \"target equals source\" is valid in both shallow and deep mode.\n\t        if (!loop && opt.deep && this.graph) {\n\n\t            var sourceElement = this.getSourceCell();\n\t            var targetElement = this.getTargetCell();\n\n\t            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n\t        }\n\n\t        return loop;\n\t    },\n\n\t    // unlike source(), this method returns null if source is a point\n\t    getSourceCell: function() {\n\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        var attributes = ref.attributes;\n\t        var source = attributes.source;\n\t        return (source && source.id && graph && graph.getCell(source.id)) || null;\n\t    },\n\n\t    getSourceElement: function() {\n\t        var cell = this;\n\t        var visited = {};\n\t        do {\n\t            if (visited[cell.id]) { return null; }\n\t            visited[cell.id] = true;\n\t            cell = cell.getSourceCell();\n\t        } while (cell && cell.isLink());\n\t        return cell;\n\t    },\n\n\t    // unlike target(), this method returns null if target is a point\n\t    getTargetCell: function() {\n\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        var attributes = ref.attributes;\n\t        var target = attributes.target;\n\t        return (target && target.id && graph && graph.getCell(target.id)) || null;\n\t    },\n\n\t    getTargetElement: function() {\n\t        var cell = this;\n\t        var visited = {};\n\t        do {\n\t            if (visited[cell.id]) { return null; }\n\t            visited[cell.id] = true;\n\t            cell = cell.getTargetCell();\n\t        } while (cell && cell.isLink());\n\t        return cell;\n\t    },\n\n\t    // Returns the common ancestor for the source element,\n\t    // target element and the link itself.\n\t    getRelationshipAncestor: function() {\n\n\t        var connectionAncestor;\n\n\t        if (this.graph) {\n\n\t            var cells = [\n\t                this,\n\t                this.getSourceElement(), // null if source is a point\n\t                this.getTargetElement() // null if target is a point\n\t            ].filter(function(item) {\n\t                return !!item;\n\t            });\n\n\t            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n\t        }\n\n\t        return connectionAncestor || null;\n\t    },\n\n\t    // Is source, target and the link itself embedded in a given cell?\n\t    isRelationshipEmbeddedIn: function(cell) {\n\n\t        var cellId = (isString(cell) || isNumber(cell)) ? cell : cell.id;\n\t        var ancestor = this.getRelationshipAncestor();\n\n\t        return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n\t    },\n\n\t    // Get resolved default label.\n\t    _getDefaultLabel: function() {\n\n\t        var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};\n\n\t        var label = {};\n\t        label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;\n\t        label.position = defaultLabel.position;\n\t        label.attrs = defaultLabel.attrs;\n\t        label.size = defaultLabel.size;\n\n\t        return label;\n\t    }\n\t}, {\n\n\t    endsEqual: function(a, b) {\n\n\t        var portsEqual = a.port === b.port || !a.port && !b.port;\n\t        return a.id === b.id && portsEqual;\n\t    }\n\t});\n\n\tvar PortData = function(data) {\n\n\t    var clonedData = cloneDeep(data) || {};\n\t    this.ports = [];\n\t    this.groups = {};\n\t    this.portLayoutNamespace = Port;\n\t    this.portLabelLayoutNamespace = PortLabel;\n\n\t    this._init(clonedData);\n\t};\n\n\tPortData.prototype = {\n\n\t    getPorts: function() {\n\t        return this.ports;\n\t    },\n\n\t    getGroup: function(name) {\n\t        return this.groups[name] || {};\n\t    },\n\n\t    getPortsByGroup: function(groupName) {\n\n\t        return this.ports.filter(function(port) {\n\t            return port.group === groupName;\n\t        });\n\t    },\n\n\t    getGroupPortsMetrics: function(groupName, elBBox) {\n\n\t        var group = this.getGroup(groupName);\n\t        var ports = this.getPortsByGroup(groupName);\n\n\t        var groupPosition = group.position || {};\n\t        var groupPositionName = groupPosition.name;\n\t        var namespace = this.portLayoutNamespace;\n\t        if (!namespace[groupPositionName]) {\n\t            groupPositionName = 'left';\n\t        }\n\n\t        var groupArgs = groupPosition.args || {};\n\t        var portsArgs = ports.map(function(port) {\n\t            return port && port.position && port.position.args;\n\t        });\n\t        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n\n\t        var accumulator = {\n\t            ports: ports,\n\t            result: []\n\t        };\n\n\t        toArray(groupPortTransformations).reduce(function(res, portTransformation, index) {\n\t            var port = res.ports[index];\n\t            res.result.push({\n\t                portId: port.id,\n\t                portTransformation: portTransformation,\n\t                labelTransformation: this._getPortLabelLayout(port, Point(portTransformation), elBBox),\n\t                portAttrs: port.attrs,\n\t                portSize: port.size,\n\t                labelSize: port.label.size\n\t            });\n\t            return res;\n\t        }.bind(this), accumulator);\n\n\t        return accumulator.result;\n\t    },\n\n\t    _getPortLabelLayout: function(port, portPosition, elBBox) {\n\n\t        var namespace = this.portLabelLayoutNamespace;\n\t        var labelPosition = port.label.position.name || 'left';\n\n\t        if (namespace[labelPosition]) {\n\t            return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n\t        }\n\n\t        return null;\n\t    },\n\n\t    _init: function(data) {\n\n\t        // prepare groups\n\t        if (isObject$1(data.groups)) {\n\t            var groups = Object.keys(data.groups);\n\t            for (var i = 0, n = groups.length; i < n; i++) {\n\t                var key = groups[i];\n\t                this.groups[key] = this._evaluateGroup(data.groups[key]);\n\t            }\n\t        }\n\n\t        // prepare ports\n\t        var ports = toArray(data.items);\n\t        for (var j = 0, m = ports.length; j < m; j++) {\n\t            this.ports.push(this._evaluatePort(ports[j]));\n\t        }\n\t    },\n\n\t    _evaluateGroup: function(group) {\n\n\t        return merge(group, {\n\t            position: this._getPosition(group.position, true),\n\t            label: this._getLabel(group, true)\n\t        });\n\t    },\n\n\t    _evaluatePort: function(port) {\n\n\t        var evaluated = assign({}, port);\n\n\t        var group = this.getGroup(port.group);\n\n\t        evaluated.markup = evaluated.markup || group.markup;\n\t        evaluated.attrs = merge({}, group.attrs, evaluated.attrs);\n\t        evaluated.position = this._createPositionNode(group, evaluated);\n\t        evaluated.label = merge({}, group.label, this._getLabel(evaluated));\n\t        evaluated.z = this._getZIndex(group, evaluated);\n\t        evaluated.size = assign({}, group.size, evaluated.size);\n\n\t        return evaluated;\n\t    },\n\n\t    _getZIndex: function(group, port) {\n\n\t        if (isNumber(port.z)) {\n\t            return port.z;\n\t        }\n\t        if (isNumber(group.z) || group.z === 'auto') {\n\t            return group.z;\n\t        }\n\t        return 'auto';\n\t    },\n\n\t    _createPositionNode: function(group, port) {\n\n\t        return merge({\n\t            name: 'left',\n\t            args: {}\n\t        }, group.position, { args: port.args });\n\t    },\n\n\t    _getPosition: function(position, setDefault) {\n\n\t        var args = {};\n\t        var positionName;\n\n\t        if (isFunction(position)) {\n\t            positionName = 'fn';\n\t            args.fn = position;\n\t        } else if (isString(position)) {\n\t            positionName = position;\n\t        } else if (position === undefined) {\n\t            positionName = setDefault ? 'left' : null;\n\t        } else if (Array.isArray(position)) {\n\t            positionName = 'absolute';\n\t            args.x = position[0];\n\t            args.y = position[1];\n\t        } else if (isObject$1(position)) {\n\t            positionName = position.name;\n\t            assign(args, position.args);\n\t        }\n\n\t        var result = { args: args };\n\n\t        if (positionName) {\n\t            result.name = positionName;\n\t        }\n\t        return result;\n\t    },\n\n\t    _getLabel: function(item, setDefaults) {\n\n\t        var label = item.label || {};\n\n\t        var ret = label;\n\t        ret.position = this._getPosition(label.position, setDefaults);\n\n\t        return ret;\n\t    }\n\t};\n\n\tvar elementPortPrototype = {\n\n\t    _initializePorts: function() {\n\n\t        this._createPortData();\n\t        this.on('change:ports', function() {\n\n\t            this._processRemovedPort();\n\t            this._createPortData();\n\t        }, this);\n\t    },\n\n\t    /**\n\t     * remove links tied wiht just removed element\n\t     * @private\n\t     */\n\t    _processRemovedPort: function() {\n\n\t        var current = this.get('ports') || {};\n\t        var currentItemsMap = {};\n\n\t        toArray(current.items).forEach(function(item) {\n\t            currentItemsMap[item.id] = true;\n\t        });\n\n\t        var previous = this.previous('ports') || {};\n\t        var removed = {};\n\n\t        toArray(previous.items).forEach(function(item) {\n\t            if (!currentItemsMap[item.id]) {\n\t                removed[item.id] = true;\n\t            }\n\t        });\n\n\t        var graph = this.graph;\n\t        if (graph && !isEmpty(removed)) {\n\n\t            var inboundLinks = graph.getConnectedLinks(this, { inbound: true });\n\t            inboundLinks.forEach(function(link) {\n\n\t                if (removed[link.get('target').port]) { link.remove(); }\n\t            });\n\n\t            var outboundLinks = graph.getConnectedLinks(this, { outbound: true });\n\t            outboundLinks.forEach(function(link) {\n\n\t                if (removed[link.get('source').port]) { link.remove(); }\n\t            });\n\t        }\n\t    },\n\n\t    /**\n\t     * @returns {boolean}\n\t     */\n\t    hasPorts: function() {\n\n\t        var ports = this.prop('ports/items');\n\t        return Array.isArray(ports) && ports.length > 0;\n\t    },\n\n\t    /**\n\t     * @param {string} id\n\t     * @returns {boolean}\n\t     */\n\t    hasPort: function(id) {\n\n\t        return this.getPortIndex(id) !== -1;\n\t    },\n\n\t    /**\n\t     * @returns {Array<object>}\n\t     */\n\t    getPorts: function() {\n\n\t        return cloneDeep(this.prop('ports/items')) || [];\n\t    },\n\n\t    /**\n\t     * @returns {Array<object>}\n\t     */\n\t    getGroupPorts: function(groupName) {\n\t        var groupPorts = toArray(this.prop(['ports','items'])).filter(function (port) { return port.group === groupName; });\n\t        return cloneDeep(groupPorts);\n\t    },\n\n\t    /**\n\t     * @param {string} id\n\t     * @returns {object}\n\t     */\n\t    getPort: function(id) {\n\n\t        return cloneDeep(toArray(this.prop('ports/items')).find(function(port) {\n\t            return port.id && port.id === id;\n\t        }));\n\t    },\n\n\t    /**\n\t     * @param {string} groupName\n\t     * @returns {Object<portId, {x: number, y: number, angle: number}>}\n\t     */\n\t    getPortsPositions: function(groupName) {\n\n\t        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, Rect(this.size()));\n\n\t        return portsMetrics.reduce(function(positions, metrics) {\n\t            var transformation = metrics.portTransformation;\n\t            positions[metrics.portId] = {\n\t                x: transformation.x,\n\t                y: transformation.y,\n\t                angle: transformation.angle\n\t            };\n\t            return positions;\n\t        }, {});\n\t    },\n\n\t    /**\n\t     * @param {string|Port} port port id or port\n\t     * @returns {number} port index\n\t     */\n\t    getPortIndex: function(port) {\n\n\t        var id = isObject$1(port) ? port.id : port;\n\n\t        if (!this._isValidPortId(id)) {\n\t            return -1;\n\t        }\n\n\t        return toArray(this.prop('ports/items')).findIndex(function(item) {\n\t            return item.id === id;\n\t        });\n\t    },\n\n\t    /**\n\t     * @param {object} port\n\t     * @param {object} [opt]\n\t     * @returns {joint.dia.Element}\n\t     */\n\t    addPort: function(port, opt) {\n\n\t        if (!isObject$1(port) || Array.isArray(port)) {\n\t            throw new Error('Element: addPort requires an object.');\n\t        }\n\n\t        var ports = assign([], this.prop('ports/items'));\n\t        ports.push(port);\n\t        this.prop('ports/items', ports, opt);\n\n\t        return this;\n\t    },\n\n\t    /**\n\t     * @param {string|Port|number} before\n\t     * @param {object} port\n\t     * @param {object} [opt]\n\t     * @returns {joint.dia.Element}\n\t     */\n\t    insertPort: function(before, port, opt) {\n\t        var index$1 = (typeof before === 'number') ? before : this.getPortIndex(before);\n\n\t        if (!isObject$1(port) || Array.isArray(port)) {\n\t            throw new Error('dia.Element: insertPort requires an object.');\n\t        }\n\n\t        var ports = assign([], this.prop('ports/items'));\n\t        ports.splice(index$1, 0, port);\n\t        this.prop('ports/items', ports, opt);\n\n\t        return this;\n\t    },\n\n\t    /**\n\t     * @param {string} portId\n\t     * @param {string|object=} path\n\t     * @param {*=} value\n\t     * @param {object=} opt\n\t     * @returns {joint.dia.Element}\n\t     */\n\t    portProp: function(portId, path, value, opt) {\n\n\t        var index$1 = this.getPortIndex(portId);\n\n\t        if (index$1 === -1) {\n\t            throw new Error('Element: unable to find port with id ' + portId);\n\t        }\n\n\t        var args = Array.prototype.slice.call(arguments, 1);\n\t        if (Array.isArray(path)) {\n\t            args[0] = ['ports', 'items', index$1].concat(path);\n\t        } else if (isString(path)) {\n\n\t            // Get/set an attribute by a special path syntax that delimits\n\t            // nested objects by the colon character.\n\t            args[0] = ['ports/items/', index$1, '/', path].join('');\n\n\t        } else {\n\n\t            args = ['ports/items/' + index$1];\n\t            if (isPlainObject(path)) {\n\t                args.push(path);\n\t                args.push(value);\n\t            }\n\t        }\n\n\t        return this.prop.apply(this, args);\n\t    },\n\n\t    _validatePorts: function() {\n\n\t        var portsAttr = this.get('ports') || {};\n\n\t        var errorMessages = [];\n\t        portsAttr = portsAttr || {};\n\t        var ports = toArray(portsAttr.items);\n\n\t        ports.forEach(function(p) {\n\n\t            if (typeof p !== 'object') {\n\t                errorMessages.push('Element: invalid port ', p);\n\t            }\n\n\t            if (!this._isValidPortId(p.id)) {\n\t                p.id = this.generatePortId();\n\t            }\n\t        }, this);\n\n\t        if (uniq(ports, 'id').length !== ports.length) {\n\t            errorMessages.push('Element: found id duplicities in ports.');\n\t        }\n\n\t        return errorMessages;\n\t    },\n\n\t    generatePortId: function() {\n\t        return this.generateId();\n\t    },\n\n\t    /**\n\t     * @param {string} id port id\n\t     * @returns {boolean}\n\t     * @private\n\t     */\n\t    _isValidPortId: function(id) {\n\n\t        return id !== null && id !== undefined && !isObject$1(id);\n\t    },\n\n\t    addPorts: function(ports, opt) {\n\n\t        if (ports.length) {\n\t            this.prop('ports/items', assign([], this.prop('ports/items')).concat(ports), opt);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    removePort: function(port, opt) {\n\t        var options = opt || {};\n\t        var index$1 = this.getPortIndex(port);\n\t        if (index$1 !== -1) {\n\t            var ports = assign([], this.prop(['ports', 'items']));\n\t            ports.splice(index$1, 1);\n\t            options.rewrite = true;\n\t            this.startBatch('port-remove');\n\t            this.prop(['ports', 'items'], ports, options);\n\t            this.stopBatch('port-remove');\n\t        }\n\t        return this;\n\t    },\n\n\t    removePorts: function(portsForRemoval, opt) {\n\t        var options, newPorts;\n\t        if (Array.isArray(portsForRemoval)) {\n\t            options = opt || {};\n\t            if (portsForRemoval.length === 0) { return this.this; }\n\t            var currentPorts = assign([], this.prop(['ports', 'items']));\n\t            newPorts = currentPorts.filter(function(cp) {\n\t                return !portsForRemoval.some(function(rp) {\n\t                    var rpId = isObject$1(rp) ? rp.id : rp;\n\t                    return cp.id === rpId;\n\t                });\n\t            });\n\t        } else {\n\t            options = portsForRemoval || {};\n\t            newPorts = [];\n\t        }\n\t        this.startBatch('port-remove');\n\t        options.rewrite = true;\n\t        this.prop(['ports', 'items'], newPorts, options);\n\t        this.stopBatch('port-remove');\n\t        return this;\n\t    },\n\n\t    /**\n\t     * @private\n\t     */\n\t    _createPortData: function() {\n\n\t        var err = this._validatePorts();\n\n\t        if (err.length > 0) {\n\t            this.set('ports', this.previous('ports'));\n\t            throw new Error(err.join(' '));\n\t        }\n\n\t        var prevPortData;\n\n\t        if (this._portSettingsData) {\n\n\t            prevPortData = this._portSettingsData.getPorts();\n\t        }\n\n\t        this._portSettingsData = new PortData(this.get('ports'));\n\n\t        var curPortData = this._portSettingsData.getPorts();\n\n\t        if (prevPortData) {\n\n\t            var added = curPortData.filter(function(item) {\n\t                if (!prevPortData.find(function(prevPort) {\n\t                    return prevPort.id === item.id;\n\t                })) {\n\t                    return item;\n\t                }\n\t            });\n\n\t            var removed = prevPortData.filter(function(item) {\n\t                if (!curPortData.find(function(curPort) {\n\t                    return curPort.id === item.id;\n\t                })) {\n\t                    return item;\n\t                }\n\t            });\n\n\t            if (removed.length > 0) {\n\t                this.trigger('ports:remove', this, removed);\n\t            }\n\n\t            if (added.length > 0) {\n\t                this.trigger('ports:add', this, added);\n\t            }\n\t        }\n\t    }\n\t};\n\n\tvar elementViewPortPrototype = {\n\n\t    portContainerMarkup: 'g',\n\t    portMarkup: [{\n\t        tagName: 'circle',\n\t        selector: 'circle',\n\t        attributes: {\n\t            'r': 10,\n\t            'fill': '#FFFFFF',\n\t            'stroke': '#000000'\n\t        }\n\t    }],\n\t    portLabelMarkup: [{\n\t        tagName: 'text',\n\t        selector: 'text',\n\t        attributes: {\n\t            'fill': '#000000'\n\t        }\n\t    }],\n\t    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n\t    _portElementsCache: null,\n\n\t    /**\n\t     * @private\n\t     */\n\t    _initializePorts: function() {\n\t        this._cleanPortsCache();\n\t    },\n\n\t    /**\n\t     * @typedef {Object} Port\n\t     *\n\t     * @property {string} id\n\t     * @property {Object} position\n\t     * @property {Object} label\n\t     * @property {Object} attrs\n\t     * @property {string} markup\n\t     * @property {string} group\n\t     */\n\n\t    /**\n\t     * @private\n\t     */\n\t    _refreshPorts: function() {\n\n\t        this._removePorts();\n\t        this._cleanPortsCache();\n\t        this._renderPorts();\n\t    },\n\n\t    _cleanPortsCache: function() {\n\t        this._portElementsCache = {};\n\t    },\n\n\t    /**\n\t     * @private\n\t     */\n\t    _renderPorts: function() {\n\n\t        // references to rendered elements without z-index\n\t        var elementReferences = [];\n\t        var elem = this._getContainerElement();\n\n\t        for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n\t            elementReferences.push(elem.node.childNodes[i]);\n\t        }\n\n\t        var portsGropsByZ = groupBy(this.model._portSettingsData.getPorts(), 'z');\n\t        var withoutZKey = 'auto';\n\n\t        // render non-z first\n\t        toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {\n\t            var portElement = this._getPortElement(port);\n\t            elem.append(portElement);\n\t            elementReferences.push(portElement);\n\t        }, this);\n\n\t        var groupNames = Object.keys(portsGropsByZ);\n\t        for (var k = 0; k < groupNames.length; k++) {\n\t            var groupName = groupNames[k];\n\t            if (groupName !== withoutZKey) {\n\t                var z = parseInt(groupName, 10);\n\t                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n\t            }\n\t        }\n\n\t        this._updatePorts();\n\t    },\n\n\t    /**\n\t     * @returns {V}\n\t     * @private\n\t     */\n\t    _getContainerElement: function() {\n\n\t        return this.rotatableNode || this.vel;\n\t    },\n\n\t    /**\n\t     * @param {Array<Port>}ports\n\t     * @param {number} z\n\t     * @param refs\n\t     * @private\n\t     */\n\t    _appendPorts: function(ports, z, refs) {\n\n\t        var containerElement = this._getContainerElement();\n\t        var portElements = toArray(ports).map(this._getPortElement, this);\n\n\t        if (refs[z] || z < 0) {\n\t            V(refs[Math.max(z, 0)]).before(portElements);\n\t        } else {\n\t            containerElement.append(portElements);\n\t        }\n\t    },\n\n\t    /**\n\t     * Try to get element from cache,\n\t     * @param port\n\t     * @returns {*}\n\t     * @private\n\t     */\n\t    _getPortElement: function(port) {\n\n\t        if (this._portElementsCache[port.id]) {\n\t            return this._portElementsCache[port.id].portElement;\n\t        }\n\t        return this._createPortElement(port);\n\t    },\n\n\t    findPortNode: function(portId, selector) {\n\t        var portCache = this._portElementsCache[portId];\n\t        if (!portCache) { return null; }\n\t        var portRoot = portCache.portContentElement.node;\n\t        var portSelectors = portCache.portContentSelectors;\n\t        var ref = this.findBySelector(selector, portRoot, portSelectors);\n\t        var node = ref[0]; if ( node === void 0 ) node = null;\n\t        return node;\n\t    },\n\n\t    /**\n\t     * @private\n\t     */\n\t    _updatePorts: function() {\n\n\t        // layout ports without group\n\t        this._updatePortGroup(undefined);\n\t        // layout ports with explicit group\n\t        var groupsNames = Object.keys(this.model._portSettingsData.groups);\n\t        groupsNames.forEach(this._updatePortGroup, this);\n\t    },\n\n\t    /**\n\t     * @private\n\t     */\n\t    _removePorts: function() {\n\t        invoke(this._portElementsCache, 'portElement.remove');\n\t    },\n\n\t    /**\n\t     * @param {Port} port\n\t     * @returns {V}\n\t     * @private\n\t     */\n\t    _createPortElement: function(port) {\n\n\t        var portElement;\n\t        var labelElement;\n\n\t        var portContainerElement = V(this.portContainerMarkup).addClass('joint-port');\n\n\t        var portMarkup = this._getPortMarkup(port);\n\t        var portSelectors;\n\t        if (Array.isArray(portMarkup)) {\n\t            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n\t            var portFragment = portDoc.fragment;\n\t            if (portFragment.childNodes.length > 1) {\n\t                portElement = V('g').append(portFragment);\n\t            } else {\n\t                portElement = V(portFragment.firstChild);\n\t            }\n\t            portSelectors = portDoc.selectors;\n\t        } else {\n\t            portElement = V(portMarkup);\n\t            if (Array.isArray(portElement)) {\n\t                portElement = V('g').append(portElement);\n\t            }\n\t        }\n\n\t        if (!portElement) {\n\t            throw new Error('ElementView: Invalid port markup.');\n\t        }\n\n\t        portElement.attr({\n\t            'port': port.id,\n\t            'port-group': port.group\n\t        });\n\n\t        var labelMarkup = this._getPortLabelMarkup(port.label);\n\t        var labelSelectors;\n\t        if (Array.isArray(labelMarkup)) {\n\t            var labelDoc = this.parseDOMJSON(labelMarkup, portContainerElement.node);\n\t            var labelFragment = labelDoc.fragment;\n\t            if (labelFragment.childNodes.length > 1) {\n\t                labelElement = V('g').append(labelFragment);\n\t            } else {\n\t                labelElement = V(labelFragment.firstChild);\n\t            }\n\t            labelSelectors = labelDoc.selectors;\n\t        } else {\n\t            labelElement = V(labelMarkup);\n\t            if (Array.isArray(labelElement)) {\n\t                labelElement = V('g').append(labelElement);\n\t            }\n\t        }\n\n\t        if (!labelElement) {\n\t            throw new Error('ElementView: Invalid port label markup.');\n\t        }\n\n\t        var portContainerSelectors;\n\t        if (portSelectors && labelSelectors) {\n\t            for (var key in labelSelectors) {\n\t                if (portSelectors[key] && key !== this.selector) { throw new Error('ElementView: selectors within port must be unique.'); }\n\t            }\n\t            portContainerSelectors = assign({}, portSelectors, labelSelectors);\n\t        } else {\n\t            portContainerSelectors = portSelectors || labelSelectors;\n\t        }\n\n\t        portContainerElement.append([\n\t            portElement.addClass('joint-port-body'),\n\t            labelElement.addClass('joint-port-label')\n\t        ]);\n\n\t        this._portElementsCache[port.id] = {\n\t            portElement: portContainerElement,\n\t            portLabelElement: labelElement,\n\t            portSelectors: portContainerSelectors,\n\t            portLabelSelectors: labelSelectors,\n\t            portContentElement: portElement,\n\t            portContentSelectors: portSelectors\n\t        };\n\n\t        return portContainerElement;\n\t    },\n\n\t    /**\n\t     * @param {string=} groupName\n\t     * @private\n\t     */\n\t    _updatePortGroup: function(groupName) {\n\n\t        var elementBBox = Rect(this.model.size());\n\t        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n\n\t        for (var i = 0, n = portsMetrics.length; i < n; i++) {\n\t            var metrics = portsMetrics[i];\n\t            var portId = metrics.portId;\n\t            var cached = this._portElementsCache[portId] || {};\n\t            var portTransformation = metrics.portTransformation;\n\t            this.applyPortTransform(cached.portElement, portTransformation);\n\t            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n\t                rootBBox: new Rect(metrics.portSize),\n\t                selectors: cached.portSelectors\n\t            });\n\n\t            var labelTransformation = metrics.labelTransformation;\n\t            if (labelTransformation) {\n\t                this.applyPortTransform(cached.portLabelElement, labelTransformation, (-portTransformation.angle || 0));\n\t                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n\t                    rootBBox: new Rect(metrics.labelSize),\n\t                    selectors: cached.portLabelSelectors\n\t                });\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * @param {Vectorizer} element\n\t     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n\t     * @param {number=} initialAngle\n\t     * @constructor\n\t     */\n\t    applyPortTransform: function(element, transformData, initialAngle) {\n\n\t        var matrix = V.createSVGMatrix()\n\t            .rotate(initialAngle || 0)\n\t            .translate(transformData.x || 0, transformData.y || 0)\n\t            .rotate(transformData.angle || 0);\n\n\t        element.transform(matrix, { absolute: true });\n\t    },\n\n\t    /**\n\t     * @param {Port} port\n\t     * @returns {string}\n\t     * @private\n\t     */\n\t    _getPortMarkup: function(port) {\n\n\t        return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n\t    },\n\n\t    /**\n\t     * @param {Object} label\n\t     * @returns {string}\n\t     * @private\n\t     */\n\t    _getPortLabelMarkup: function(label) {\n\n\t        return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n\t    }\n\t};\n\n\t// Element base model.\n\t// -----------------------------\n\n\tvar Element$1 = Cell.extend({\n\n\t    defaults: {\n\t        position: { x: 0, y: 0 },\n\t        size: { width: 1, height: 1 },\n\t        angle: 0\n\t    },\n\n\t    initialize: function() {\n\n\t        this._initializePorts();\n\t        Cell.prototype.initialize.apply(this, arguments);\n\t    },\n\n\t    /**\n\t     * @abstract\n\t     */\n\t    _initializePorts: function() {\n\t        // implemented in ports.js\n\t    },\n\n\t    _refreshPorts: function() {\n\t        // implemented in ports.js\n\t    },\n\n\t    isElement: function() {\n\n\t        return true;\n\t    },\n\n\t    position: function(x, y, opt) {\n\n\t        var isSetter = isNumber(y);\n\n\t        opt = (isSetter ? opt : x) || {};\n\n\t        // option `parentRelative` for setting the position relative to the element's parent.\n\t        if (opt.parentRelative) {\n\n\t            // Getting the parent's position requires the collection.\n\t            // Cell.parent() holds cell id only.\n\t            if (!this.graph) { throw new Error('Element must be part of a graph.'); }\n\n\t            var parent = this.getParentCell();\n\t            var parentPosition = parent && !parent.isLink()\n\t                ? parent.get('position')\n\t                : { x: 0, y: 0 };\n\t        }\n\n\t        if (isSetter) {\n\n\t            if (opt.parentRelative) {\n\t                x += parentPosition.x;\n\t                y += parentPosition.y;\n\t            }\n\n\t            if (opt.deep) {\n\t                var currentPosition = this.get('position');\n\t                this.translate(x - currentPosition.x, y - currentPosition.y, opt);\n\t            } else {\n\t                this.set('position', { x: x, y: y }, opt);\n\t            }\n\n\t            return this;\n\n\t        } else { // Getter returns a geometry point.\n\n\t            var elementPosition = Point(this.get('position'));\n\n\t            return opt.parentRelative\n\t                ? elementPosition.difference(parentPosition)\n\t                : elementPosition;\n\t        }\n\t    },\n\n\t    translate: function(tx, ty, opt) {\n\n\t        tx = tx || 0;\n\t        ty = ty || 0;\n\n\t        if (tx === 0 && ty === 0) {\n\t            // Like nothing has happened.\n\t            return this;\n\t        }\n\n\t        opt = opt || {};\n\t        // Pass the initiator of the translation.\n\t        opt.translateBy = opt.translateBy || this.id;\n\n\t        var position = this.get('position') || { x: 0, y: 0 };\n\t        var ra = opt.restrictedArea;\n\t        if (ra && opt.translateBy === this.id) {\n\n\t            if (typeof ra === 'function') {\n\n\t                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\n\t                tx = newPosition.x - position.x;\n\t                ty = newPosition.y - position.y;\n\n\t            } else  {\n\t                // We are restricting the translation for the element itself only. We get\n\t                // the bounding box of the element including all its embeds.\n\t                // All embeds have to be translated the exact same way as the element.\n\t                var bbox = this.getBBox({ deep: true });\n\t                //- - - - - - - - - - - - -> ra.x + ra.width\n\t                // - - - -> position.x      |\n\t                // -> bbox.x\n\t                //                   |\n\t                //         \n\t                //                 |\n\t                //   \n\t                //                  |\n\t                //   <-dx->                     | restricted area right border\n\t                //         <-width->        |    translated element\n\t                //   <- - bbox.width - ->        embedded element\n\t                var dx = position.x - bbox.x;\n\t                var dy = position.y - bbox.y;\n\t                // Find the maximal/minimal coordinates that the element can be translated\n\t                // while complies the restrictions.\n\t                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n\t                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n\t                // recalculate the translation taking the restrictions into account.\n\t                tx = x - position.x;\n\t                ty = y - position.y;\n\t            }\n\t        }\n\n\t        var translatedPosition = {\n\t            x: position.x + tx,\n\t            y: position.y + ty\n\t        };\n\n\t        // To find out by how much an element was translated in event 'change:position' handlers.\n\t        opt.tx = tx;\n\t        opt.ty = ty;\n\n\t        if (opt.transition) {\n\n\t            if (!isObject$1(opt.transition)) { opt.transition = {}; }\n\n\t            this.transition('position', translatedPosition, assign({}, opt.transition, {\n\t                valueFunction: interpolate.object\n\t            }));\n\n\t            // Recursively call `translate()` on all the embeds cells.\n\t            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\n\t        } else {\n\n\t            this.startBatch('translate', opt);\n\t            this.set('position', translatedPosition, opt);\n\t            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\t            this.stopBatch('translate', opt);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    size: function(width, height, opt) {\n\n\t        var currentSize = this.get('size');\n\t        // Getter\n\t        // () signature\n\t        if (width === undefined) {\n\t            return {\n\t                width: currentSize.width,\n\t                height: currentSize.height\n\t            };\n\t        }\n\t        // Setter\n\t        // (size, opt) signature\n\t        if (isObject$1(width)) {\n\t            opt = height;\n\t            height = isNumber(width.height) ? width.height : currentSize.height;\n\t            width = isNumber(width.width) ? width.width : currentSize.width;\n\t        }\n\n\t        return this.resize(width, height, opt);\n\t    },\n\n\t    resize: function(width, height, opt) {\n\n\t        opt = opt || {};\n\n\t        this.startBatch('resize', opt);\n\n\t        if (opt.direction) {\n\n\t            var currentSize = this.get('size');\n\n\t            switch (opt.direction) {\n\n\t                case 'left':\n\t                case 'right':\n\t                    // Don't change height when resizing horizontally.\n\t                    height = currentSize.height;\n\t                    break;\n\n\t                case 'top':\n\t                case 'bottom':\n\t                    // Don't change width when resizing vertically.\n\t                    width = currentSize.width;\n\t                    break;\n\t            }\n\n\t            // Get the angle and clamp its value between 0 and 360 degrees.\n\t            var angle = normalizeAngle(this.get('angle') || 0);\n\n\t            // This is a rectangle in size of the un-rotated element.\n\t            var bbox = this.getBBox();\n\n\t            var origin;\n\n\t            if (angle) {\n\n\t                var quadrant = {\n\t                    'top-right': 0,\n\t                    'right': 0,\n\t                    'top-left': 1,\n\t                    'top': 1,\n\t                    'bottom-left': 2,\n\t                    'left': 2,\n\t                    'bottom-right': 3,\n\t                    'bottom': 3\n\t                }[opt.direction];\n\n\t                if (opt.absolute) {\n\n\t                    // We are taking the element's rotation into account\n\t                    quadrant += Math.floor((angle + 45) / 90);\n\t                    quadrant %= 4;\n\t                }\n\n\t                // Pick the corner point on the element, which meant to stay on its place before and\n\t                // after the rotation.\n\t                var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n\t                // Find  an image of the previous indent point. This is the position, where is the\n\t                // point actually located on the screen.\n\t                var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n\t                // Every point on the element rotates around a circle with the centre of rotation\n\t                // in the middle of the element while the whole element is being rotated. That means\n\t                // that the distance from a point in the corner of the element (supposed its always rect) to\n\t                // the center of the element doesn't change during the rotation and therefore it equals\n\t                // to a distance on un-rotated element.\n\t                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\t                var radius = Math.sqrt((width * width) + (height * height)) / 2;\n\n\t                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n\t                // and ending at the center of the element. We call this angle `alpha`.\n\n\t                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n\t                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n\t                //\n\t                // 3 | 2\n\t                // --c-- Quadrant positions around the element's center `c`\n\t                // 0 | 1\n\t                //\n\t                var alpha = quadrant * Math.PI / 2;\n\n\t                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n\t                // going through the center of the element) and line crossing the indent of the fixed point and the center\n\t                // of the element. This is the angle we need but on the un-rotated element.\n\t                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n\t                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n\t                alpha -= toRad(angle);\n\n\t                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n\t                // Note that fromPolar constructor accepts an angle in radians.\n\t                var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n\t                // The top left corner on the un-rotated element has to be half a width on the left\n\t                // and half a height to the top from the center. This will be the origin of rectangle\n\t                // we were looking for.\n\t                origin = Point(center).offset(width / -2, height / -2);\n\n\t            } else {\n\t                // calculation for the origin Point when there is no rotation of the element\n\t                origin = bbox.topLeft();\n\n\t                switch (opt.direction) {\n\t                    case 'top':\n\t                    case 'top-right':\n\t                        origin.offset(0, bbox.height - height);\n\t                        break;\n\t                    case 'left':\n\t                    case 'bottom-left':\n\t                        origin.offset(bbox.width -width, 0);\n\t                        break;\n\t                    case 'top-left':\n\t                        origin.offset(bbox.width - width, bbox.height - height);\n\t                        break;\n\t                }\n\t            }\n\n\t            // Resize the element (before re-positioning it).\n\t            this.set('size', { width: width, height: height }, opt);\n\n\t            // Finally, re-position the element.\n\t            this.position(origin.x, origin.y, opt);\n\n\t        } else {\n\n\t            // Resize the element.\n\t            this.set('size', { width: width, height: height }, opt);\n\t        }\n\n\t        this.stopBatch('resize', opt);\n\n\t        return this;\n\t    },\n\n\t    scale: function(sx, sy, origin, opt) {\n\n\t        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n\t        this.startBatch('scale', opt);\n\t        this.position(scaledBBox.x, scaledBBox.y, opt);\n\t        this.resize(scaledBBox.width, scaledBBox.height, opt);\n\t        this.stopBatch('scale');\n\t        return this;\n\t    },\n\n\t    fitEmbeds: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        // Getting the children's size and position requires the collection.\n\t        // Cell.get('embeds') helds an array of cell ids only.\n\t        var ref = this;\n\t        var graph = ref.graph;\n\t        if (!graph) { throw new Error('Element must be part of a graph.'); }\n\n\t        var embeddedCells = this.getEmbeddedCells().filter(function (cell) { return cell.isElement(); });\n\t        if (embeddedCells.length === 0) { return this; }\n\n\t        this.startBatch('fit-embeds', opt);\n\n\t        if (opt.deep) {\n\t            // Recursively apply fitEmbeds on all embeds first.\n\t            invoke(embeddedCells, 'fitEmbeds', opt);\n\t        }\n\n\t        // Compute cell's size and position based on the children bbox\n\t        // and given padding.\n\t        var ref$1 = normalizeSides(opt.padding);\n\t        var left = ref$1.left;\n\t        var right = ref$1.right;\n\t        var top = ref$1.top;\n\t        var bottom = ref$1.bottom;\n\t        var ref$2 = graph.getCellsBBox(embeddedCells);\n\t        var x = ref$2.x;\n\t        var y = ref$2.y;\n\t        var width = ref$2.width;\n\t        var height = ref$2.height;\n\t        // Apply padding computed above to the bbox.\n\t        x -= left;\n\t        y -= top;\n\t        width += left + right;\n\t        height += bottom + top;\n\n\t        // Set new element dimensions finally.\n\t        this.set({\n\t            position: { x: x, y: y },\n\t            size: { width: width, height: height }\n\t        }, opt);\n\n\t        this.stopBatch('fit-embeds');\n\n\t        return this;\n\t    },\n\n\t    // Rotate element by `angle` degrees, optionally around `origin` point.\n\t    // If `origin` is not provided, it is considered to be the center of the element.\n\t    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n\t    // the difference from the previous angle.\n\t    rotate: function(angle, absolute, origin, opt) {\n\n\t        if (origin) {\n\n\t            var center = this.getBBox().center();\n\t            var size = this.get('size');\n\t            var position = this.get('position');\n\t            center.rotate(origin, this.get('angle') - angle);\n\t            var dx = center.x - size.width / 2 - position.x;\n\t            var dy = center.y - size.height / 2 - position.y;\n\t            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\n\t            this.position(position.x + dx, position.y + dy, opt);\n\t            this.rotate(angle, absolute, null, opt);\n\t            this.stopBatch('rotate');\n\n\t        } else {\n\n\t            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    angle: function() {\n\t        return normalizeAngle(this.get('angle') || 0);\n\t    },\n\n\t    getBBox: function(opt) {\n\n\t        opt = opt || {};\n\n\t        if (opt.deep && this.graph) {\n\n\t            // Get all the embedded elements using breadth first algorithm,\n\t            // that doesn't use recursion.\n\t            var elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n\t            // Add the model itself.\n\t            elements.push(this);\n\n\t            return this.graph.getCellsBBox(elements);\n\t        }\n\n\t        var position = this.get('position');\n\t        var size = this.get('size');\n\n\t        return new Rect(position.x, position.y, size.width, size.height);\n\t    },\n\n\t    getPointFromConnectedLink: function(link, endType) {\n\t        // Center of the model\n\t        var bbox = this.getBBox();\n\t        var center = bbox.center();\n\t        // Center of a port\n\t        var endDef = link.get(endType);\n\t        if (!endDef) { return center; }\n\t        var portId = endDef.port;\n\t        if (!portId || !this.hasPort(portId)) { return center; }\n\t        var portGroup = this.portProp(portId, ['group']);\n\t        var portsPositions = this.getPortsPositions(portGroup);\n\t        var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n\t        var angle = this.angle();\n\t        if (angle) { portCenter.rotate(center, -angle); }\n\t        return portCenter;\n\t    }\n\t});\n\n\tassign(Element$1.prototype, elementPortPrototype);\n\n\tvar GraphCells = Backbone.Collection.extend({\n\n\t    initialize: function(models, opt) {\n\n\t        // Set the optional namespace where all model classes are defined.\n\t        if (opt.cellNamespace) {\n\t            this.cellNamespace = opt.cellNamespace;\n\t        } else {\n\t            /* global joint: true */\n\t            this.cellNamespace = typeof joint !== 'undefined' && has$2(joint, 'shapes') ? joint.shapes : null;\n\t            /* global joint: false */\n\t        }\n\n\n\t        this.graph = opt.graph;\n\t    },\n\n\t    model: function(attrs, opt) {\n\n\t        var collection = opt.collection;\n\t        var namespace = collection.cellNamespace;\n\n\t        // Find the model class in the namespace or use the default one.\n\t        var ModelClass = (attrs.type === 'link')\n\t            ? Link\n\t            : getByPath(namespace, attrs.type, '.') || Element$1;\n\n\t        var cell = new ModelClass(attrs, opt);\n\t        // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n\t        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n\t        if (!opt.dry) {\n\t            cell.graph = collection.graph;\n\t        }\n\n\t        return cell;\n\t    },\n\n\t    // `comparator` makes it easy to sort cells based on their `z` index.\n\t    comparator: function(model) {\n\n\t        return model.get('z') || 0;\n\t    }\n\t});\n\n\n\tvar Graph = Backbone.Model.extend({\n\n\t    initialize: function(attrs, opt) {\n\n\t        opt = opt || {};\n\n\t        // Passing `cellModel` function in the options object to graph allows for\n\t        // setting models based on attribute objects. This is especially handy\n\t        // when processing JSON graphs that are in a different than JointJS format.\n\t        var cells = new GraphCells([], {\n\t            model: opt.cellModel,\n\t            cellNamespace: opt.cellNamespace,\n\t            graph: this\n\t        });\n\t        Backbone.Model.prototype.set.call(this, 'cells', cells);\n\n\t        // Make all the events fired in the `cells` collection available.\n\t        // to the outside world.\n\t        cells.on('all', this.trigger, this);\n\n\t        // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n\t        // they're already in the collection. Therefore, we're triggering sort manually here.\n\t        this.on('change:z', this._sortOnChangeZ, this);\n\n\t        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n\t        // for fast graph queries. All changes that affect the structure of the graph\n\t        // must be reflected in the `al` object. This object provides fast answers to\n\t        // questions such as \"what are the neighbours of this node\" or \"what\n\t        // are the sibling links of this link\".\n\n\t        // Outgoing edges per node. Note that we use a hash-table for the list\n\t        // of outgoing edges for a faster lookup.\n\t        // [nodeId] -> Object [edgeId] -> true\n\t        this._out = {};\n\t        // Ingoing edges per node.\n\t        // [nodeId] -> Object [edgeId] -> true\n\t        this._in = {};\n\t        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n\t        // having to go through the whole cells array.\n\t        // [node ID] -> true\n\t        this._nodes = {};\n\t        // `_edges` is useful for quick lookup of all the links in the graph, without\n\t        // having to go through the whole cells array.\n\t        // [edgeId] -> true\n\t        this._edges = {};\n\n\t        this._batches = {};\n\n\t        cells.on('add', this._restructureOnAdd, this);\n\t        cells.on('remove', this._restructureOnRemove, this);\n\t        cells.on('reset', this._restructureOnReset, this);\n\t        cells.on('change:source', this._restructureOnChangeSource, this);\n\t        cells.on('change:target', this._restructureOnChangeTarget, this);\n\t        cells.on('remove', this._removeCell, this);\n\t    },\n\n\t    _sortOnChangeZ: function() {\n\n\t        this.get('cells').sort();\n\t    },\n\n\t    _restructureOnAdd: function(cell) {\n\n\t        if (cell.isLink()) {\n\t            this._edges[cell.id] = true;\n\t            var ref = cell.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            if (source.id) {\n\t                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n\t            }\n\t            if (target.id) {\n\t                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n\t            }\n\t        } else {\n\t            this._nodes[cell.id] = true;\n\t        }\n\t    },\n\n\t    _restructureOnRemove: function(cell) {\n\n\t        if (cell.isLink()) {\n\t            delete this._edges[cell.id];\n\t            var ref = cell.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n\t                delete this._out[source.id][cell.id];\n\t            }\n\t            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n\t                delete this._in[target.id][cell.id];\n\t            }\n\t        } else {\n\t            delete this._nodes[cell.id];\n\t        }\n\t    },\n\n\t    _restructureOnReset: function(cells) {\n\n\t        // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n\t        cells = cells.models;\n\n\t        this._out = {};\n\t        this._in = {};\n\t        this._nodes = {};\n\t        this._edges = {};\n\n\t        cells.forEach(this._restructureOnAdd, this);\n\t    },\n\n\t    _restructureOnChangeSource: function(link) {\n\n\t        var prevSource = link.previous('source');\n\t        if (prevSource.id && this._out[prevSource.id]) {\n\t            delete this._out[prevSource.id][link.id];\n\t        }\n\t        var source = link.attributes.source;\n\t        if (source.id) {\n\t            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n\t        }\n\t    },\n\n\t    _restructureOnChangeTarget: function(link) {\n\n\t        var prevTarget = link.previous('target');\n\t        if (prevTarget.id && this._in[prevTarget.id]) {\n\t            delete this._in[prevTarget.id][link.id];\n\t        }\n\t        var target = link.get('target');\n\t        if (target.id) {\n\t            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n\t        }\n\t    },\n\n\t    // Return all outbound edges for the node. Return value is an object\n\t    // of the form: [edgeId] -> true\n\t    getOutboundEdges: function(node) {\n\n\t        return (this._out && this._out[node]) || {};\n\t    },\n\n\t    // Return all inbound edges for the node. Return value is an object\n\t    // of the form: [edgeId] -> true\n\t    getInboundEdges: function(node) {\n\n\t        return (this._in && this._in[node]) || {};\n\t    },\n\n\t    toJSON: function() {\n\n\t        // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n\t        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n\t        var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n\t        json.cells = this.get('cells').toJSON();\n\t        return json;\n\t    },\n\n\t    fromJSON: function(json, opt) {\n\n\t        if (!json.cells) {\n\n\t            throw new Error('Graph JSON must contain cells array.');\n\t        }\n\n\t        return this.set(json, opt);\n\t    },\n\n\t    set: function(key, val, opt) {\n\n\t        var attrs;\n\n\t        // Handle both `key`, value and {key: value} style arguments.\n\t        if (typeof key === 'object') {\n\t            attrs = key;\n\t            opt = val;\n\t        } else {\n\t            (attrs = {})[key] = val;\n\t        }\n\n\t        // Make sure that `cells` attribute is handled separately via resetCells().\n\t        if (attrs.hasOwnProperty('cells')) {\n\t            this.resetCells(attrs.cells, opt);\n\t            attrs = omit(attrs, 'cells');\n\t        }\n\n\t        // The rest of the attributes are applied via original set method.\n\t        return Backbone.Model.prototype.set.call(this, attrs, opt);\n\t    },\n\n\t    clear: function(opt) {\n\n\t        opt = assign({}, opt, { clear: true });\n\n\t        var collection = this.get('cells');\n\n\t        if (collection.length === 0) { return this; }\n\n\t        this.startBatch('clear', opt);\n\n\t        // The elements come after the links.\n\t        var cells = collection.sortBy(function(cell) {\n\t            return cell.isLink() ? 1 : 2;\n\t        });\n\n\t        do {\n\n\t            // Remove all the cells one by one.\n\t            // Note that all the links are removed first, so it's\n\t            // safe to remove the elements without removing the connected\n\t            // links first.\n\t            cells.shift().remove(opt);\n\n\t        } while (cells.length > 0);\n\n\t        this.stopBatch('clear');\n\n\t        return this;\n\t    },\n\n\t    _prepareCell: function(cell, opt) {\n\n\t        var attrs;\n\t        if (cell instanceof Backbone.Model) {\n\t            attrs = cell.attributes;\n\t            if (!cell.graph && (!opt || !opt.dry)) {\n\t                // An element can not be member of more than one graph.\n\t                // A cell stops being the member of the graph after it's explicitly removed.\n\t                cell.graph = this;\n\t            }\n\t        } else {\n\t            // In case we're dealing with a plain JS object, we have to set the reference\n\t            // to the `graph` right after the actual model is created. This happens in the `model()` function\n\t            // of `joint.dia.GraphCells`.\n\t            attrs = cell;\n\t        }\n\n\t        if (!isString(attrs.type)) {\n\t            throw new TypeError('dia.Graph: cell type must be a string.');\n\t        }\n\n\t        return cell;\n\t    },\n\n\t    minZIndex: function() {\n\n\t        var firstCell = this.get('cells').first();\n\t        return firstCell ? (firstCell.get('z') || 0) : 0;\n\t    },\n\n\t    maxZIndex: function() {\n\n\t        var lastCell = this.get('cells').last();\n\t        return lastCell ? (lastCell.get('z') || 0) : 0;\n\t    },\n\n\t    addCell: function(cell, opt) {\n\n\t        if (Array.isArray(cell)) {\n\n\t            return this.addCells(cell, opt);\n\t        }\n\n\t        if (cell instanceof Backbone.Model) {\n\n\t            if (!cell.has('z')) {\n\t                cell.set('z', this.maxZIndex() + 1);\n\t            }\n\n\t        } else if (cell.z === undefined) {\n\n\t            cell.z = this.maxZIndex() + 1;\n\t        }\n\n\t        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n\t        return this;\n\t    },\n\n\t    addCells: function(cells, opt) {\n\n\t        if (cells.length === 0) { return this; }\n\n\t        cells = flattenDeep(cells);\n\t        opt.maxPosition = opt.position = cells.length - 1;\n\n\t        this.startBatch('add', opt);\n\t        cells.forEach(function(cell) {\n\t            this.addCell(cell, opt);\n\t            opt.position--;\n\t        }, this);\n\t        this.stopBatch('add', opt);\n\n\t        return this;\n\t    },\n\n\t    // When adding a lot of cells, it is much more efficient to\n\t    // reset the entire cells collection in one go.\n\t    // Useful for bulk operations and optimizations.\n\t    resetCells: function(cells, opt) {\n\n\t        var preparedCells = toArray(cells).map(function(cell) {\n\t            return this._prepareCell(cell, opt);\n\t        }, this);\n\t        this.get('cells').reset(preparedCells, opt);\n\n\t        return this;\n\t    },\n\n\t    removeCells: function(cells, opt) {\n\n\t        if (cells.length) {\n\n\t            this.startBatch('remove');\n\t            invoke(cells, 'remove', opt);\n\t            this.stopBatch('remove');\n\t        }\n\n\t        return this;\n\t    },\n\n\t    _removeCell: function(cell, collection, options) {\n\n\t        options = options || {};\n\n\t        if (!options.clear) {\n\t            // Applications might provide a `disconnectLinks` option set to `true` in order to\n\t            // disconnect links when a cell is removed rather then removing them. The default\n\t            // is to remove all the associated links.\n\t            if (options.disconnectLinks) {\n\n\t                this.disconnectLinks(cell, options);\n\n\t            } else {\n\n\t                this.removeLinks(cell, options);\n\t            }\n\t        }\n\t        // Silently remove the cell from the cells collection. Silently, because\n\t        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n\t        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n\t        // would be triggered on the graph model.\n\t        this.get('cells').remove(cell, { silent: true });\n\n\t        if (cell.graph === this) {\n\t            // Remove the element graph reference only if the cell is the member of this graph.\n\t            cell.graph = null;\n\t        }\n\t    },\n\n\t    // Get a cell by `id`.\n\t    getCell: function(id) {\n\n\t        return this.get('cells').get(id);\n\t    },\n\n\t    getCells: function() {\n\n\t        return this.get('cells').toArray();\n\t    },\n\n\t    getElements: function() {\n\n\t        return Object.keys(this._nodes).map(this.getCell, this);\n\t    },\n\n\t    getLinks: function() {\n\n\t        return Object.keys(this._edges).map(this.getCell, this);\n\t    },\n\n\t    getFirstCell: function() {\n\n\t        return this.get('cells').first();\n\t    },\n\n\t    getLastCell: function() {\n\n\t        return this.get('cells').last();\n\t    },\n\n\t    // Get all inbound and outbound links connected to the cell `model`.\n\t    getConnectedLinks: function(model, opt) {\n\n\t        opt = opt || {};\n\n\t        var indirect = opt.indirect;\n\t        var inbound = opt.inbound;\n\t        var outbound = opt.outbound;\n\t        if ((inbound === undefined) && (outbound === undefined)) {\n\t            inbound = outbound = true;\n\t        }\n\n\t        // the final array of connected link models\n\t        var links = [];\n\t        // a hash table of connected edges of the form: [edgeId] -> true\n\t        // used for quick lookups to check if we already added a link\n\t        var edges = {};\n\n\t        if (outbound) {\n\t            addOutbounds(this, model);\n\t        }\n\t        if (inbound) {\n\t            addInbounds(this, model);\n\t        }\n\n\t        function addOutbounds(graph, model) {\n\t            forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n\t                // skip links that were already added\n\t                // (those must be self-loop links)\n\t                // (because they are inbound and outbound edges of the same two elements)\n\t                if (edges[edge]) { return; }\n\t                var link = graph.getCell(edge);\n\t                links.push(link);\n\t                edges[edge] = true;\n\t                if (indirect) {\n\t                    if (inbound) { addInbounds(graph, link); }\n\t                    if (outbound) { addOutbounds(graph, link); }\n\t                }\n\t            }.bind(graph));\n\t            if (indirect && model.isLink()) {\n\t                var outCell = model.getTargetCell();\n\t                if (outCell && outCell.isLink()) {\n\t                    if (!edges[outCell.id]) {\n\t                        links.push(outCell);\n\t                        addOutbounds(graph, outCell);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        function addInbounds(graph, model) {\n\t            forIn(graph.getInboundEdges(model.id), function(_, edge) {\n\t                // skip links that were already added\n\t                // (those must be self-loop links)\n\t                // (because they are inbound and outbound edges of the same two elements)\n\t                if (edges[edge]) { return; }\n\t                var link = graph.getCell(edge);\n\t                links.push(link);\n\t                edges[edge] = true;\n\t                if (indirect) {\n\t                    if (inbound) { addInbounds(graph, link); }\n\t                    if (outbound) { addOutbounds(graph, link); }\n\t                }\n\t            }.bind(graph));\n\t            if (indirect && model.isLink()) {\n\t                var inCell = model.getSourceCell();\n\t                if (inCell && inCell.isLink()) {\n\t                    if (!edges[inCell.id]) {\n\t                        links.push(inCell);\n\t                        addInbounds(graph, inCell);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n\t        if (opt.deep) {\n\n\t            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n\t            // in the first round, we collect all the embedded elements\n\t            var embeddedElements = {};\n\t            embeddedCells.forEach(function(cell) {\n\t                if (cell.isElement()) {\n\t                    embeddedElements[cell.id] = true;\n\t                }\n\t            });\n\n\t            embeddedCells.forEach(function(cell) {\n\t                if (cell.isLink()) { return; }\n\t                if (outbound) {\n\t                    forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n\t                        if (!edges[edge]) {\n\t                            var edgeCell = this.getCell(edge);\n\t                            var ref = edgeCell.attributes;\n\t                            var source = ref.source;\n\t                            var target = ref.target;\n\t                            var sourceId = source.id;\n\t                            var targetId = target.id;\n\n\t                            // if `includeEnclosed` option is falsy, skip enclosed links\n\t                            if (!opt.includeEnclosed\n\t                                && (sourceId && embeddedElements[sourceId])\n\t                                && (targetId && embeddedElements[targetId])) {\n\t                                return;\n\t                            }\n\n\t                            links.push(this.getCell(edge));\n\t                            edges[edge] = true;\n\t                        }\n\t                    }.bind(this));\n\t                }\n\t                if (inbound) {\n\t                    forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n\t                        if (!edges[edge]) {\n\t                            var edgeCell = this.getCell(edge);\n\t                            var ref = edgeCell.attributes;\n\t                            var source = ref.source;\n\t                            var target = ref.target;\n\t                            var sourceId = source.id;\n\t                            var targetId = target.id;\n\n\t                            // if `includeEnclosed` option is falsy, skip enclosed links\n\t                            if (!opt.includeEnclosed\n\t                                && (sourceId && embeddedElements[sourceId])\n\t                                && (targetId && embeddedElements[targetId])) {\n\t                                return;\n\t                            }\n\n\t                            links.push(this.getCell(edge));\n\t                            edges[edge] = true;\n\t                        }\n\t                    }.bind(this));\n\t                }\n\t            }, this);\n\t        }\n\n\t        return links;\n\t    },\n\n\t    getNeighbors: function(model, opt) {\n\n\t        opt || (opt = {});\n\n\t        var inbound = opt.inbound;\n\t        var outbound = opt.outbound;\n\t        if (inbound === undefined && outbound === undefined) {\n\t            inbound = outbound = true;\n\t        }\n\n\t        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            var loop = link.hasLoop(opt);\n\n\t            // Discard if it is a point, or if the neighbor was already added.\n\t            if (inbound && has$2(source, 'id') && !res[source.id]) {\n\n\t                var sourceElement = this.getCell(source.id);\n\t                if (sourceElement.isElement()) {\n\t                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n\t                        res[source.id] = sourceElement;\n\t                    }\n\t                }\n\t            }\n\n\t            // Discard if it is a point, or if the neighbor was already added.\n\t            if (outbound && has$2(target, 'id') && !res[target.id]) {\n\n\t                var targetElement = this.getCell(target.id);\n\t                if (targetElement.isElement()) {\n\t                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n\t                        res[target.id] = targetElement;\n\t                    }\n\t                }\n\t            }\n\n\t            return res;\n\t        }.bind(this), {});\n\n\t        if (model.isLink()) {\n\t            if (inbound) {\n\t                var sourceCell = model.getSourceCell();\n\t                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n\t                    neighbors[sourceCell.id] = sourceCell;\n\t                }\n\t            }\n\t            if (outbound) {\n\t                var targetCell = model.getTargetCell();\n\t                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n\t                    neighbors[targetCell.id] = targetCell;\n\t                }\n\t            }\n\t        }\n\n\t        return toArray(neighbors);\n\t    },\n\n\t    getCommonAncestor: function(/* cells */) {\n\n\t        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n\t            var ancestors = [];\n\t            var parentId = cell.get('parent');\n\n\t            while (parentId) {\n\n\t                ancestors.push(parentId);\n\t                parentId = this.getCell(parentId).get('parent');\n\t            }\n\n\t            return ancestors;\n\n\t        }, this);\n\n\t        cellsAncestors = cellsAncestors.sort(function(a, b) {\n\t            return a.length - b.length;\n\t        });\n\n\t        var commonAncestor = toArray(cellsAncestors.shift()).find(function(ancestor) {\n\t            return cellsAncestors.every(function(cellAncestors) {\n\t                return cellAncestors.includes(ancestor);\n\t            });\n\t        });\n\n\t        return this.getCell(commonAncestor);\n\t    },\n\n\t    // Find the whole branch starting at `element`.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n\t    getSuccessors: function(element, opt) {\n\n\t        opt = opt || {};\n\t        var res = [];\n\t        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n\t        this.search(element, function(el) {\n\t            if (el !== element) {\n\t                res.push(el);\n\t            }\n\t        }, assign({}, opt, { outbound: true }));\n\t        return res;\n\t    },\n\n\t    cloneCells: cloneCells,\n\t    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n\t    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n\t    // Return a map of the form: [original cell ID] -> [clone].\n\t    cloneSubgraph: function(cells, opt) {\n\n\t        var subgraph = this.getSubgraph(cells, opt);\n\t        return this.cloneCells(subgraph);\n\t    },\n\n\t    // Return `cells` and all the connected links that connect cells in the `cells` array.\n\t    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n\t    // and all the links that connect any of the returned cells.\n\t    // For example, for a single shallow element, the result is that very same element.\n\t    // For two elements connected with a link: `A --- L ---> B`, the result for\n\t    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n\t    getSubgraph: function(cells, opt) {\n\n\t        opt = opt || {};\n\n\t        var subgraph = [];\n\t        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n\t        var cellMap = {};\n\t        var elements = [];\n\t        var links = [];\n\n\t        toArray(cells).forEach(function(cell) {\n\t            if (!cellMap[cell.id]) {\n\t                subgraph.push(cell);\n\t                cellMap[cell.id] = cell;\n\t                if (cell.isLink()) {\n\t                    links.push(cell);\n\t                } else {\n\t                    elements.push(cell);\n\t                }\n\t            }\n\n\t            if (opt.deep) {\n\t                var embeds = cell.getEmbeddedCells({ deep: true });\n\t                embeds.forEach(function(embed) {\n\t                    if (!cellMap[embed.id]) {\n\t                        subgraph.push(embed);\n\t                        cellMap[embed.id] = embed;\n\t                        if (embed.isLink()) {\n\t                            links.push(embed);\n\t                        } else {\n\t                            elements.push(embed);\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t        });\n\n\t        links.forEach(function(link) {\n\t            // For links, return their source & target (if they are elements - not points).\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            if (source.id && !cellMap[source.id]) {\n\t                var sourceElement = this.getCell(source.id);\n\t                subgraph.push(sourceElement);\n\t                cellMap[sourceElement.id] = sourceElement;\n\t                elements.push(sourceElement);\n\t            }\n\t            if (target.id && !cellMap[target.id]) {\n\t                var targetElement = this.getCell(target.id);\n\t                subgraph.push(this.getCell(target.id));\n\t                cellMap[targetElement.id] = targetElement;\n\t                elements.push(targetElement);\n\t            }\n\t        }, this);\n\n\t        elements.forEach(function(element) {\n\t            // For elements, include their connected links if their source/target is in the subgraph;\n\t            var links = this.getConnectedLinks(element, opt);\n\t            links.forEach(function(link) {\n\t                var ref = link.attributes;\n\t                var source = ref.source;\n\t                var target = ref.target;\n\t                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n\t                    subgraph.push(link);\n\t                    cellMap[link.id] = link;\n\t                }\n\t            });\n\t        }, this);\n\n\t        return subgraph;\n\t    },\n\n\t    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n\t    getPredecessors: function(element, opt) {\n\n\t        opt = opt || {};\n\t        var res = [];\n\t        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n\t        this.search(element, function(el) {\n\t            if (el !== element) {\n\t                res.push(el);\n\t            }\n\t        }, assign({}, opt, { inbound: true }));\n\t        return res;\n\t    },\n\n\t    // Perform search on the graph.\n\t    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n\t    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // `iteratee` is a function of the form `function(element) {}`.\n\t    // If `iteratee` explicitly returns `false`, the searching stops.\n\t    search: function(element, iteratee, opt) {\n\n\t        opt = opt || {};\n\t        if (opt.breadthFirst) {\n\t            this.bfs(element, iteratee, opt);\n\t        } else {\n\t            this.dfs(element, iteratee, opt);\n\t        }\n\t    },\n\n\t    // Breadth-first search.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n\t    // `iteratee` is a function of the form `function(element, distance) {}`.\n\t    // where `element` is the currently visited element and `distance` is the distance of that element\n\t    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n\t    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n\t    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n\t    // If `iteratee` explicitly returns `false`, the searching stops.\n\t    bfs: function(element, iteratee, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var visited = {};\n\t        var distance = {};\n\t        var queue = [];\n\n\t        queue.push(element);\n\t        distance[element.id] = 0;\n\n\t        while (queue.length > 0) {\n\t            var next = queue.shift();\n\t            if (visited[next.id]) { continue; }\n\t            visited[next.id] = true;\n\t            if (iteratee.call(this, next, distance[next.id]) === false) { continue; }\n\t            var neighbors = this.getNeighbors(next, opt);\n\t            for (var i = 0, n = neighbors.length; i < n; i++) {\n\t                var neighbor = neighbors[i];\n\t                distance[neighbor.id] = distance[next.id] + 1;\n\t                queue.push(neighbor);\n\t            }\n\t        }\n\t    },\n\n\t    // Depth-first search.\n\t    // If `opt.deep` is `true`, take into account embedded elements too.\n\t    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n\t    // `iteratee` is a function of the form `function(element, distance) {}`.\n\t    // If `iteratee` explicitly returns `false`, the search stops.\n\t    dfs: function(element, iteratee, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var visited = {};\n\t        var distance = {};\n\t        var queue = [];\n\n\t        queue.push(element);\n\t        distance[element.id] = 0;\n\n\t        while (queue.length > 0) {\n\t            var next = queue.pop();\n\t            if (visited[next.id]) { continue; }\n\t            visited[next.id] = true;\n\t            if (iteratee.call(this, next, distance[next.id]) === false) { continue; }\n\t            var neighbors = this.getNeighbors(next, opt);\n\t            var lastIndex = queue.length;\n\t            for (var i = 0, n = neighbors.length; i < n; i++) {\n\t                var neighbor = neighbors[i];\n\t                distance[neighbor.id] = distance[next.id] + 1;\n\t                queue.splice(lastIndex, 0, neighbor);\n\t            }\n\t        }\n\t    },\n\n\t    // Get all the roots of the graph. Time complexity: O(|V|).\n\t    getSources: function() {\n\n\t        var sources = [];\n\t        forIn(this._nodes, function(exists, node) {\n\t            if (!this._in[node] || isEmpty(this._in[node])) {\n\t                sources.push(this.getCell(node));\n\t            }\n\t        }.bind(this));\n\t        return sources;\n\t    },\n\n\t    // Get all the leafs of the graph. Time complexity: O(|V|).\n\t    getSinks: function() {\n\n\t        var sinks = [];\n\t        forIn(this._nodes, function(exists, node) {\n\t            if (!this._out[node] || isEmpty(this._out[node])) {\n\t                sinks.push(this.getCell(node));\n\t            }\n\t        }.bind(this));\n\t        return sinks;\n\t    },\n\n\t    // Return `true` if `element` is a root. Time complexity: O(1).\n\t    isSource: function(element) {\n\n\t        return !this._in[element.id] || isEmpty(this._in[element.id]);\n\t    },\n\n\t    // Return `true` if `element` is a leaf. Time complexity: O(1).\n\t    isSink: function(element) {\n\n\t        return !this._out[element.id] || isEmpty(this._out[element.id]);\n\t    },\n\n\t    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n\t    isSuccessor: function(elementA, elementB) {\n\n\t        var isSuccessor = false;\n\t        this.search(elementA, function(element) {\n\t            if (element === elementB && element !== elementA) {\n\t                isSuccessor = true;\n\t                return false;\n\t            }\n\t        }, { outbound: true });\n\t        return isSuccessor;\n\t    },\n\n\t    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n\t    isPredecessor: function(elementA, elementB) {\n\n\t        var isPredecessor = false;\n\t        this.search(elementA, function(element) {\n\t            if (element === elementB && element !== elementA) {\n\t                isPredecessor = true;\n\t                return false;\n\t            }\n\t        }, { inbound: true });\n\t        return isPredecessor;\n\t    },\n\n\t    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n\t    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n\t    // for more details.\n\t    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n\t    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n\t    isNeighbor: function(elementA, elementB, opt) {\n\n\t        opt = opt || {};\n\n\t        var inbound = opt.inbound;\n\t        var outbound = opt.outbound;\n\t        if ((inbound === undefined) && (outbound === undefined)) {\n\t            inbound = outbound = true;\n\t        }\n\n\t        var isNeighbor = false;\n\n\t        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\n\t            // Discard if it is a point.\n\t            if (inbound && has$2(source, 'id') && (source.id === elementB.id)) {\n\t                isNeighbor = true;\n\t                return false;\n\t            }\n\n\t            // Discard if it is a point, or if the neighbor was already added.\n\t            if (outbound && has$2(target, 'id') && (target.id === elementB.id)) {\n\t                isNeighbor = true;\n\t                return false;\n\t            }\n\t        });\n\n\t        return isNeighbor;\n\t    },\n\n\t    // Disconnect links connected to the cell `model`.\n\t    disconnectLinks: function(model, opt) {\n\n\t        this.getConnectedLinks(model).forEach(function(link) {\n\n\t            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n\t        });\n\t    },\n\n\t    // Remove links connected to the cell `model` completely.\n\t    removeLinks: function(model, opt) {\n\n\t        invoke(this.getConnectedLinks(model), 'remove', opt);\n\t    },\n\n\t    // Find all elements at given point\n\t    findModelsFromPoint: function(p) {\n\n\t        return this.getElements().filter(function(el) {\n\t            return el.getBBox().containsPoint(p);\n\t        });\n\t    },\n\n\t    // Find all elements in given area\n\t    findModelsInArea: function(rect$1, opt) {\n\n\t        rect$1 = rect(rect$1);\n\t        opt = defaults(opt || {}, { strict: false });\n\n\t        var method = opt.strict ? 'containsRect' : 'intersect';\n\n\t        return this.getElements().filter(function(el) {\n\t            return rect$1[method](el.getBBox());\n\t        });\n\t    },\n\n\t    // Find all elements under the given element.\n\t    findModelsUnderElement: function(element, opt) {\n\n\t        opt = defaults(opt || {}, { searchBy: 'bbox' });\n\n\t        var bbox = element.getBBox();\n\t        var elements = (opt.searchBy === 'bbox')\n\t            ? this.findModelsInArea(bbox)\n\t            : this.findModelsFromPoint(bbox[opt.searchBy]());\n\n\t        // don't account element itself or any of its descendants\n\t        return elements.filter(function(el) {\n\t            return element.id !== el.id && !el.isEmbeddedIn(element);\n\t        });\n\t    },\n\n\n\t    // Return bounding box of all elements.\n\t    getBBox: function() {\n\n\t        return this.getCellsBBox(this.getCells());\n\t    },\n\n\t    // Return the bounding box of all cells in array provided.\n\t    getCellsBBox: function(cells, opt) {\n\t        opt || (opt = {});\n\t        return toArray(cells).reduce(function(memo, cell) {\n\t            var rect = cell.getBBox(opt);\n\t            if (!rect) { return memo; }\n\t            var angle = cell.angle();\n\t            if (angle) { rect = rect.bbox(angle); }\n\t            if (memo) {\n\t                return memo.union(rect);\n\t            }\n\t            return rect;\n\t        }, null);\n\t    },\n\n\t    translate: function(dx, dy, opt) {\n\n\t        // Don't translate cells that are embedded in any other cell.\n\t        var cells = this.getCells().filter(function(cell) {\n\t            return !cell.isEmbedded();\n\t        });\n\n\t        invoke(cells, 'translate', dx, dy, opt);\n\n\t        return this;\n\t    },\n\n\t    resize: function(width, height, opt) {\n\n\t        return this.resizeCells(width, height, this.getCells(), opt);\n\t    },\n\n\t    resizeCells: function(width, height, cells, opt) {\n\n\t        // `getBBox` method returns `null` if no elements provided.\n\t        // i.e. cells can be an array of links\n\t        var bbox = this.getCellsBBox(cells);\n\t        if (bbox) {\n\t            var sx = Math.max(width / bbox.width, 0);\n\t            var sy = Math.max(height / bbox.height, 0);\n\t            invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    startBatch: function(name, data) {\n\n\t        data = data || {};\n\t        this._batches[name] = (this._batches[name] || 0) + 1;\n\n\t        return this.trigger('batch:start', assign({}, data, { batchName: name }));\n\t    },\n\n\t    stopBatch: function(name, data) {\n\n\t        data = data || {};\n\t        this._batches[name] = (this._batches[name] || 0) - 1;\n\n\t        return this.trigger('batch:stop', assign({}, data, { batchName: name }));\n\t    },\n\n\t    hasActiveBatch: function(name) {\n\n\t        var batches = this._batches;\n\t        var names;\n\n\t        if (arguments.length === 0) {\n\t            names = Object.keys(batches);\n\t        } else if (Array.isArray(name)) {\n\t            names = name;\n\t        } else {\n\t            names = [name];\n\t        }\n\n\t        return names.some(function (batch) { return batches[batch] > 0; });\n\t    }\n\n\t}, {\n\n\t    validations: {\n\n\t        multiLinks: function(graph, link) {\n\n\t            // Do not allow multiple links to have the same source and target.\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\n\t            if (source.id && target.id) {\n\n\t                var sourceModel = link.getSourceCell();\n\t                if (sourceModel) {\n\n\t                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n\t                    var sameLinks = connectedLinks.filter(function(_link) {\n\n\t                        var ref = _link.attributes;\n\t                        var _source = ref.source;\n\t                        var _target = ref.target;\n\t                        return _source && _source.id === source.id &&\n\t                            (!_source.port || (_source.port === source.port)) &&\n\t                            _target && _target.id === target.id &&\n\t                            (!_target.port || (_target.port === target.port));\n\n\t                    });\n\n\t                    if (sameLinks.length > 1) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\n\t            return true;\n\t        },\n\n\t        linkPinning: function(_graph, link) {\n\t            var ref = link.attributes;\n\t            var source = ref.source;\n\t            var target = ref.target;\n\t            return source.id && target.id;\n\t        }\n\t    }\n\n\t});\n\n\twrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n\n\tvar views = {};\n\n\tvar View = Backbone.View.extend({\n\n\t    options: {},\n\t    theme: null,\n\t    themeClassNamePrefix: addClassNamePrefix('theme-'),\n\t    requireSetThemeOverride: false,\n\t    defaultTheme: config.defaultTheme,\n\t    children: null,\n\t    childNodes: null,\n\n\t    DETACHABLE: true,\n\t    UPDATE_PRIORITY: 2,\n\t    FLAG_INSERT: 1<<30,\n\t    FLAG_REMOVE: 1<<29,\n\n\t    constructor: function(options) {\n\n\t        this.requireSetThemeOverride = options && !!options.theme;\n\t        this.options = assign({}, this.options, options);\n\n\t        Backbone.View.call(this, options);\n\t    },\n\n\t    initialize: function() {\n\n\t        views[this.cid] = this;\n\n\t        this.setTheme(this.options.theme || this.defaultTheme);\n\t        this.init();\n\t    },\n\n\t    unmount: function() {\n\t        if (this.svgElement) {\n\t            this.vel.remove();\n\t        } else {\n\t            this.$el.remove();\n\t        }\n\t    },\n\n\t    renderChildren: function(children) {\n\t        children || (children = result(this, 'children'));\n\t        if (children) {\n\t            var isSVG = this.svgElement;\n\t            var namespace = V.namespace[isSVG ? 'svg' : 'xhtml'];\n\t            var doc = parseDOMJSON(children, namespace);\n\t            (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n\t            this.childNodes = doc.selectors;\n\t        }\n\t        return this;\n\t    },\n\n\t    findAttribute: function(attributeName, node) {\n\n\t        var currentNode = node;\n\n\t        while (currentNode && currentNode.nodeType === 1) {\n\t            var attributeValue = currentNode.getAttribute(attributeName);\n\t            // attribute found\n\t            if (attributeValue) { return attributeValue; }\n\t            // do not climb up the DOM\n\t            if (currentNode === this.el) { return null; }\n\t            // try parent node\n\t            currentNode = currentNode.parentNode;\n\t        }\n\n\t        return null;\n\t    },\n\n\t    // Override the Backbone `_ensureElement()` method in order to create an\n\t    // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n\t    // Expose class name setter as a separate method.\n\t    _ensureElement: function() {\n\t        if (!this.el) {\n\t            var tagName = result(this, 'tagName');\n\t            var attrs = assign({}, result(this, 'attributes'));\n\t            var style = assign({}, result(this, 'style'));\n\t            if (this.id) { attrs.id = result(this, 'id'); }\n\t            this.setElement(this._createElement(tagName));\n\t            this._setAttributes(attrs);\n\t            this._setStyle(style);\n\t        } else {\n\t            this.setElement(result(this, 'el'));\n\t        }\n\t        this._ensureElClassName();\n\t    },\n\n\t    _setAttributes: function(attrs) {\n\t        if (this.svgElement) {\n\t            this.vel.attr(attrs);\n\t        } else {\n\t            this.$el.attr(attrs);\n\t        }\n\t    },\n\n\t    _setStyle: function(style) {\n\t        this.$el.css(style);\n\t    },\n\n\t    _createElement: function(tagName) {\n\t        if (this.svgElement) {\n\t            return document.createElementNS(V.namespace.svg, tagName);\n\t        } else {\n\t            return document.createElement(tagName);\n\t        }\n\t    },\n\n\t    // Utilize an alternative DOM manipulation API by\n\t    // adding an element reference wrapped in Vectorizer.\n\t    _setElement: function(el) {\n\t        this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\n\t        this.el = this.$el[0];\n\t        if (this.svgElement) { this.vel = V(this.el); }\n\t    },\n\n\t    _ensureElClassName: function() {\n\t        var className = result(this, 'className');\n\t        if (!className) { return; }\n\t        var prefixedClassName = addClassNamePrefix(className);\n\t        // Note: className removal here kept for backwards compatibility only\n\t        if (this.svgElement) {\n\t            this.vel.removeClass(className).addClass(prefixedClassName);\n\t        } else {\n\t            this.$el.removeClass(className).addClass(prefixedClassName);\n\t        }\n\t    },\n\n\t    init: function() {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t    },\n\n\t    onRender: function() {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t    },\n\n\t    confirmUpdate: function() {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t        return 0;\n\t    },\n\n\t    setTheme: function(theme, opt) {\n\n\t        opt = opt || {};\n\n\t        // Theme is already set, override is required, and override has not been set.\n\t        // Don't set the theme.\n\t        if (this.theme && this.requireSetThemeOverride && !opt.override) {\n\t            return this;\n\t        }\n\n\t        this.removeThemeClassName();\n\t        this.addThemeClassName(theme);\n\t        this.onSetTheme(this.theme/* oldTheme */, theme/* newTheme */);\n\t        this.theme = theme;\n\n\t        return this;\n\t    },\n\n\t    addThemeClassName: function(theme) {\n\n\t        theme = theme || this.theme;\n\n\t        var className = this.themeClassNamePrefix + theme;\n\n\t        if (this.svgElement) {\n\t            this.vel.addClass(className);\n\t        } else {\n\t            this.$el.addClass(className);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    removeThemeClassName: function(theme) {\n\n\t        theme = theme || this.theme;\n\n\t        var className = this.themeClassNamePrefix + theme;\n\n\t        if (this.svgElement) {\n\t            this.vel.removeClass(className);\n\t        } else {\n\t            this.$el.removeClass(className);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    onSetTheme: function(oldTheme, newTheme) {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t    },\n\n\t    remove: function() {\n\n\t        this.onRemove();\n\t        this.undelegateDocumentEvents();\n\n\t        views[this.cid] = null;\n\n\t        Backbone.View.prototype.remove.apply(this, arguments);\n\n\t        return this;\n\t    },\n\n\t    onRemove: function() {\n\t        // Intentionally empty.\n\t        // This method is meant to be overridden.\n\t    },\n\n\t    getEventNamespace: function() {\n\t        // Returns a per-session unique namespace\n\t        return '.joint-event-ns-' + this.cid;\n\t    },\n\n\t    delegateElementEvents: function(element, events, data) {\n\t        if (!events) { return this; }\n\t        data || (data = {});\n\t        var eventNS = this.getEventNamespace();\n\t        for (var eventName in events) {\n\t            var method = events[eventName];\n\t            if (typeof method !== 'function') { method = this[method]; }\n\t            if (!method) { continue; }\n\t            $(element).on(eventName + eventNS, data, method.bind(this));\n\t        }\n\t        return this;\n\t    },\n\n\t    undelegateElementEvents: function(element) {\n\t        $(element).off(this.getEventNamespace());\n\t        return this;\n\t    },\n\n\t    delegateDocumentEvents: function(events, data) {\n\t        events || (events = result(this, 'documentEvents'));\n\t        return this.delegateElementEvents(document, events, data);\n\t    },\n\n\t    undelegateDocumentEvents: function() {\n\t        return this.undelegateElementEvents(document);\n\t    },\n\n\t    eventData: function(evt, data) {\n\t        if (!evt) { throw new Error('eventData(): event object required.'); }\n\t        var currentData = evt.data;\n\t        var key = '__' + this.cid + '__';\n\t        if (data === undefined) {\n\t            if (!currentData) { return {}; }\n\t            return currentData[key] || {};\n\t        }\n\t        currentData || (currentData = evt.data = {});\n\t        currentData[key] || (currentData[key] = {});\n\t        assign(currentData[key], data);\n\t        return this;\n\t    },\n\n\t    stopPropagation: function(evt) {\n\t        this.eventData(evt, { propagationStopped: true });\n\t        return this;\n\t    },\n\n\t    isPropagationStopped: function(evt) {\n\t        return !!this.eventData(evt).propagationStopped;\n\t    }\n\n\t}, {\n\n\t    extend: function() {\n\n\t        var args = Array.from(arguments);\n\n\t        // Deep clone the prototype and static properties objects.\n\t        // This prevents unexpected behavior where some properties are overwritten outside of this function.\n\t        var protoProps = args[0] && assign({}, args[0]) || {};\n\t        var staticProps = args[1] && assign({}, args[1]) || {};\n\n\t        // Need the real render method so that we can wrap it and call it later.\n\t        var renderFn = protoProps.render || (this.prototype && this.prototype.render) || null;\n\n\t        /*\n\t            Wrap the real render method so that:\n\t                .. `onRender` is always called.\n\t                .. `this` is always returned.\n\t        */\n\t        protoProps.render = function() {\n\n\t            if (typeof renderFn === 'function') {\n\t                // Call the original render method.\n\t                renderFn.apply(this, arguments);\n\t            }\n\n\t            if (this.render.__render__ === renderFn) {\n\t                // Should always call onRender() method.\n\t                // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n\t                this.onRender();\n\t            }\n\n\t            // Should always return itself.\n\t            return this;\n\t        };\n\n\t        protoProps.render.__render__ = renderFn;\n\n\t        return Backbone.View.extend.call(this, protoProps, staticProps);\n\t    }\n\t});\n\n\tvar index$1 = ({\n\t\tviews: views,\n\t\tView: View\n\t});\n\n\tfunction toArray$1(obj) {\n\t    if (!obj) { return []; }\n\t    if (Array.isArray(obj)) { return obj; }\n\t    return [obj];\n\t}\n\n\tvar HighlighterView = View.extend({\n\n\t    tagName: 'g',\n\t    svgElement: true,\n\t    className: 'highlight',\n\n\t    HIGHLIGHT_FLAG: 1,\n\t    UPDATE_PRIORITY: 3,\n\t    DETACHABLE: false,\n\t    UPDATABLE: true,\n\t    MOUNTABLE: true,\n\n\t    cellView: null,\n\t    nodeSelector: null,\n\t    node: null,\n\t    updateRequested: false,\n\t    transformGroup: null,\n\n\t    requestUpdate: function requestUpdate(cellView, nodeSelector) {\n\t        var paper = cellView.paper;\n\t        this.cellView = cellView;\n\t        this.nodeSelector = nodeSelector;\n\t        if (paper) {\n\t            this.updateRequested = true;\n\t            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n\t        }\n\t    },\n\n\t    confirmUpdate: function confirmUpdate() {\n\t        // The cellView is now rendered/updated since it has a higher update priority.\n\t        this.updateRequested = false;\n\t        var ref = this;\n\t        var cellView = ref.cellView;\n\t        var nodeSelector = ref.nodeSelector;\n\t        this.update(cellView, nodeSelector);\n\t        this.mount();\n\t        this.transform();\n\t        return 0;\n\t    },\n\n\t    findNode: function findNode(cellView, nodeSelector) {\n\t        var assign, assign$1;\n\n\t        if ( nodeSelector === void 0 ) nodeSelector = null;\n\t        var el;\n\t        if (typeof nodeSelector === 'string') {\n\t            (assign = cellView.findBySelector(nodeSelector), el = assign[0]);\n\t        } else if (isPlainObject(nodeSelector)) {\n\t            var isLink = cellView.model.isLink();\n\t            var label = nodeSelector.label; if ( label === void 0 ) label = null;\n\t            var port = nodeSelector.port;\n\t            var selector = nodeSelector.selector;\n\t            if (isLink && label !== null) {\n\t                // Link Label Selector\n\t                el = cellView.findLabelNode(label, selector);\n\t            } else if (!isLink && port) {\n\t                // Element Port Selector\n\t                el = cellView.findPortNode(port, selector);\n\t            } else {\n\t                // Cell Selector\n\t                (assign$1 = cellView.findBySelector(selector), el = assign$1[0]);\n\t            }\n\t        } else if (nodeSelector) {\n\t            el = V.toNode(nodeSelector);\n\t            if (!(el instanceof SVGElement)) { el = null; }\n\t        }\n\t        return el ? el : null;\n\t    },\n\n\t    mount: function mount() {\n\t        var ref = this;\n\t        var MOUNTABLE = ref.MOUNTABLE;\n\t        var cellView = ref.cellView;\n\t        var el = ref.el;\n\t        var options = ref.options;\n\t        var transformGroup = ref.transformGroup;\n\t        if (!MOUNTABLE || transformGroup) { return; }\n\t        var cellViewRoot = cellView.vel;\n\t        var paper = cellView.paper;\n\t        var layerName = options.layer;\n\t        if (layerName) {\n\t            this.transformGroup = V('g')\n\t                .addClass('highlight-transform')\n\t                .append(el)\n\t                .appendTo(paper.getLayerNode(layerName));\n\t        } else {\n\t            // TODO: prepend vs append\n\t            if (!el.parentNode || el.nextSibling) {\n\t                // Not appended yet or not the last child\n\t                cellViewRoot.append(el);\n\t            }\n\t        }\n\t    },\n\n\t    unmount: function unmount() {\n\t        var ref = this;\n\t        var MOUNTABLE = ref.MOUNTABLE;\n\t        var transformGroup = ref.transformGroup;\n\t        var vel = ref.vel;\n\t        if (!MOUNTABLE) { return; }\n\t        if (transformGroup) {\n\t            this.transformGroup = null;\n\t            transformGroup.remove();\n\t        } else {\n\t            vel.remove();\n\t        }\n\t    },\n\n\t    transform: function transform() {\n\t        var ref = this;\n\t        var transformGroup = ref.transformGroup;\n\t        var cellView = ref.cellView;\n\t        var updateRequested = ref.updateRequested;\n\t        if (!transformGroup || cellView.model.isLink() || updateRequested) { return; }\n\t        var translateMatrix = cellView.getRootTranslateMatrix();\n\t        var rotateMatrix = cellView.getRootRotateMatrix();\n\t        var transformMatrix = translateMatrix.multiply(rotateMatrix);\n\t        transformGroup.attr('transform', V.matrixToTransformString(transformMatrix));\n\t    },\n\n\t    update: function update() {\n\t        var ref = this;\n\t        var prevNode = ref.node;\n\t        var cellView = ref.cellView;\n\t        var nodeSelector = ref.nodeSelector;\n\t        var updateRequested = ref.updateRequested;\n\t        var id = ref.id;\n\t        if (updateRequested) { return; }\n\t        var node = this.node = this.findNode(cellView, nodeSelector);\n\t        if (prevNode) {\n\t            this.unhighlight(cellView, prevNode);\n\t        }\n\t        if (node) {\n\t            this.highlight(cellView, node);\n\t            this.mount();\n\t        } else {\n\t            this.unmount();\n\t            cellView.notify('cell:highlight:invalid', id, this);\n\t        }\n\t    },\n\n\t    onRemove: function onRemove() {\n\t        var ref = this;\n\t        var node = ref.node;\n\t        var cellView = ref.cellView;\n\t        var id = ref.id;\n\t        var constructor = ref.constructor;\n\t        if (node) {\n\t            this.unhighlight(cellView, node);\n\t        }\n\t        this.unmount();\n\t        constructor._removeRef(cellView, id);\n\t    },\n\n\t    highlight: function highlight(_cellView, _node) {\n\t        // to be overridden\n\t    },\n\n\t    unhighlight: function unhighlight(_cellView, _node) {\n\t        // to be overridden\n\t    }\n\n\t}, {\n\n\t    _views: {},\n\n\t    // Used internally by CellView highlight()\n\t    highlight: function(cellView, node, opt) {\n\t        var id = this.uniqueId(node, opt);\n\t        this.add(cellView, node, id, opt);\n\t    },\n\n\t    // Used internally by CellView unhighlight()\n\t    unhighlight: function(cellView, node, opt) {\n\t        var id = this.uniqueId(node, opt);\n\t        this.remove(cellView, id);\n\t    },\n\n\t    get: function get(cellView, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        var cid = cellView.cid;\n\t        var ref$2 = this;\n\t        var _views = ref$2._views;\n\t        var refs = _views[cid];\n\t        if (id === null) {\n\t            // all highlighters\n\t            var views = [];\n\t            if (!refs) { return views; }\n\t            for (var hid in refs) {\n\t                var ref = refs[hid];\n\t                if (ref instanceof this) {\n\t                    views.push(ref);\n\t                }\n\t            }\n\t            return views;\n\t        } else {\n\t            // single highlighter\n\t            if (!refs) { return null; }\n\t            if (id in refs) {\n\t                var ref$1 = refs[id];\n\t                if (ref$1 instanceof this) { return ref$1; }\n\t            }\n\t            return null;\n\t        }\n\t    },\n\n\t    add: function add(cellView, nodeSelector, id, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        if (!id) { throw new Error('dia.HighlighterView: An ID required.'); }\n\t        // Search the existing view amongst all the highlighters\n\t        var previousView = HighlighterView.get(cellView, id);\n\t        if (previousView) { previousView.remove(); }\n\t        var view = new this(opt);\n\t        view.id = id;\n\t        this._addRef(cellView, id, view);\n\t        view.requestUpdate(cellView, nodeSelector);\n\t        return view;\n\t    },\n\n\t    _addRef: function _addRef(cellView, id, view) {\n\t        var cid = cellView.cid;\n\t        var ref = this;\n\t        var _views = ref._views;\n\t        var refs = _views[cid];\n\t        if (!refs) { refs = _views[cid] = {}; }\n\t        refs[id] = view;\n\t    },\n\n\t    _removeRef: function _removeRef(cellView, id) {\n\t        var cid = cellView.cid;\n\t        var ref = this;\n\t        var _views = ref._views;\n\t        var refs = _views[cid];\n\t        if (!refs) { return; }\n\t        if (id) { delete refs[id]; }\n\t        for (var _ in refs) { return; }\n\t        delete _views[cid];\n\t    },\n\n\t    remove: function remove(cellView, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        toArray$1(this.get(cellView, id)).forEach(function (view) {\n\t            view.remove();\n\t        });\n\t    },\n\n\t    update: function update(cellView, id, dirty) {\n\t        if ( id === void 0 ) id = null;\n\t        if ( dirty === void 0 ) dirty = false;\n\n\t        toArray$1(this.get(cellView, id)).forEach(function (view) {\n\t            if (dirty || view.UPDATABLE) { view.update(); }\n\t        });\n\t    },\n\n\t    transform: function transform(cellView, id) {\n\t        if ( id === void 0 ) id = null;\n\n\t        toArray$1(this.get(cellView, id)).forEach(function (view) {\n\t            if (view.UPDATABLE) { view.transform(); }\n\t        });\n\t    },\n\n\t    uniqueId: function uniqueId(node, opt) {\n\t        if ( opt === void 0 ) opt = '';\n\n\t        return V.ensureId(node) + JSON.stringify(opt);\n\t    }\n\n\t});\n\n\tvar HighlightingTypes = {\n\t    DEFAULT: 'default',\n\t    EMBEDDING: 'embedding',\n\t    CONNECTING: 'connecting',\n\t    MAGNET_AVAILABILITY: 'magnetAvailability',\n\t    ELEMENT_AVAILABILITY: 'elementAvailability'\n\t};\n\n\t// CellView base view and controller.\n\t// --------------------------------------------\n\n\t// This is the base view and controller for `ElementView` and `LinkView`.\n\tvar CellView = View.extend({\n\n\t    tagName: 'g',\n\n\t    svgElement: true,\n\n\t    selector: 'root',\n\n\t    metrics: null,\n\n\t    className: function() {\n\n\t        var classNames = ['cell'];\n\t        var type = this.model.get('type');\n\n\t        if (type) {\n\n\t            type.toLowerCase().split('.').forEach(function(value, index, list) {\n\t                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n\t            });\n\t        }\n\n\t        return classNames.join(' ');\n\t    },\n\n\t    _presentationAttributes: null,\n\t    _flags: null,\n\n\t    setFlags: function() {\n\t        var flags = {};\n\t        var attributes = {};\n\t        var shift = 0;\n\t        var i, n, label;\n\t        var presentationAttributes = this.presentationAttributes;\n\t        for (var attribute in presentationAttributes) {\n\t            if (!presentationAttributes.hasOwnProperty(attribute)) { continue; }\n\t            var labels = presentationAttributes[attribute];\n\t            if (!Array.isArray(labels)) { labels = [labels]; }\n\t            for (i = 0, n = labels.length; i < n; i++) {\n\t                label = labels[i];\n\t                var flag = flags[label];\n\t                if (!flag) {\n\t                    flag = flags[label] = 1<<(shift++);\n\t                }\n\t                attributes[attribute] |= flag;\n\t            }\n\t        }\n\t        var initFlag = this.initFlag;\n\t        if (!Array.isArray(initFlag)) { initFlag = [initFlag]; }\n\t        for (i = 0, n = initFlag.length; i < n; i++) {\n\t            label = initFlag[i];\n\t            if (!flags[label]) { flags[label] = 1<<(shift++); }\n\t        }\n\n\t        // 26 - 30 are reserved for paper flags\n\t        // 31+ overflows maximal number\n\t        if (shift > 25) { throw new Error('dia.CellView: Maximum number of flags exceeded.'); }\n\n\t        this._flags = flags;\n\t        this._presentationAttributes = attributes;\n\t    },\n\n\t    hasFlag: function(flag, label) {\n\t        return flag & this.getFlag(label);\n\t    },\n\n\t    removeFlag: function(flag, label) {\n\t        return flag ^ (flag & this.getFlag(label));\n\t    },\n\n\t    getFlag: function(label) {\n\t        var flags = this._flags;\n\t        if (!flags) { return 0; }\n\t        var flag = 0;\n\t        if (Array.isArray(label)) {\n\t            for (var i = 0, n = label.length; i < n; i++) { flag |= flags[label[i]]; }\n\t        } else {\n\t            flag |= flags[label];\n\t        }\n\t        return flag;\n\t    },\n\n\t    attributes: function() {\n\t        var cell = this.model;\n\t        return {\n\t            'model-id': cell.id,\n\t            'data-type': cell.attributes.type\n\t        };\n\t    },\n\n\t    constructor: function(options) {\n\n\t        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n\t        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n\t        // still be associated to the same object among all those clients. This is necessary for real-time\n\t        // collaboration mechanism.\n\t        options.id = options.id || guid(this);\n\n\t        View.call(this, options);\n\t    },\n\n\t    initialize: function() {\n\n\t        this.setFlags();\n\n\t        View.prototype.initialize.apply(this, arguments);\n\n\t        this.cleanNodesCache();\n\n\t        // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n\t        this.$el.data('view', this);\n\n\t        this.startListening();\n\t    },\n\n\t    startListening: function() {\n\t        this.listenTo(this.model, 'change', this.onAttributesChange);\n\t    },\n\n\t    onAttributesChange: function(model, opt) {\n\t        var flag = model.getChangeFlag(this._presentationAttributes);\n\t        if (opt.updateHandled || !flag) { return; }\n\t        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) { flag |= this.getFlag('RENDER'); }\n\t        // TODO: tool changes does not need to be sync\n\t        // Fix Segments tools\n\t        if (opt.tool) { opt.async = false; }\n\t        this.requestUpdate(flag, opt);\n\t    },\n\n\t    requestUpdate: function(flags, opt) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        if (paper && flags > 0) {\n\t            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n\t        }\n\t    },\n\n\t    parseDOMJSON: function(markup, root) {\n\n\t        var doc = parseDOMJSON(markup);\n\t        var selectors = doc.selectors;\n\t        var groups = doc.groupSelectors;\n\t        for (var group in groups) {\n\t            if (selectors[group]) { throw new Error('dia.CellView: ambiguous group selector'); }\n\t            selectors[group] = groups[group];\n\t        }\n\t        if (root) {\n\t            var rootSelector = this.selector;\n\t            if (selectors[rootSelector]) { throw new Error('dia.CellView: ambiguous root selector.'); }\n\t            selectors[rootSelector] = root;\n\t        }\n\t        return { fragment: doc.fragment, selectors: selectors };\n\t    },\n\n\t    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n\t    // Example: `can('vertexMove')`, `can('labelMove')`.\n\t    can: function(feature) {\n\n\t        var interactive = isFunction(this.options.interactive)\n\t            ? this.options.interactive(this)\n\t            : this.options.interactive;\n\n\t        return (isObject$1(interactive) && interactive[feature] !== false) ||\n\t            (isBoolean(interactive) && interactive !== false);\n\t    },\n\n\t    findBySelector: function(selector, root, selectors) {\n\n\t        root || (root = this.el);\n\t        selectors || (selectors = this.selectors);\n\n\t        // These are either descendants of `this.$el` of `this.$el` itself.\n\t        // `.` is a special selector used to select the wrapping `<g>` element.\n\t        if (!selector || selector === '.') { return [root]; }\n\t        if (selectors) {\n\t            var nodes = selectors[selector];\n\t            if (nodes) {\n\t                if (Array.isArray(nodes)) { return nodes; }\n\t                return [nodes];\n\t            }\n\t        }\n\n\t        // Maintaining backwards compatibility\n\t        // e.g. `circle:first` would fail with querySelector() call\n\t        if (config.useCSSSelectors) { return $(root).find(selector).toArray(); }\n\n\t        return [];\n\t    },\n\n\t    notify: function(eventName) {\n\n\t        if (this.paper) {\n\n\t            var args = Array.prototype.slice.call(arguments, 1);\n\n\t            // Trigger the event on both the element itself and also on the paper.\n\t            this.trigger.apply(this, [eventName].concat(args));\n\n\t            // Paper event handlers receive the view object as the first argument.\n\t            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n\t        }\n\t    },\n\n\t    getBBox: function(opt) {\n\n\t        var bbox;\n\t        if (opt && opt.useModelGeometry) {\n\t            var model = this.model;\n\t            bbox = model.getBBox().bbox(model.angle());\n\t        } else {\n\t            bbox = this.getNodeBBox(this.el);\n\t        }\n\n\t        return this.paper.localToPaperRect(bbox);\n\t    },\n\n\t    getNodeBBox: function(magnet) {\n\n\t        var rect = this.getNodeBoundingRect(magnet);\n\t        var magnetMatrix = this.getNodeMatrix(magnet);\n\t        var translateMatrix = this.getRootTranslateMatrix();\n\t        var rotateMatrix = this.getRootRotateMatrix();\n\t        return V.transformRect(rect, translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix));\n\t    },\n\n\t    getNodeUnrotatedBBox: function(magnet) {\n\n\t        var rect = this.getNodeBoundingRect(magnet);\n\t        var magnetMatrix = this.getNodeMatrix(magnet);\n\t        var translateMatrix = this.getRootTranslateMatrix();\n\t        return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n\t    },\n\n\t    getRootTranslateMatrix: function() {\n\n\t        var model = this.model;\n\t        var position = model.position();\n\t        var mt = V.createSVGMatrix().translate(position.x, position.y);\n\t        return mt;\n\t    },\n\n\t    getRootRotateMatrix: function() {\n\n\t        var mr = V.createSVGMatrix();\n\t        var model = this.model;\n\t        var angle = model.angle();\n\t        if (angle) {\n\t            var bbox = model.getBBox();\n\t            var cx = bbox.width / 2;\n\t            var cy = bbox.height / 2;\n\t            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n\t        }\n\t        return mr;\n\t    },\n\n\t    _notifyHighlight: function(eventName, el, opt) {\n\t        var assign, assign$1;\n\n\t        if ( opt === void 0 ) opt = {};\n\t        var ref = this;\n\t        var rootNode = ref.el;\n\t        var node;\n\t        if (typeof el === 'string') {\n\t            (assign = this.findBySelector(el), node = assign[0], node = node === void 0 ? rootNode : node);\n\t        } else {\n\t            (assign$1 = this.$(el), node = assign$1[0], node = node === void 0 ? rootNode : node);\n\t        }\n\t        // set partial flag if the highlighted element is not the entire view.\n\t        opt.partial = (node !== rootNode);\n\t        // translate type flag into a type string\n\t        if (opt.type === undefined) {\n\t            var type;\n\t            switch (true) {\n\t                case opt.embedding:\n\t                    type = HighlightingTypes.EMBEDDING;\n\t                    break;\n\t                case opt.connecting:\n\t                    type = HighlightingTypes.CONNECTING;\n\t                    break;\n\t                case opt.magnetAvailability:\n\t                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n\t                    break;\n\t                case opt.elementAvailability:\n\t                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n\t                    break;\n\t                default:\n\t                    type = HighlightingTypes.DEFAULT;\n\t                    break;\n\t            }\n\t            opt.type = type;\n\t        }\n\t        this.notify(eventName, node, opt);\n\t        return this;\n\t    },\n\n\t    highlight: function(el, opt) {\n\t        return this._notifyHighlight('cell:highlight', el, opt);\n\t    },\n\n\t    unhighlight: function(el, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        return this._notifyHighlight('cell:unhighlight', el, opt);\n\t    },\n\n\t    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n\t    // an element found, return the root element of the cell view.\n\t    findMagnet: function(el) {\n\n\t        var root = this.el;\n\t        var magnet = this.$(el)[0];\n\t        if (!magnet) {\n\t            magnet = root;\n\t        }\n\n\t        do {\n\t            var magnetAttribute = magnet.getAttribute('magnet');\n\t            var isMagnetRoot = (magnet === root);\n\t            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n\t                return magnet;\n\t            }\n\t            if (isMagnetRoot) {\n\t                // If the overall cell has set `magnet === false`, then return `undefined` to\n\t                // announce there is no magnet found for this cell.\n\t                // This is especially useful to set on cells that have 'ports'. In this case,\n\t                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n\t                return undefined;\n\t            }\n\t            magnet = magnet.parentNode;\n\t        } while (magnet);\n\n\t        return undefined;\n\t    },\n\n\t    findProxyNode: function(el, type) {\n\t        el || (el = this.el);\n\t        var nodeSelector = el.getAttribute((type + \"-selector\"));\n\t        if (nodeSelector) {\n\t            var ref = this.findBySelector(nodeSelector);\n\t            var proxyNode = ref[0];\n\t            if (proxyNode) { return proxyNode; }\n\t        }\n\t        return el;\n\t    },\n\n\t    // Construct a unique selector for the `el` element within this view.\n\t    // `prevSelector` is being collected through the recursive call.\n\t    // No value for `prevSelector` is expected when using this method.\n\t    getSelector: function(el, prevSelector) {\n\n\t        var selector;\n\n\t        if (el === this.el) {\n\t            if (typeof prevSelector === 'string') { selector = '> ' + prevSelector; }\n\t            return selector;\n\t        }\n\n\t        if (el) {\n\n\t            var nthChild = V(el).index() + 1;\n\t            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n\t            if (prevSelector) {\n\t                selector += ' > ' + prevSelector;\n\t            }\n\n\t            selector = this.getSelector(el.parentNode, selector);\n\t        }\n\n\t        return selector;\n\t    },\n\n\t    getLinkEnd: function(magnet) {\n\t        var ref;\n\n\t        var args = [], len = arguments.length - 1;\n\t        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n\t        var model = this.model;\n\t        var id = model.id;\n\t        var port = this.findAttribute('port', magnet);\n\t        // Find a unique `selector` of the element under pointer that is a magnet.\n\t        var selector = magnet.getAttribute('joint-selector');\n\n\t        var end = { id: id };\n\t        if (selector != null) { end.magnet = selector; }\n\t        if (port != null) {\n\t            end.port = port;\n\t            if (!model.hasPort(port) && !selector) {\n\t                // port created via the `port` attribute (not API)\n\t                end.selector = this.getSelector(magnet);\n\t            }\n\t        } else if (selector == null && this.el !== magnet) {\n\t            end.selector = this.getSelector(magnet);\n\t        }\n\n\t        return (ref = this).customizeLinkEnd.apply(ref, [ end, magnet ].concat( args ));\n\t    },\n\n\t    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var ref$1 = paper.options;\n\t        var connectionStrategy = ref$1.connectionStrategy;\n\t        if (typeof connectionStrategy === 'function') {\n\t            var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n\t            if (strategy) { return strategy; }\n\t        }\n\t        return end;\n\t    },\n\n\t    getMagnetFromLinkEnd: function(end) {\n\n\t        var root = this.el;\n\t        var port = end.port;\n\t        var selector = end.magnet;\n\t        var model = this.model;\n\t        var magnet;\n\t        if (port != null && model.isElement() && model.hasPort(port)) {\n\t            magnet = this.findPortNode(port, selector) || root;\n\t        } else {\n\t            if (!selector) { selector = end.selector; }\n\t            if (!selector && port != null) {\n\t                // link end has only `id` and `port` property referencing\n\t                // a port created via the `port` attribute (not API).\n\t                selector = '[port=\"' + port + '\"]';\n\t            }\n\t            magnet = this.findBySelector(selector, root, this.selectors)[0];\n\t        }\n\n\t        return this.findProxyNode(magnet, 'magnet');\n\t    },\n\n\t    getAttributeDefinition: function(attrName) {\n\n\t        return this.model.constructor.getAttributeDefinition(attrName);\n\t    },\n\n\t    setNodeAttributes: function(node, attrs) {\n\n\t        if (!isEmpty(attrs)) {\n\t            if (node instanceof SVGElement) {\n\t                V(node).attr(attrs);\n\t            } else {\n\t                $(node).attr(attrs);\n\t            }\n\t        }\n\t    },\n\n\t    processNodeAttributes: function(node, attrs) {\n\n\t        var attrName, attrVal, def, i, n;\n\t        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n\t        var relatives = [];\n\t        // divide the attributes between normal and special\n\t        for (attrName in attrs) {\n\t            if (!attrs.hasOwnProperty(attrName)) { continue; }\n\t            attrVal = attrs[attrName];\n\t            def = this.getAttributeDefinition(attrName);\n\t            if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs))) {\n\t                if (isString(def.set)) {\n\t                    normalAttrs || (normalAttrs = {});\n\t                    normalAttrs[def.set] = attrVal;\n\t                }\n\t                if (attrVal !== null) {\n\t                    relatives.push(attrName, def);\n\t                }\n\t            } else {\n\t                normalAttrs || (normalAttrs = {});\n\t                normalAttrs[toKebabCase(attrName)] = attrVal;\n\t            }\n\t        }\n\n\t        // handle the rest of attributes via related method\n\t        // from the special attributes namespace.\n\t        for (i = 0, n = relatives.length; i < n; i+=2) {\n\t            attrName = relatives[i];\n\t            def = relatives[i+1];\n\t            attrVal = attrs[attrName];\n\t            if (isFunction(def.set)) {\n\t                setAttrs || (setAttrs = {});\n\t                setAttrs[attrName] = attrVal;\n\t            }\n\t            if (isFunction(def.position)) {\n\t                positionAttrs || (positionAttrs = {});\n\t                positionAttrs[attrName] = attrVal;\n\t            }\n\t            if (isFunction(def.offset)) {\n\t                offsetAttrs || (offsetAttrs = {});\n\t                offsetAttrs[attrName] = attrVal;\n\t            }\n\t        }\n\n\t        return {\n\t            raw: attrs,\n\t            normal: normalAttrs,\n\t            set: setAttrs,\n\t            position: positionAttrs,\n\t            offset: offsetAttrs\n\t        };\n\t    },\n\n\t    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n\t        opt || (opt = {});\n\n\t        var attrName, attrVal, def;\n\t        var rawAttrs = attrs.raw || {};\n\t        var nodeAttrs = attrs.normal || {};\n\t        var setAttrs = attrs.set;\n\t        var positionAttrs = attrs.position;\n\t        var offsetAttrs = attrs.offset;\n\n\t        for (attrName in setAttrs) {\n\t            attrVal = setAttrs[attrName];\n\t            def = this.getAttributeDefinition(attrName);\n\t            // SET - set function should return attributes to be set on the node,\n\t            // which will affect the node dimensions based on the reference bounding\n\t            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n\t            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n\t            if (isObject$1(setResult)) {\n\t                assign(nodeAttrs, setResult);\n\t            } else if (setResult !== undefined) {\n\t                nodeAttrs[attrName] = setResult;\n\t            }\n\t        }\n\n\t        if (node instanceof HTMLElement) {\n\t            // TODO: setting the `transform` attribute on HTMLElements\n\t            // via `node.style.transform = 'matrix(...)';` would introduce\n\t            // a breaking change (e.g. basic.TextBlock).\n\t            this.setNodeAttributes(node, nodeAttrs);\n\t            return;\n\t        }\n\n\t        // The final translation of the subelement.\n\t        var nodeTransform = nodeAttrs.transform;\n\t        var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n\t        var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n\t        if (nodeTransform) {\n\t            nodeAttrs = omit(nodeAttrs, 'transform');\n\t            nodeMatrix.e = nodeMatrix.f = 0;\n\t        }\n\n\t        // Calculate node scale determined by the scalable group\n\t        // only if later needed.\n\t        var sx, sy, translation;\n\t        if (positionAttrs || offsetAttrs) {\n\t            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n\t            sx = nodeScale.sx;\n\t            sy = nodeScale.sy;\n\t        }\n\n\t        var positioned = false;\n\t        for (attrName in positionAttrs) {\n\t            attrVal = positionAttrs[attrName];\n\t            def = this.getAttributeDefinition(attrName);\n\t            // POSITION - position function should return a point from the\n\t            // reference bounding box. The default position of the node is x:0, y:0 of\n\t            // the reference bounding box or could be further specify by some\n\t            // SVG attributes e.g. `x`, `y`\n\t            translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n\t            if (translation) {\n\t                nodePosition.offset(Point(translation).scale(sx, sy));\n\t                positioned || (positioned = true);\n\t            }\n\t        }\n\n\t        // The node bounding box could depend on the `size` set from the previous loop.\n\t        // Here we know, that all the size attributes have been already set.\n\t        this.setNodeAttributes(node, nodeAttrs);\n\n\t        var offseted = false;\n\t        if (offsetAttrs) {\n\t            // Check if the node is visible\n\t            var nodeBoundingRect = this.getNodeBoundingRect(node);\n\t            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n\t                var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n\t                for (attrName in offsetAttrs) {\n\t                    attrVal = offsetAttrs[attrName];\n\t                    def = this.getAttributeDefinition(attrName);\n\t                    // OFFSET - offset function should return a point from the element\n\t                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n\t                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n\t                    translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs);\n\t                    if (translation) {\n\t                        nodePosition.offset(Point(translation).scale(sx, sy));\n\t                        offseted || (offseted = true);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        // Do not touch node's transform attribute if there is no transformation applied.\n\t        if (nodeTransform !== undefined || positioned || offseted) {\n\t            // Round the coordinates to 1 decimal point.\n\t            nodePosition.round(1);\n\t            nodeMatrix.e = nodePosition.x;\n\t            nodeMatrix.f = nodePosition.y;\n\t            node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n\t            // TODO: store nodeMatrix metrics?\n\t        }\n\t    },\n\n\t    getNodeScale: function(node, scalableNode) {\n\n\t        // Check if the node is a descendant of the scalable group.\n\t        var sx, sy;\n\t        if (scalableNode && scalableNode.contains(node)) {\n\t            var scale = scalableNode.scale();\n\t            sx = 1 / scale.sx;\n\t            sy = 1 / scale.sy;\n\t        } else {\n\t            sx = 1;\n\t            sy = 1;\n\t        }\n\n\t        return { sx: sx, sy: sy };\n\t    },\n\n\t    cleanNodesCache: function() {\n\t        this.metrics = {};\n\t    },\n\n\t    nodeCache: function(magnet) {\n\n\t        var metrics = this.metrics;\n\t        // Don't use cache? It most likely a custom view with overridden update.\n\t        if (!metrics) { return {}; }\n\t        var id = V.ensureId(magnet);\n\t        var value = metrics[id];\n\t        if (!value) { value = metrics[id] = {}; }\n\t        return value;\n\t    },\n\n\t    getNodeData: function(magnet) {\n\n\t        var metrics = this.nodeCache(magnet);\n\t        if (!metrics.data) { metrics.data = {}; }\n\t        return metrics.data;\n\t    },\n\n\t    getNodeBoundingRect: function(magnet) {\n\n\t        var metrics = this.nodeCache(magnet);\n\t        if (metrics.boundingRect === undefined) { metrics.boundingRect = V(magnet).getBBox(); }\n\t        return new Rect(metrics.boundingRect);\n\t    },\n\n\t    getNodeMatrix: function(magnet) {\n\n\t        var metrics = this.nodeCache(magnet);\n\t        if (metrics.magnetMatrix === undefined) {\n\t            var target = this.rotatableNode || this.el;\n\t            metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n\t        }\n\t        return V.createSVGMatrix(metrics.magnetMatrix);\n\t    },\n\n\t    getNodeShape: function(magnet) {\n\n\t        var metrics = this.nodeCache(magnet);\n\t        if (metrics.geometryShape === undefined) { metrics.geometryShape = V(magnet).toGeometryShape(); }\n\t        return metrics.geometryShape.clone();\n\t    },\n\n\t    isNodeConnection: function(node) {\n\t        return this.model.isLink() && (!node || node === this.el);\n\t    },\n\n\t    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n\t        var i, n, nodeAttrs, nodeId;\n\t        var nodesAttrs = {};\n\t        var mergeIds = [];\n\t        for (var selector in attrs) {\n\t            if (!attrs.hasOwnProperty(selector)) { continue; }\n\t            nodeAttrs = attrs[selector];\n\t            if (!isPlainObject(nodeAttrs)) { continue; } // Not a valid selector-attributes pair\n\t            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n\t            for (i = 0, n = selected.length; i < n; i++) {\n\t                var node = selected[i];\n\t                nodeId = V.ensureId(node);\n\t                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n\t                // groupSelector referencing a single node is not \"unique\"\n\t                var unique = (selectors && selectors[selector] === node);\n\t                var prevNodeAttrs = nodesAttrs[nodeId];\n\t                if (prevNodeAttrs) {\n\t                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n\t                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n\t                    if (!prevNodeAttrs.array) {\n\t                        mergeIds.push(nodeId);\n\t                        prevNodeAttrs.array = true;\n\t                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n\t                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n\t                    }\n\t                    var attributes = prevNodeAttrs.attributes;\n\t                    var selectedLength = prevNodeAttrs.selectedLength;\n\t                    if (unique) {\n\t                        // node referenced by `selector`\n\t                        attributes.unshift(nodeAttrs);\n\t                        selectedLength.unshift(-1);\n\t                    } else {\n\t                        // node referenced by `groupSelector`\n\t                        var sortIndex = sortedIndex(selectedLength, n);\n\t                        attributes.splice(sortIndex, 0, nodeAttrs);\n\t                        selectedLength.splice(sortIndex, 0, n);\n\t                    }\n\t                } else {\n\t                    nodesAttrs[nodeId] = {\n\t                        attributes: nodeAttrs,\n\t                        selectedLength: unique ? -1 : n,\n\t                        node: node,\n\t                        array: false\n\t                    };\n\t                }\n\t            }\n\t        }\n\n\t        for (i = 0, n = mergeIds.length; i < n; i++) {\n\t            nodeId = mergeIds[i];\n\t            nodeAttrs = nodesAttrs[nodeId];\n\t            nodeAttrs.attributes = merge.apply(void 0, [ {} ].concat( nodeAttrs.attributes.reverse() ));\n\t        }\n\n\t        return nodesAttrs;\n\t    },\n\n\t    getEventTarget: function(evt, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n\t        // It holds the element when a touchstart triggered.\n\t        var target = evt.target;\n\t        var type = evt.type;\n\t        var clientX = evt.clientX; if ( clientX === void 0 ) clientX = 0;\n\t        var clientY = evt.clientY; if ( clientY === void 0 ) clientY = 0;\n\t        if (opt.fromPoint || type === 'touchmove' || type === 'touchend') {\n\t            return document.elementFromPoint(clientX, clientY);\n\t        }\n\n\t        return target;\n\t    },\n\n\t    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n\t    // unless `attrs` parameter was passed.\n\t    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n\t        opt || (opt = {});\n\t        opt.rootBBox || (opt.rootBBox = Rect());\n\t        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n\t        // Cache table for query results and bounding box calculation.\n\t        // Note that `selectorCache` needs to be invalidated for all\n\t        // `updateAttributes` calls, as the selectors might pointing\n\t        // to nodes designated by an attribute or elements dynamically\n\t        // created.\n\t        var selectorCache = {};\n\t        var bboxCache = {};\n\t        var relativeItems = [];\n\t        var relativeRefItems = [];\n\t        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n\t        var roAttrs = opt.roAttributes;\n\t        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n\t        // `nodesAttrs` are different from all attributes, when\n\t        // rendering only  attributes sent to this method.\n\t        var nodesAllAttrs = (roAttrs)\n\t            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n\t            : nodesAttrs;\n\n\t        for (var nodeId in nodesAttrs) {\n\t            nodeData = nodesAttrs[nodeId];\n\t            nodeAttrs = nodeData.attributes;\n\t            node = nodeData.node;\n\t            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n\t            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n\t                // Set all the normal attributes right on the SVG/HTML element.\n\t                this.setNodeAttributes(node, processedAttrs.normal);\n\n\t            } else {\n\n\t                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n\t                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n\t                    ? nodeAllAttrs.ref\n\t                    : nodeAttrs.ref;\n\n\t                var refNode;\n\t                if (refSelector) {\n\t                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n\t                    if (!refNode) {\n\t                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n\t                    }\n\t                } else {\n\t                    refNode = null;\n\t                }\n\n\t                item = {\n\t                    node: node,\n\t                    refNode: refNode,\n\t                    processedAttributes: processedAttrs,\n\t                    allAttributes: nodeAllAttrs\n\t                };\n\n\t                if (refNode) {\n\t                    // If an element in the list is positioned relative to this one, then\n\t                    // we want to insert this one before it in the list.\n\t                    var itemIndex = relativeRefItems.findIndex(function(item) {\n\t                        return item.refNode === node;\n\t                    });\n\n\t                    if (itemIndex > -1) {\n\t                        relativeRefItems.splice(itemIndex, 0, item);\n\t                    } else {\n\t                        relativeRefItems.push(item);\n\t                    }\n\t                } else {\n\t                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n\t                    // The order of no-ref-items is not specified/important.\n\t                    relativeItems.push(item);\n\t                }\n\t            }\n\t        }\n\n\t        relativeItems.push.apply(relativeItems, relativeRefItems);\n\n\t        var rotatableMatrix;\n\t        for (var i = 0, n = relativeItems.length; i < n; i++) {\n\t            item = relativeItems[i];\n\t            node = item.node;\n\t            refNode = item.refNode;\n\n\t            // Find the reference element bounding box. If no reference was provided, we\n\t            // use the optional bounding box.\n\t            var vRotatable = V(opt.rotatableNode);\n\t            var refNodeId = refNode ? V.ensureId(refNode) : '';\n\t            var isRefNodeRotatable = !!vRotatable && !!refNode && vRotatable.contains(refNode);\n\t            var unrotatedRefBBox = bboxCache[refNodeId];\n\t            if (!unrotatedRefBBox) {\n\t                // Get the bounding box of the reference element relative to the `rotatable` `<g>` (without rotation)\n\t                // or to the root `<g>` element if no rotatable group present if reference node present.\n\t                // Uses the bounding box provided.\n\t                var transformationTarget = (isRefNodeRotatable) ? vRotatable : rootNode;\n\t                unrotatedRefBBox = bboxCache[refNodeId] = (refNode)\n\t                    ? V(refNode).getBBox({ target: transformationTarget })\n\t                    : opt.rootBBox;\n\t            }\n\n\t            if (roAttrs) {\n\t                // if there was a special attribute affecting the position amongst passed-in attributes\n\t                // we have to merge it with the rest of the element's attributes as they are necessary\n\t                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n\t                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n\t                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n\t            } else {\n\t                processedAttrs = item.processedAttributes;\n\t            }\n\n\t            var refBBox = unrotatedRefBBox;\n\t            if (isRefNodeRotatable && !vRotatable.contains(node)) {\n\t                // if the referenced node is inside the rotatable group while the updated node is outside,\n\t                // we need to take the rotatable node transformation into account\n\t                if (!rotatableMatrix) { rotatableMatrix = V.transformStringToMatrix(vRotatable.attr('transform')); }\n\t                refBBox = V.transformRect(unrotatedRefBBox, rotatableMatrix);\n\t            }\n\n\t            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n\t        }\n\t    },\n\n\t    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n\t        processedAttrs.set || (processedAttrs.set = {});\n\t        processedAttrs.position || (processedAttrs.position = {});\n\t        processedAttrs.offset || (processedAttrs.offset = {});\n\n\t        assign(processedAttrs.set, roProcessedAttrs.set);\n\t        assign(processedAttrs.position, roProcessedAttrs.position);\n\t        assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n\t        // Handle also the special transform property.\n\t        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n\t        if (transform !== undefined && roProcessedAttrs.normal) {\n\t            roProcessedAttrs.normal.transform = transform;\n\t        }\n\t        processedAttrs.normal = roProcessedAttrs.normal;\n\t    },\n\n\t    onRemove: function() {\n\t        this.removeTools();\n\t        this.removeHighlighters();\n\t    },\n\n\t    _toolsView: null,\n\n\t    hasTools: function(name) {\n\t        var toolsView = this._toolsView;\n\t        if (!toolsView) { return false; }\n\t        if (!name) { return true; }\n\t        return (toolsView.getName() === name);\n\t    },\n\n\t    addTools: function(toolsView) {\n\n\t        this.removeTools();\n\n\t        if (toolsView) {\n\t            this._toolsView = toolsView;\n\t            toolsView.configure({ relatedView: this });\n\t            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n\t        }\n\t        return this;\n\t    },\n\n\t    updateTools: function(opt) {\n\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) { toolsView.update(opt); }\n\t        return this;\n\t    },\n\n\t    removeTools: function() {\n\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) {\n\t            toolsView.remove();\n\t            this._toolsView = null;\n\t        }\n\t        return this;\n\t    },\n\n\t    hideTools: function() {\n\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) { toolsView.hide(); }\n\t        return this;\n\t    },\n\n\t    showTools: function() {\n\n\t        var toolsView = this._toolsView;\n\t        if (toolsView) { toolsView.show(); }\n\t        return this;\n\t    },\n\n\t    onToolEvent: function(event) {\n\t        switch (event) {\n\t            case 'remove':\n\t                this.removeTools();\n\t                break;\n\t            case 'hide':\n\t                this.hideTools();\n\t                break;\n\t            case 'show':\n\t                this.showTools();\n\t                break;\n\t        }\n\t    },\n\n\t    removeHighlighters: function() {\n\t        HighlighterView.remove(this);\n\t    },\n\n\t    updateHighlighters: function(dirty) {\n\t        if ( dirty === void 0 ) dirty = false;\n\n\t        HighlighterView.update(this, null, dirty);\n\t    },\n\n\t    transformHighlighters: function() {\n\t        HighlighterView.transform(this);\n\t    },\n\n\t    // Interaction. The controller part.\n\t    // ---------------------------------\n\n\t    // Interaction is handled by the paper and delegated to the view in interest.\n\t    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n\t    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n\t    // These functions are supposed to be overriden by the views that inherit from `joint.dia.Cell`,\n\t    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n\t    pointerdblclick: function(evt, x, y) {\n\n\t        this.notify('cell:pointerdblclick', evt, x, y);\n\t    },\n\n\t    pointerclick: function(evt, x, y) {\n\n\t        this.notify('cell:pointerclick', evt, x, y);\n\t    },\n\n\t    contextmenu: function(evt, x, y) {\n\n\t        this.notify('cell:contextmenu', evt, x, y);\n\t    },\n\n\t    pointerdown: function(evt, x, y) {\n\n\t        var ref = this;\n\t        var model = ref.model;\n\t        var graph = model.graph;\n\t        if (graph) {\n\t            model.startBatch('pointer');\n\t            this.eventData(evt, { graph: graph });\n\t        }\n\n\t        this.notify('cell:pointerdown', evt, x, y);\n\t    },\n\n\t    pointermove: function(evt, x, y) {\n\n\t        this.notify('cell:pointermove', evt, x, y);\n\t    },\n\n\t    pointerup: function(evt, x, y) {\n\n\t        var ref = this.eventData(evt);\n\t        var graph = ref.graph;\n\n\t        this.notify('cell:pointerup', evt, x, y);\n\n\t        if (graph) {\n\t            // we don't want to trigger event on model as model doesn't\n\t            // need to be member of collection anymore (remove)\n\t            graph.stopBatch('pointer', { cell: this.model });\n\t        }\n\t    },\n\n\t    mouseover: function(evt) {\n\n\t        this.notify('cell:mouseover', evt);\n\t    },\n\n\t    mouseout: function(evt) {\n\n\t        this.notify('cell:mouseout', evt);\n\t    },\n\n\t    mouseenter: function(evt) {\n\n\t        this.notify('cell:mouseenter', evt);\n\t    },\n\n\t    mouseleave: function(evt) {\n\n\t        this.notify('cell:mouseleave', evt);\n\t    },\n\n\t    mousewheel: function(evt, x, y, delta) {\n\n\t        this.notify('cell:mousewheel', evt, x, y, delta);\n\t    },\n\n\t    onevent: function(evt, eventName, x, y) {\n\n\t        this.notify(eventName, evt, x, y);\n\t    },\n\n\t    onmagnet: function() {\n\n\t        // noop\n\t    },\n\n\t    magnetpointerdblclick: function() {\n\n\t        // noop\n\t    },\n\n\t    magnetcontextmenu: function() {\n\n\t        // noop\n\t    },\n\n\t    checkMouseleave: function checkMouseleave(evt) {\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        if (paper.isAsync()) {\n\t            // Do the updates of the current view synchronously now\n\t            paper.dumpView(this);\n\t        }\n\t        var target = this.getEventTarget(evt, { fromPoint: true });\n\t        var view = paper.findView(target);\n\t        if (view === this) { return; }\n\t        // Leaving the current view\n\t        this.mouseleave(evt);\n\t        if (!view) { return; }\n\t        // Entering another view\n\t        view.mouseenter(evt);\n\t    },\n\n\t    setInteractivity: function(value) {\n\n\t        this.options.interactive = value;\n\t    }\n\t}, {\n\n\t    Highlighting: HighlightingTypes,\n\n\t    addPresentationAttributes: function(presentationAttributes) {\n\t        return merge({}, this.prototype.presentationAttributes, presentationAttributes, function(a, b) {\n\t            if (!a || !b) { return; }\n\t            if (typeof a === 'string') { a = [a]; }\n\t            if (typeof b === 'string') { b = [b]; }\n\t            if (Array.isArray(a) && Array.isArray(b)) { return uniq(a.concat(b)); }\n\t        });\n\t    }\n\t});\n\n\t// Element base view and controller.\n\t// -------------------------------------------\n\n\tvar ElementView = CellView.extend({\n\n\t    /**\n\t     * @abstract\n\t     */\n\t    _removePorts: function() {\n\t        // implemented in ports.js\n\t    },\n\n\t    /**\n\t     *\n\t     * @abstract\n\t     */\n\t    _renderPorts: function() {\n\t        // implemented in ports.js\n\t    },\n\n\t    className: function() {\n\n\t        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n\t        classNames.push('element');\n\n\t        return classNames.join(' ');\n\t    },\n\n\t    initialize: function() {\n\n\t        CellView.prototype.initialize.apply(this, arguments);\n\n\t        this._initializePorts();\n\t    },\n\n\t    presentationAttributes: {\n\t        'attrs': ['UPDATE'],\n\t        'position': ['TRANSLATE', 'TOOLS'],\n\t        'size': ['RESIZE', 'PORTS', 'TOOLS'],\n\t        'angle': ['ROTATE', 'TOOLS'],\n\t        'markup': ['RENDER'],\n\t        'ports': ['PORTS']\n\t    },\n\n\t    initFlag: ['RENDER'],\n\n\t    UPDATE_PRIORITY: 0,\n\n\t    confirmUpdate: function(flag, opt) {\n\n\t        var useCSSSelectors = config.useCSSSelectors;\n\t        if (this.hasFlag(flag, 'PORTS')) {\n\t            this._removePorts();\n\t            this._cleanPortsCache();\n\t        }\n\t        var transformHighlighters = false;\n\t        if (this.hasFlag(flag, 'RENDER')) {\n\t            this.render();\n\t            this.updateTools(opt);\n\t            this.updateHighlighters(true);\n\t            transformHighlighters = true;\n\t            flag = this.removeFlag(flag, ['RENDER', 'UPDATE', 'RESIZE', 'TRANSLATE', 'ROTATE', 'PORTS', 'TOOLS']);\n\t        } else {\n\t            var updateHighlighters = false;\n\n\t            // Skip this branch if render is required\n\t            if (this.hasFlag(flag, 'RESIZE')) {\n\t                this.resize(opt);\n\t                updateHighlighters = true;\n\t                // Resize method is calling `update()` internally\n\t                flag = this.removeFlag(flag, ['RESIZE', 'UPDATE']);\n\t            }\n\t            if (this.hasFlag(flag, 'UPDATE')) {\n\t                this.update(this.model, null, opt);\n\t                flag = this.removeFlag(flag, 'UPDATE');\n\t                updateHighlighters = true;\n\t                if (useCSSSelectors) {\n\t                    // `update()` will render ports when useCSSSelectors are enabled\n\t                    flag = this.removeFlag(flag, 'PORTS');\n\t                }\n\t            }\n\t            if (this.hasFlag(flag, 'TRANSLATE')) {\n\t                this.translate();\n\t                flag = this.removeFlag(flag, 'TRANSLATE');\n\t                transformHighlighters = true;\n\t            }\n\t            if (this.hasFlag(flag, 'ROTATE')) {\n\t                this.rotate();\n\t                flag = this.removeFlag(flag, 'ROTATE');\n\t                transformHighlighters = true;\n\t            }\n\t            if (this.hasFlag(flag, 'PORTS')) {\n\t                this._renderPorts();\n\t                updateHighlighters = true;\n\t                flag = this.removeFlag(flag, 'PORTS');\n\t            }\n\n\t            if (updateHighlighters) {\n\t                this.updateHighlighters(false);\n\t            }\n\t        }\n\n\t        if (transformHighlighters) {\n\t            this.transformHighlighters();\n\t        }\n\n\t        if (this.hasFlag(flag, 'TOOLS')) {\n\t            this.updateTools(opt);\n\t            flag = this.removeFlag(flag, 'TOOLS');\n\t        }\n\n\t        return flag;\n\t    },\n\n\t    /**\n\t     * @abstract\n\t     */\n\t    _initializePorts: function() {\n\n\t    },\n\n\t    update: function(_, renderingOnlyAttrs) {\n\n\t        this.cleanNodesCache();\n\n\t        // When CSS selector strings are used, make sure no rule matches port nodes.\n\t        var useCSSSelectors = config.useCSSSelectors;\n\t        if (useCSSSelectors) { this._removePorts(); }\n\n\t        var model = this.model;\n\t        var modelAttrs = model.attr();\n\t        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n\t            rootBBox: new Rect(model.size()),\n\t            selectors: this.selectors,\n\t            scalableNode: this.scalableNode,\n\t            rotatableNode: this.rotatableNode,\n\t            // Use rendering only attributes if they differs from the model attributes\n\t            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\n\t        });\n\n\t        if (useCSSSelectors) {\n\t            this._renderPorts();\n\t        }\n\t    },\n\n\t    rotatableSelector: 'rotatable',\n\t    scalableSelector: 'scalable',\n\t    scalableNode: null,\n\t    rotatableNode: null,\n\n\t    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n\t    // default markup is not desirable.\n\t    renderMarkup: function() {\n\n\t        var element = this.model;\n\t        var markup = element.get('markup') || element.markup;\n\t        if (!markup) { throw new Error('dia.ElementView: markup required'); }\n\t        if (Array.isArray(markup)) { return this.renderJSONMarkup(markup); }\n\t        if (typeof markup === 'string') { return this.renderStringMarkup(markup); }\n\t        throw new Error('dia.ElementView: invalid markup');\n\t    },\n\n\t    renderJSONMarkup: function(markup) {\n\n\t        var doc = this.parseDOMJSON(markup, this.el);\n\t        var selectors = this.selectors = doc.selectors;\n\t        this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n\t        this.scalableNode = V(selectors[this.scalableSelector]) || null;\n\t        // Fragment\n\t        this.vel.append(doc.fragment);\n\t    },\n\n\t    renderStringMarkup: function(markup) {\n\n\t        var vel = this.vel;\n\t        vel.append(V(markup));\n\t        // Cache transformation groups\n\t        this.rotatableNode = vel.findOne('.rotatable');\n\t        this.scalableNode = vel.findOne('.scalable');\n\n\t        var selectors = this.selectors = {};\n\t        selectors[this.selector] = this.el;\n\t    },\n\n\t    render: function() {\n\n\t        this.vel.empty();\n\t        this.renderMarkup();\n\t        if (this.scalableNode) {\n\t            // Double update is necessary for elements with the scalable group only\n\t            // Note the resize() triggers the other `update`.\n\t            this.update();\n\t        }\n\t        this.resize();\n\t        if (this.rotatableNode) {\n\t            // Translate transformation is applied on `this.el` while the rotation transformation\n\t            // on `this.rotatableNode`\n\t            this.rotate();\n\t            this.translate();\n\t        } else {\n\t            this.updateTransformation();\n\t        }\n\t        if (!config.useCSSSelectors) { this._renderPorts(); }\n\t        return this;\n\t    },\n\n\t    resize: function(opt) {\n\n\t        if (this.scalableNode) { return this.sgResize(opt); }\n\t        if (this.model.attributes.angle) { this.rotate(); }\n\t        this.update();\n\t    },\n\n\t    translate: function() {\n\n\t        if (this.rotatableNode) { return this.rgTranslate(); }\n\t        this.updateTransformation();\n\t    },\n\n\t    rotate: function() {\n\n\t        if (this.rotatableNode) {\n\t            this.rgRotate();\n\t            // It's necessary to call the update for the nodes outside\n\t            // the rotatable group referencing nodes inside the group\n\t            this.update();\n\t            return;\n\t        }\n\t        this.updateTransformation();\n\t    },\n\n\t    updateTransformation: function() {\n\n\t        var transformation = this.getTranslateString();\n\t        var rotateString = this.getRotateString();\n\t        if (rotateString) { transformation += ' ' + rotateString; }\n\t        this.vel.attr('transform', transformation);\n\t    },\n\n\t    getTranslateString: function() {\n\n\t        var position = this.model.attributes.position;\n\t        return 'translate(' + position.x + ',' + position.y + ')';\n\t    },\n\n\t    getRotateString: function() {\n\t        var attributes = this.model.attributes;\n\t        var angle = attributes.angle;\n\t        if (!angle) { return null; }\n\t        var size = attributes.size;\n\t        return 'rotate(' + angle + ',' + (size.width / 2) + ',' + (size.height / 2) + ')';\n\t    },\n\n\t    // Rotatable & Scalable Group\n\t    // always slower, kept mainly for backwards compatibility\n\n\t    rgRotate: function() {\n\n\t        this.rotatableNode.attr('transform', this.getRotateString());\n\t    },\n\n\t    rgTranslate: function() {\n\n\t        this.vel.attr('transform', this.getTranslateString());\n\t    },\n\n\t    sgResize: function(opt) {\n\n\t        var model = this.model;\n\t        var angle = model.angle();\n\t        var size = model.size();\n\t        var scalable = this.scalableNode;\n\n\t        // Getting scalable group's bbox.\n\t        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n\t        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n\t        var recursive = false;\n\t        if (scalable.node.getElementsByTagName('path').length > 0) {\n\t            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n\t            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n\t            recursive = true;\n\t        }\n\t        var scalableBBox = scalable.getBBox({ recursive: recursive });\n\n\t        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n\t        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n\t        var sx = (size.width / (scalableBBox.width || 1));\n\t        var sy = (size.height / (scalableBBox.height || 1));\n\t        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n\t        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n\t        // Order of transformations is significant but we want to reconstruct the object always in the order:\n\t        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n\t        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n\t        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n\t        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n\t        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n\t        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\t        var rotatable = this.rotatableNode;\n\t        var rotation = rotatable && rotatable.attr('transform');\n\t        if (rotation) {\n\n\t            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\n\t            var rotatableBBox = scalable.getBBox({ target: this.paper.cells });\n\n\t            // Store new x, y and perform rotate() again against the new rotation origin.\n\t            model.set('position', { x: rotatableBBox.x, y: rotatableBBox.y }, assign({ updateHandled: true }, opt));\n\t            this.translate();\n\t            this.rotate();\n\t        }\n\n\t        // Update must always be called on non-rotated element. Otherwise, relative positioning\n\t        // would work with wrong (rotated) bounding boxes.\n\t        this.update();\n\t    },\n\n\t    // Embedding mode methods.\n\t    // -----------------------\n\n\t    prepareEmbedding: function(data) {\n\n\t        data || (data = {});\n\n\t        var model = data.model || this.model;\n\t        var paper = data.paper || this.paper;\n\t        var graph = paper.model;\n\n\t        model.startBatch('to-front');\n\n\t        // Bring the model to the front with all his embeds.\n\t        model.toFront({ deep: true, ui: true });\n\n\t        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n\t        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n\t        var maxZ = graph.getElements().reduce(function(max, cell) {\n\t            return Math.max(max, cell.attributes.z || 0);\n\t        }, 0);\n\n\t        // Move to front also all the inbound and outbound links that are connected\n\t        // to any of the element descendant. If we bring to front only embedded elements,\n\t        // links connected to them would stay in the background.\n\t        var connectedLinks = graph.getConnectedLinks(model, { deep: true, includeEnclosed: true });\n\t        connectedLinks.forEach(function(link) {\n\t            if (link.attributes.z <= maxZ) { link.set('z', maxZ + 1, { ui: true }); }\n\t        });\n\n\t        model.stopBatch('to-front');\n\n\t        // Before we start looking for suitable parent we remove the current one.\n\t        var parentId = model.parent();\n\t        if (parentId) {\n\t            graph.getCell(parentId).unembed(model, { ui: true });\n\t        }\n\t    },\n\n\t    processEmbedding: function(data) {\n\n\t        data || (data = {});\n\n\t        var model = data.model || this.model;\n\t        var paper = data.paper || this.paper;\n\t        var paperOptions = paper.options;\n\n\t        var candidates = [];\n\t        if (isFunction(paperOptions.findParentBy)) {\n\t            var parents = toArray(paperOptions.findParentBy.call(paper.model, this));\n\t            candidates = parents.filter(function(el) {\n\t                return el instanceof Cell && this.model.id !== el.id && !el.isEmbeddedIn(this.model);\n\t            }.bind(this));\n\t        } else {\n\t            candidates = paper.model.findModelsUnderElement(model, { searchBy: paperOptions.findParentBy });\n\t        }\n\n\t        if (paperOptions.frontParentOnly) {\n\t            // pick the element with the highest `z` index\n\t            candidates = candidates.slice(-1);\n\t        }\n\n\t        var newCandidateView = null;\n\t        var prevCandidateView = data.candidateEmbedView;\n\n\t        // iterate over all candidates starting from the last one (has the highest z-index).\n\t        for (var i = candidates.length - 1; i >= 0; i--) {\n\n\t            var candidate = candidates[i];\n\n\t            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n\n\t                // candidate remains the same\n\t                newCandidateView = prevCandidateView;\n\t                break;\n\n\t            } else {\n\n\t                var view = candidate.findView(paper);\n\t                if (paperOptions.validateEmbedding.call(paper, this, view)) {\n\n\t                    // flip to the new candidate\n\t                    newCandidateView = view;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\n\t        if (newCandidateView && newCandidateView != prevCandidateView) {\n\t            // A new candidate view found. Highlight the new one.\n\t            this.clearEmbedding(data);\n\t            data.candidateEmbedView = newCandidateView.highlight(\n\t                newCandidateView.findProxyNode(null, 'container'),\n\t                { embedding: true }\n\t            );\n\t        }\n\n\t        if (!newCandidateView && prevCandidateView) {\n\t            // No candidate view found. Unhighlight the previous candidate.\n\t            this.clearEmbedding(data);\n\t        }\n\t    },\n\n\t    clearEmbedding: function(data) {\n\n\t        data || (data = {});\n\n\t        var candidateView = data.candidateEmbedView;\n\t        if (candidateView) {\n\t            // No candidate view found. Unhighlight the previous candidate.\n\t            candidateView.unhighlight(\n\t                candidateView.findProxyNode(null, 'container'),\n\t                { embedding: true }\n\t            );\n\t            data.candidateEmbedView = null;\n\t        }\n\t    },\n\n\t    finalizeEmbedding: function(data) {\n\n\t        data || (data = {});\n\n\t        var candidateView = data.candidateEmbedView;\n\t        var model = data.model || this.model;\n\t        var paper = data.paper || this.paper;\n\n\t        if (candidateView) {\n\n\t            // We finished embedding. Candidate view is chosen to become the parent of the model.\n\t            candidateView.model.embed(model, { ui: true });\n\t            candidateView.unhighlight(\n\t                candidateView.findProxyNode(null, 'container'),\n\t                { embedding: true }\n\t            );\n\n\t            data.candidateEmbedView = null;\n\t        }\n\n\t        invoke(paper.model.getConnectedLinks(model, { deep: true }), 'reparent', { ui: true });\n\t    },\n\n\t    getDelegatedView: function() {\n\n\t        var view = this;\n\t        var model = view.model;\n\t        var paper = view.paper;\n\n\t        while (view) {\n\t            if (model.isLink()) { break; }\n\t            if (!model.isEmbedded() || view.can('stopDelegation')) { return view; }\n\t            model = model.getParentCell();\n\t            view = paper.findViewByModel(model);\n\t        }\n\n\t        return null;\n\t    },\n\n\t    findProxyNode: function(el, type) {\n\t        el || (el = this.el);\n\t        var nodeSelector = el.getAttribute((type + \"-selector\"));\n\t        if (nodeSelector) {\n\t            var port = this.findAttribute('port', el);\n\t            if (port) {\n\t                var proxyPortNode = this.findPortNode(port, nodeSelector);\n\t                if (proxyPortNode) { return proxyPortNode; }\n\t            } else {\n\t                var ref = this.findBySelector(nodeSelector);\n\t                var proxyNode = ref[0];\n\t                if (proxyNode) { return proxyNode; }\n\t            }\n\t        }\n\t        return el;\n\t    },\n\n\t    // Interaction. The controller part.\n\t    // ---------------------------------\n\n\t    notifyPointerdown: function notifyPointerdown(evt, x, y) {\n\t        CellView.prototype.pointerdown.call(this, evt, x, y);\n\t        this.notify('element:pointerdown', evt, x, y);\n\t    },\n\n\t    notifyPointermove: function notifyPointermove(evt, x, y) {\n\t        CellView.prototype.pointermove.call(this, evt, x, y);\n\t        this.notify('element:pointermove', evt, x, y);\n\t    },\n\n\t    notifyPointerup: function notifyPointerup(evt, x, y) {\n\t        this.notify('element:pointerup', evt, x, y);\n\t        CellView.prototype.pointerup.call(this, evt, x, y);\n\t    },\n\n\t    pointerdblclick: function(evt, x, y) {\n\n\t        CellView.prototype.pointerdblclick.apply(this, arguments);\n\t        this.notify('element:pointerdblclick', evt, x, y);\n\t    },\n\n\t    pointerclick: function(evt, x, y) {\n\n\t        CellView.prototype.pointerclick.apply(this, arguments);\n\t        this.notify('element:pointerclick', evt, x, y);\n\t    },\n\n\t    contextmenu: function(evt, x, y) {\n\n\t        CellView.prototype.contextmenu.apply(this, arguments);\n\t        this.notify('element:contextmenu', evt, x, y);\n\t    },\n\n\t    pointerdown: function(evt, x, y) {\n\n\t        if (this.isPropagationStopped(evt)) { return; }\n\n\t        this.notifyPointerdown(evt, x, y);\n\t        this.dragStart(evt, x, y);\n\t    },\n\n\t    pointermove: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\n\t        switch (data.action) {\n\t            case 'magnet':\n\t                this.dragMagnet(evt, x, y);\n\t                break;\n\t            case 'move':\n\t                (data.delegatedView || this).drag(evt, x, y);\n\t            // eslint: no-fallthrough=false\n\t            default:\n\t                this.notifyPointermove(evt, x, y);\n\t                break;\n\t        }\n\n\t        // Make sure the element view data is passed along.\n\t        // It could have been wiped out in the handlers above.\n\t        this.eventData(evt, data);\n\t    },\n\n\t    pointerup: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        switch (data.action) {\n\t            case 'magnet':\n\t                this.dragMagnetEnd(evt, x, y);\n\t                break;\n\t            case 'move':\n\t                (data.delegatedView || this).dragEnd(evt, x, y);\n\t            // eslint: no-fallthrough=false\n\t            default:\n\t                this.notifyPointerup(evt, x, y);\n\t        }\n\n\t        var magnet = data.targetMagnet;\n\t        if (magnet) { this.magnetpointerclick(evt, magnet, x, y); }\n\n\t        this.checkMouseleave(evt);\n\t    },\n\n\t    mouseover: function(evt) {\n\n\t        CellView.prototype.mouseover.apply(this, arguments);\n\t        this.notify('element:mouseover', evt);\n\t    },\n\n\t    mouseout: function(evt) {\n\n\t        CellView.prototype.mouseout.apply(this, arguments);\n\t        this.notify('element:mouseout', evt);\n\t    },\n\n\t    mouseenter: function(evt) {\n\n\t        CellView.prototype.mouseenter.apply(this, arguments);\n\t        this.notify('element:mouseenter', evt);\n\t    },\n\n\t    mouseleave: function(evt) {\n\n\t        CellView.prototype.mouseleave.apply(this, arguments);\n\t        this.notify('element:mouseleave', evt);\n\t    },\n\n\t    mousewheel: function(evt, x, y, delta) {\n\n\t        CellView.prototype.mousewheel.apply(this, arguments);\n\t        this.notify('element:mousewheel', evt, x, y, delta);\n\t    },\n\n\t    onmagnet: function(evt, x, y) {\n\n\t        this.dragMagnetStart(evt, x, y);\n\t    },\n\n\t    magnetpointerdblclick: function(evt, magnet, x, y) {\n\n\t        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n\t    },\n\n\t    magnetcontextmenu: function(evt, magnet, x, y) {\n\n\t        this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n\t    },\n\n\t    // Drag Start Handlers\n\n\t    dragStart: function(evt, x, y) {\n\n\t        var view = this.getDelegatedView();\n\t        if (!view || !view.can('elementMove')) { return; }\n\n\t        this.eventData(evt, {\n\t            action: 'move',\n\t            delegatedView: view\n\t        });\n\n\t        view.eventData(evt, {\n\t            pointerOffset: view.model.position().difference(x, y),\n\t            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n\t        });\n\t    },\n\n\t    dragMagnetStart: function(evt, x, y) {\n\n\t        if (!this.can('addLinkFromMagnet')) { return; }\n\n\t        var magnet = evt.currentTarget;\n\t        var paper = this.paper;\n\t        this.eventData(evt, { targetMagnet: magnet });\n\t        evt.stopPropagation();\n\n\t        if (paper.options.validateMagnet(this, magnet, evt)) {\n\n\t            if (paper.options.magnetThreshold <= 0) {\n\t                this.dragLinkStart(evt, magnet, x, y);\n\t            }\n\n\t            this.eventData(evt, { action: 'magnet' });\n\t            this.stopPropagation(evt);\n\n\t        } else {\n\n\t            this.pointerdown(evt, x, y);\n\t        }\n\n\t        paper.delegateDragEvents(this, evt.data);\n\t    },\n\n\t    dragLinkStart: function(evt, magnet, x, y) {\n\n\t        this.model.startBatch('add-link');\n\n\t        var linkView = this.addLinkFromMagnet(magnet, x, y);\n\n\t        // backwards compatibility events\n\t        linkView.notifyPointerdown(evt, x, y);\n\n\t        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n\t        this.eventData(evt, { linkView: linkView });\n\t    },\n\n\t    addLinkFromMagnet: function(magnet, x, y) {\n\n\t        var paper = this.paper;\n\t        var graph = paper.model;\n\n\t        var link = paper.getDefaultLink(this, magnet);\n\t        link.set({\n\t            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n\t            target: { x: x, y: y }\n\t        }).addTo(graph, {\n\t            async: false,\n\t            ui: true\n\t        });\n\n\t        return link.findView(paper);\n\t    },\n\n\t    // Drag Handlers\n\n\t    drag: function(evt, x, y) {\n\n\t        var paper = this.paper;\n\t        var grid = paper.options.gridSize;\n\t        var element = this.model;\n\t        var data = this.eventData(evt);\n\t        var pointerOffset = data.pointerOffset;\n\t        var restrictedArea = data.restrictedArea;\n\t        var embedding = data.embedding;\n\n\t        // Make sure the new element's position always snaps to the current grid\n\t        var elX = snapToGrid(x + pointerOffset.x, grid);\n\t        var elY = snapToGrid(y + pointerOffset.y, grid);\n\n\t        element.position(elX, elY, { restrictedArea: restrictedArea, deep: true, ui: true });\n\n\t        if (paper.options.embeddingMode) {\n\t            if (!embedding) {\n\t                // Prepare the element for embedding only if the pointer moves.\n\t                // We don't want to do unnecessary action with the element\n\t                // if an user only clicks/dblclicks on it.\n\t                this.prepareEmbedding(data);\n\t                embedding = true;\n\t            }\n\t            this.processEmbedding(data);\n\t        }\n\n\t        this.eventData(evt, {\n\t            embedding: embedding\n\t        });\n\t    },\n\n\t    dragMagnet: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        var linkView = data.linkView;\n\t        if (linkView) {\n\t            linkView.pointermove(evt, x, y);\n\t        } else {\n\t            var paper = this.paper;\n\t            var magnetThreshold = paper.options.magnetThreshold;\n\t            var currentTarget = this.getEventTarget(evt);\n\t            var targetMagnet = data.targetMagnet;\n\t            if (magnetThreshold === 'onleave') {\n\t                // magnetThreshold when the pointer leaves the magnet\n\t                if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) { return; }\n\t            } else {\n\t                // magnetThreshold defined as a number of movements\n\t                if (paper.eventData(evt).mousemoved <= magnetThreshold) { return; }\n\t            }\n\t            this.dragLinkStart(evt, targetMagnet, x, y);\n\t        }\n\t    },\n\n\t    // Drag End Handlers\n\n\t    dragEnd: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        if (data.embedding) { this.finalizeEmbedding(data); }\n\t    },\n\n\t    dragMagnetEnd: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        var linkView = data.linkView;\n\t        if (!linkView) { return; }\n\t        linkView.pointerup(evt, x, y);\n\t        this.model.stopBatch('add-link');\n\t    },\n\n\t    magnetpointerclick: function(evt, magnet, x, y) {\n\t        var paper = this.paper;\n\t        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) { return; }\n\t        this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n\t    }\n\n\t});\n\n\tassign(ElementView.prototype, elementViewPortPrototype);\n\n\t// Does not make any changes to vertices.\n\t// Returns the arguments that are passed to it, unchanged.\n\tvar normal = function(vertices, opt, linkView) {\n\n\t    return vertices;\n\t};\n\n\t// Routes the link always to/from a certain side\n\t//\n\t// Arguments:\n\t//   padding ... gap between the element and the first vertex. :: Default 40.\n\t//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n\t//\n\tvar oneSide = function(vertices, opt, linkView) {\n\n\t    var side = opt.side || 'bottom';\n\t    var padding = normalizeSides(opt.padding || 40);\n\n\t    // LinkView contains cached source an target bboxes.\n\t    // Note that those are Geometry rectangle objects.\n\t    var sourceBBox = linkView.sourceBBox;\n\t    var targetBBox = linkView.targetBBox;\n\t    var sourcePoint = sourceBBox.center();\n\t    var targetPoint = targetBBox.center();\n\n\t    var coordinate, dimension, direction;\n\n\t    switch (side) {\n\t        case 'bottom':\n\t            direction = 1;\n\t            coordinate = 'y';\n\t            dimension = 'height';\n\t            break;\n\t        case 'top':\n\t            direction = -1;\n\t            coordinate = 'y';\n\t            dimension = 'height';\n\t            break;\n\t        case 'left':\n\t            direction = -1;\n\t            coordinate = 'x';\n\t            dimension = 'width';\n\t            break;\n\t        case 'right':\n\t            direction = 1;\n\t            coordinate = 'x';\n\t            dimension = 'width';\n\t            break;\n\t        default:\n\t            throw new Error('Router: invalid side');\n\t    }\n\n\t    // move the points from the center of the element to outside of it.\n\t    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n\t    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n\t    // make link orthogonal (at least the first and last vertex).\n\t    if ((direction * (sourcePoint[coordinate] - targetPoint[coordinate])) > 0) {\n\t        targetPoint[coordinate] = sourcePoint[coordinate];\n\t    } else {\n\t        sourcePoint[coordinate] = targetPoint[coordinate];\n\t    }\n\n\t    return [sourcePoint].concat(vertices, targetPoint);\n\t};\n\n\t// bearing -> opposite bearing\n\tvar opposites = {\n\t    N: 'S',\n\t    S: 'N',\n\t    E: 'W',\n\t    W: 'E'\n\t};\n\n\t// bearing -> radians\n\tvar radians = {\n\t    N: -Math.PI / 2 * 3,\n\t    S: -Math.PI / 2,\n\t    E: 0,\n\t    W: Math.PI\n\t};\n\n\t// HELPERS //\n\n\t// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n\t// in the given box\n\tfunction freeJoin(p1, p2, bbox) {\n\n\t    var p = new Point(p1.x, p2.y);\n\t    if (bbox.containsPoint(p)) { p = new Point(p2.x, p1.y); }\n\t    // kept for reference\n\t    // if (bbox.containsPoint(p)) p = null;\n\n\t    return p;\n\t}\n\n\t// returns either width or height of a bbox based on the given bearing\n\tfunction getBBoxSize(bbox, bearing) {\n\n\t    return bbox[(bearing === 'W' || bearing === 'E') ? 'width' : 'height'];\n\t}\n\n\t// simple bearing method (calculates only orthogonal cardinals)\n\tfunction getBearing(from, to) {\n\n\t    if (from.x === to.x) { return (from.y > to.y) ? 'N' : 'S'; }\n\t    if (from.y === to.y) { return (from.x > to.x) ? 'W' : 'E'; }\n\t    return null;\n\t}\n\n\t// transform point to a rect\n\tfunction getPointBox(p) {\n\n\t    return new Rect(p.x, p.y, 0, 0);\n\t}\n\n\tfunction getPaddingBox(opt) {\n\n\t    // if both provided, opt.padding wins over opt.elementPadding\n\t    var sides = normalizeSides(opt.padding || opt.elementPadding || 20);\n\n\t    return {\n\t        x: -sides.left,\n\t        y: -sides.top,\n\t        width: sides.left + sides.right,\n\t        height: sides.top + sides.bottom\n\t    };\n\t}\n\n\t// return source bbox\n\tfunction getSourceBBox(linkView, opt) {\n\n\t    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n\t}\n\n\t// return target bbox\n\tfunction getTargetBBox(linkView, opt) {\n\n\t    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n\t}\n\n\t// return source anchor\n\tfunction getSourceAnchor(linkView, opt) {\n\n\t    if (linkView.sourceAnchor) { return linkView.sourceAnchor; }\n\n\t    // fallback: center of bbox\n\t    var sourceBBox = getSourceBBox(linkView, opt);\n\t    return sourceBBox.center();\n\t}\n\n\t// return target anchor\n\tfunction getTargetAnchor(linkView, opt) {\n\n\t    if (linkView.targetAnchor) { return linkView.targetAnchor; }\n\n\t    // fallback: center of bbox\n\t    var targetBBox = getTargetBBox(linkView, opt);\n\t    return targetBBox.center(); // default\n\t}\n\n\t// PARTIAL ROUTERS //\n\n\tfunction vertexVertex(from, to, bearing) {\n\n\t    var p1 = new Point(from.x, to.y);\n\t    var p2 = new Point(to.x, from.y);\n\t    var d1 = getBearing(from, p1);\n\t    var d2 = getBearing(from, p2);\n\t    var opposite = opposites[bearing];\n\n\t    var p = (d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))) ? p1 : p2;\n\n\t    return { points: [p], direction: getBearing(p, to) };\n\t}\n\n\tfunction elementVertex(from, to, fromBBox) {\n\n\t    var p = freeJoin(from, to, fromBBox);\n\n\t    return { points: [p], direction: getBearing(p, to) };\n\t}\n\n\tfunction vertexElement(from, to, toBBox, bearing) {\n\n\t    var route = {};\n\n\t    var points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n\t    var freePoints = points.filter(function(pt) {\n\t        return !toBBox.containsPoint(pt);\n\t    });\n\t    var freeBearingPoints = freePoints.filter(function(pt) {\n\t        return getBearing(pt, from) !== bearing;\n\t    });\n\n\t    var p;\n\n\t    if (freeBearingPoints.length > 0) {\n\t        // Try to pick a point which bears the same direction as the previous segment.\n\n\t        p = freeBearingPoints.filter(function(pt) {\n\t            return getBearing(from, pt) === bearing;\n\t        }).pop();\n\t        p = p || freeBearingPoints[0];\n\n\t        route.points = [p];\n\t        route.direction = getBearing(p, to);\n\n\t    } else {\n\t        // Here we found only points which are either contained in the element or they would create\n\t        // a link segment going in opposite direction from the previous one.\n\t        // We take the point inside element and move it outside the element in the direction the\n\t        // route is going. Now we can join this point with the current end (using freeJoin).\n\n\t        p = difference(points, freePoints)[0];\n\n\t        var p2 = (new Point(to)).move(p, -getBBoxSize(toBBox, bearing) / 2);\n\t        var p1 = freeJoin(p2, from, toBBox);\n\n\t        route.points = [p1, p2];\n\t        route.direction = getBearing(p2, to);\n\t    }\n\n\t    return route;\n\t}\n\n\tfunction elementElement(from, to, fromBBox, toBBox) {\n\n\t    var route = elementVertex(to, from, toBBox);\n\t    var p1 = route.points[0];\n\n\t    if (fromBBox.containsPoint(p1)) {\n\n\t        route = elementVertex(from, to, fromBBox);\n\t        var p2 = route.points[0];\n\n\t        if (toBBox.containsPoint(p2)) {\n\n\t            var fromBorder = (new Point(from)).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n\t            var toBorder = (new Point(to)).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n\t            var mid = (new Line(fromBorder, toBorder)).midpoint();\n\n\t            var startRoute = elementVertex(from, mid, fromBBox);\n\t            var endRoute = vertexVertex(mid, to, startRoute.direction);\n\n\t            route.points = [startRoute.points[0], endRoute.points[0]];\n\t            route.direction = endRoute.direction;\n\t        }\n\t    }\n\n\t    return route;\n\t}\n\n\t// Finds route for situations where one element is inside the other.\n\t// Typically the route is directed outside the outer element first and\n\t// then back towards the inner element.\n\tfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\n\t    var route = {};\n\t    var boundary = fromBBox.union(toBBox).inflate(1);\n\n\t    // start from the point which is closer to the boundary\n\t    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n\t    var start = reversed ? to : from;\n\t    var end = reversed ? from : to;\n\n\t    var p1, p2, p3;\n\n\t    if (bearing) {\n\t        // Points on circle with radius equals 'W + H` are always outside the rectangle\n\t        // with width W and height H if the center of that circle is the center of that rectangle.\n\t        p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n\t        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\n\t    } else {\n\t        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n\t    }\n\n\t    p2 = freeJoin(p1, end, boundary);\n\n\t    if (p1.round().equals(p2.round())) {\n\t        p2 = Point.fromPolar(boundary.width + boundary.height, toRad(p1.theta(start)) + Math.PI / 2, end);\n\t        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n\t        p3 = freeJoin(p1, p2, boundary);\n\t        route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\n\t    } else {\n\t        route.points = reversed ? [p2, p1] : [p1, p2];\n\t    }\n\n\t    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\n\t    return route;\n\t}\n\n\t// MAIN ROUTER //\n\n\t// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n\t// routing from source to target going through `vertices`.\n\tfunction orthogonal(vertices, opt, linkView) {\n\n\t    var sourceBBox = getSourceBBox(linkView, opt);\n\t    var targetBBox = getTargetBBox(linkView, opt);\n\n\t    var sourceAnchor = getSourceAnchor(linkView, opt);\n\t    var targetAnchor = getTargetAnchor(linkView, opt);\n\n\t    // if anchor lies outside of bbox, the bbox expands to include it\n\t    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n\t    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\n\t    vertices = toArray(vertices).map(Point);\n\t    vertices.unshift(sourceAnchor);\n\t    vertices.push(targetAnchor);\n\n\t    var bearing; // bearing of previous route segment\n\n\t    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n\t    for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\n\t        var route = null;\n\n\t        var from = vertices[i];\n\t        var to = vertices[i + 1];\n\n\t        var isOrthogonal = !!getBearing(from, to);\n\n\t        if (i === 0) { // source\n\n\t            if (i + 1 === max) { // route source -> target\n\n\t                // Expand one of the elements by 1px to detect situations when the two\n\t                // elements are positioned next to each other with no gap in between.\n\t                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n\t                    route = insideElement(from, to, sourceBBox, targetBBox);\n\n\t                } else if (!isOrthogonal) {\n\t                    route = elementElement(from, to, sourceBBox, targetBBox);\n\t                }\n\n\t            } else { // route source -> vertex\n\n\t                if (sourceBBox.containsPoint(to)) {\n\t                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\n\t                } else if (!isOrthogonal) {\n\t                    route = elementVertex(from, to, sourceBBox);\n\t                }\n\t            }\n\n\t        } else if (i + 1 === max) { // route vertex -> target\n\n\t            // prevent overlaps with previous line segment\n\t            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n\t            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n\t                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\n\t            } else if (!isOrthogonal) {\n\t                route = vertexElement(from, to, targetBBox, bearing);\n\t            }\n\n\t        } else if (!isOrthogonal) { // route vertex -> vertex\n\t            route = vertexVertex(from, to, bearing);\n\t        }\n\n\t        // applicable to all routes:\n\n\t        // set bearing for next iteration\n\t        if (route) {\n\t            Array.prototype.push.apply(orthogonalVertices, route.points);\n\t            bearing = route.direction;\n\n\t        } else {\n\t            // orthogonal route and not looped\n\t            bearing = getBearing(from, to);\n\t        }\n\n\t        // push `to` point to identified orthogonal vertices array\n\t        if (i + 1 < max) {\n\t            orthogonalVertices.push(to);\n\t        }\n\t    }\n\n\t    return orthogonalVertices;\n\t}\n\n\tvar config$1 = {\n\n\t    // size of the step to find a route (the grid of the manhattan pathfinder)\n\t    step: 10,\n\n\t    // the number of route finding loops that cause the router to abort\n\t    // returns fallback route instead\n\t    maximumLoops: 2000,\n\n\t    // the number of decimal places to round floating point coordinates\n\t    precision: 1,\n\n\t    // maximum change of direction\n\t    maxAllowedDirectionChange: 90,\n\n\t    // should the router use perpendicular linkView option?\n\t    // does not connect anchor of element but rather a point close-by that is orthogonal\n\t    // this looks much better\n\t    perpendicular: true,\n\n\t    // should the source and/or target not be considered as obstacles?\n\t    excludeEnds: [], // 'source', 'target'\n\n\t    // should certain types of elements not be considered as obstacles?\n\t    excludeTypes: ['basic.Text'],\n\n\t    // possible starting directions from an element\n\t    startDirections: ['top', 'right', 'bottom', 'left'],\n\n\t    // possible ending directions to an element\n\t    endDirections: ['top', 'right', 'bottom', 'left'],\n\n\t    // specify the directions used above and what they mean\n\t    directionMap: {\n\t        top: { x: 0, y: -1 },\n\t        right: { x: 1, y: 0 },\n\t        bottom: { x: 0, y: 1 },\n\t        left: { x: -1, y: 0 }\n\t    },\n\n\t    // cost of an orthogonal step\n\t    cost: function() {\n\n\t        return this.step;\n\t    },\n\n\t    // an array of directions to find next points on the route\n\t    // different from start/end directions\n\t    directions: function() {\n\n\t        var step = this.step;\n\t        var cost = this.cost();\n\n\t        return [\n\t            { offsetX: step, offsetY: 0, cost: cost },\n\t            { offsetX: -step, offsetY: 0, cost: cost },\n\t            { offsetX: 0, offsetY: step, cost: cost },\n\t            { offsetX: 0, offsetY: -step, cost: cost }\n\t        ];\n\t    },\n\n\t    // a penalty received for direction change\n\t    penalties: function() {\n\n\t        return {\n\t            0: 0,\n\t            45: this.step / 2,\n\t            90: this.step / 2\n\t        };\n\t    },\n\n\t    // padding applied on the element bounding boxes\n\t    paddingBox: function() {\n\n\t        var step = this.step;\n\n\t        return {\n\t            x: -step,\n\t            y: -step,\n\t            width: 2 * step,\n\t            height: 2 * step\n\t        };\n\t    },\n\n\t    // a router to use when the manhattan router fails\n\t    // (one of the partial routes returns null)\n\t    fallbackRouter: function(vertices, opt, linkView) {\n\n\t        if (!isFunction(orthogonal)) {\n\t            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n\t        }\n\n\t        return orthogonal(vertices, assign({}, config$1, opt), linkView);\n\t    },\n\n\t    /* Deprecated */\n\t    // a simple route used in situations when main routing method fails\n\t    // (exceed max number of loop iterations, inaccessible)\n\t    fallbackRoute: function(from, to, opt) {\n\n\t        return null; // null result will trigger the fallbackRouter\n\n\t        // left for reference:\n\t        /*// Find an orthogonal route ignoring obstacles.\n\n\t        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n\t                ? new g.Point(from.x, to.y)\n\t                : new g.Point(to.x, from.y);\n\n\t        return [point];*/\n\t    },\n\n\t    // if a function is provided, it's used to route the link while dragging an end\n\t    // i.e. function(from, to, opt) { return []; }\n\t    draggingRoute: null\n\t};\n\n\t// HELPER CLASSES //\n\n\t// Map of obstacles\n\t// Helper structure to identify whether a point lies inside an obstacle.\n\tfunction ObstacleMap(opt) {\n\n\t    this.map = {};\n\t    this.options = opt;\n\t    // tells how to divide the paper when creating the elements map\n\t    this.mapGridSize = 100;\n\t}\n\n\tObstacleMap.prototype.build = function(graph, link) {\n\n\t    var opt = this.options;\n\n\t    // source or target element could be excluded from set of obstacles\n\t    var excludedEnds = toArray(opt.excludeEnds).reduce(function(res, item) {\n\n\t        var end = link.get(item);\n\t        if (end) {\n\t            var cell = graph.getCell(end.id);\n\t            if (cell) {\n\t                res.push(cell);\n\t            }\n\t        }\n\n\t        return res;\n\t    }, []);\n\n\t    // Exclude any embedded elements from the source and the target element.\n\t    var excludedAncestors = [];\n\n\t    var source = graph.getCell(link.get('source').id);\n\t    if (source) {\n\t        excludedAncestors = union(excludedAncestors, source.getAncestors().map(function(cell) {\n\t            return cell.id;\n\t        }));\n\t    }\n\n\t    var target = graph.getCell(link.get('target').id);\n\t    if (target) {\n\t        excludedAncestors = union(excludedAncestors, target.getAncestors().map(function(cell) {\n\t            return cell.id;\n\t        }));\n\t    }\n\n\t    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n\t    // in any obstacle?) (a simplified grid search).\n\t    // The paper is divided into smaller cells, where each holds information about which\n\t    // elements belong to it. When we query whether a point lies inside an obstacle we\n\t    // don't need to go through all obstacles, we check only those in a particular cell.\n\t    var mapGridSize = this.mapGridSize;\n\n\t    graph.getElements().reduce(function(map, element) {\n\n\t        var isExcludedType = toArray(opt.excludeTypes).includes(element.get('type'));\n\t        var isExcludedEnd = excludedEnds.find(function(excluded) {\n\t            return excluded.id === element.id;\n\t        });\n\t        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n\t        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n\t        if (!isExcluded) {\n\t            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n\t            var origin = bbox.origin().snapToGrid(mapGridSize);\n\t            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n\t            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n\t                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n\t                    var gridKey = x + '@' + y;\n\t                    map[gridKey] = map[gridKey] || [];\n\t                    map[gridKey].push(bbox);\n\t                }\n\t            }\n\t        }\n\n\t        return map;\n\t    }, this.map);\n\n\t    return this;\n\t};\n\n\tObstacleMap.prototype.isPointAccessible = function(point) {\n\n\t    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n\t    return toArray(this.map[mapKey]).every(function(obstacle) {\n\t        return !obstacle.containsPoint(point);\n\t    });\n\t};\n\n\t// Sorted Set\n\t// Set of items sorted by given value.\n\tfunction SortedSet() {\n\t    this.items = [];\n\t    this.hash = {};\n\t    this.values = {};\n\t    this.OPEN = 1;\n\t    this.CLOSE = 2;\n\t}\n\n\tSortedSet.prototype.add = function(item, value) {\n\n\t    if (this.hash[item]) {\n\t        // item removal\n\t        this.items.splice(this.items.indexOf(item), 1);\n\t    } else {\n\t        this.hash[item] = this.OPEN;\n\t    }\n\n\t    this.values[item] = value;\n\n\t    var index$1 = sortedIndex(this.items, item, function(i) {\n\t        return this.values[i];\n\t    }.bind(this));\n\n\t    this.items.splice(index$1, 0, item);\n\t};\n\n\tSortedSet.prototype.remove = function(item) {\n\n\t    this.hash[item] = this.CLOSE;\n\t};\n\n\tSortedSet.prototype.isOpen = function(item) {\n\n\t    return this.hash[item] === this.OPEN;\n\t};\n\n\tSortedSet.prototype.isClose = function(item) {\n\n\t    return this.hash[item] === this.CLOSE;\n\t};\n\n\tSortedSet.prototype.isEmpty = function() {\n\n\t    return this.items.length === 0;\n\t};\n\n\tSortedSet.prototype.pop = function() {\n\n\t    var item = this.items.shift();\n\t    this.remove(item);\n\t    return item;\n\t};\n\n\t// HELPERS //\n\n\t// return source bbox\n\tfunction getSourceBBox$1(linkView, opt) {\n\n\t    // expand by padding box\n\t    if (opt && opt.paddingBox) { return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox); }\n\n\t    return linkView.sourceBBox.clone();\n\t}\n\n\t// return target bbox\n\tfunction getTargetBBox$1(linkView, opt) {\n\n\t    // expand by padding box\n\t    if (opt && opt.paddingBox) { return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox); }\n\n\t    return linkView.targetBBox.clone();\n\t}\n\n\t// return source anchor\n\tfunction getSourceAnchor$1(linkView, opt) {\n\n\t    if (linkView.sourceAnchor) { return linkView.sourceAnchor; }\n\n\t    // fallback: center of bbox\n\t    var sourceBBox = getSourceBBox$1(linkView, opt);\n\t    return sourceBBox.center();\n\t}\n\n\t// return target anchor\n\tfunction getTargetAnchor$1(linkView, opt) {\n\n\t    if (linkView.targetAnchor) { return linkView.targetAnchor; }\n\n\t    // fallback: center of bbox\n\t    var targetBBox = getTargetBBox$1(linkView, opt);\n\t    return targetBBox.center(); // default\n\t}\n\n\t// returns a direction index from start point to end point\n\t// corrects for grid deformation between start and end\n\tfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n\t    var quadrant = 360 / numDirections;\n\t    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n\t    var normalizedAngle = normalizeAngle(angleTheta + (quadrant / 2));\n\t    return quadrant * Math.floor(normalizedAngle / quadrant);\n\t}\n\n\t// helper function for getDirectionAngle()\n\t// corrects for grid deformation\n\t// (if a point is one grid steps away from another in both dimensions,\n\t// it is considered to be 45 degrees away, even if the real angle is different)\n\t// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\n\tfunction fixAngleEnd(start, end, grid, opt) {\n\n\t    var step = opt.step;\n\n\t    var diffX = end.x - start.x;\n\t    var diffY = end.y - start.y;\n\n\t    var gridStepsX = diffX / grid.x;\n\t    var gridStepsY = diffY / grid.y;\n\n\t    var distanceX = gridStepsX * step;\n\t    var distanceY = gridStepsY * step;\n\n\t    return new Point(start.x + distanceX, start.y + distanceY);\n\t}\n\n\t// return the change in direction between two direction angles\n\tfunction getDirectionChange(angle1, angle2) {\n\n\t    var directionChange = Math.abs(angle1 - angle2);\n\t    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n\t}\n\n\t// fix direction offsets according to current grid\n\tfunction getGridOffsets(directions, grid, opt) {\n\n\t    var step = opt.step;\n\n\t    toArray(opt.directions).forEach(function(direction) {\n\n\t        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n\t        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n\t    });\n\t}\n\n\t// get grid size in x and y dimensions, adapted to source and target positions\n\tfunction getGrid(step, source, target) {\n\n\t    return {\n\t        source: source.clone(),\n\t        x: getGridDimension(target.x - source.x, step),\n\t        y: getGridDimension(target.y - source.y, step)\n\t    };\n\t}\n\n\t// helper function for getGrid()\n\tfunction getGridDimension(diff, step) {\n\n\t    // return step if diff = 0\n\t    if (!diff) { return step; }\n\n\t    var absDiff = Math.abs(diff);\n\t    var numSteps = Math.round(absDiff / step);\n\n\t    // return absDiff if less than one step apart\n\t    if (!numSteps) { return absDiff; }\n\n\t    // otherwise, return corrected step\n\t    var roundedDiff = numSteps * step;\n\t    var remainder = absDiff - roundedDiff;\n\t    var stepCorrection = remainder / numSteps;\n\n\t    return step + stepCorrection;\n\t}\n\n\t// return a clone of point snapped to grid\n\tfunction snapToGrid$1(point, grid) {\n\n\t    var source = grid.source;\n\n\t    var snappedX = snapToGrid(point.x - source.x, grid.x) + source.x;\n\t    var snappedY = snapToGrid(point.y - source.y, grid.y) + source.y;\n\n\t    return new Point(snappedX, snappedY);\n\t}\n\n\t// round the point to opt.precision\n\tfunction round$1(point, precision) {\n\n\t    return point.round(precision);\n\t}\n\n\t// snap to grid and then round the point\n\tfunction align(point, grid, precision) {\n\n\t    return round$1(snapToGrid$1(point.clone(), grid), precision);\n\t}\n\n\t// return a string representing the point\n\t// string is rounded in both dimensions\n\tfunction getKey(point) {\n\n\t    return point.clone().toString();\n\t}\n\n\t// return a normalized vector from given point\n\t// used to determine the direction of a difference of two points\n\tfunction normalizePoint(point) {\n\n\t    return new Point(\n\t        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n\t        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n\t    );\n\t}\n\n\t// PATHFINDING //\n\n\t// reconstructs a route by concatenating points with their parents\n\tfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n\t    var route = [];\n\n\t    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n\t    // tailPoint is assumed to be aligned already\n\t    var currentKey = getKey(tailPoint);\n\t    var parent = parents[currentKey];\n\n\t    var point;\n\t    while (parent) {\n\n\t        // point is assumed to be aligned already\n\t        point = points[currentKey];\n\n\t        var diff = normalizePoint(point.difference(parent));\n\t        if (!diff.equals(prevDiff)) {\n\t            route.unshift(point);\n\t            prevDiff = diff;\n\t        }\n\n\t        // parent is assumed to be aligned already\n\t        currentKey = getKey(parent);\n\t        parent = parents[currentKey];\n\t    }\n\n\t    // leadPoint is assumed to be aligned already\n\t    var leadPoint = points[currentKey];\n\n\t    var fromDiff = normalizePoint(leadPoint.difference(from));\n\t    if (!fromDiff.equals(prevDiff)) {\n\t        route.unshift(leadPoint);\n\t    }\n\n\t    return route;\n\t}\n\n\t// heuristic method to determine the distance between two points\n\tfunction estimateCost(from, endPoints) {\n\n\t    var min = Infinity;\n\n\t    for (var i = 0, len = endPoints.length; i < len; i++) {\n\t        var cost = from.manhattanDistance(endPoints[i]);\n\t        if (cost < min) { min = cost; }\n\t    }\n\n\t    return min;\n\t}\n\n\t// find points around the bbox taking given directions into account\n\t// lines are drawn from anchor in given directions, intersections recorded\n\t// if anchor is outside bbox, only those directions that intersect get a rect point\n\t// the anchor itself is returned as rect point (representing some directions)\n\t// (since those directions are unobstructed by the bbox)\n\tfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n\t    var precision = opt.precision;\n\t    var directionMap = opt.directionMap;\n\n\t    var anchorCenterVector = anchor.difference(bbox.center());\n\n\t    var keys = isObject$1(directionMap) ? Object.keys(directionMap) : [];\n\t    var dirList = toArray(directionList);\n\t    var rectPoints = keys.reduce(function(res, key) {\n\n\t        if (dirList.includes(key)) {\n\t            var direction = directionMap[key];\n\n\t            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n\t            // even if anchor lies outside of bbox\n\t            var endpoint = new Point(\n\t                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n\t                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n\t            );\n\t            var intersectionLine = new Line(anchor, endpoint);\n\n\t            // get the farther intersection, in case there are two\n\t            // (that happens if anchor lies next to bbox)\n\t            var intersections = intersectionLine.intersect(bbox) || [];\n\t            var numIntersections = intersections.length;\n\t            var farthestIntersectionDistance;\n\t            var farthestIntersection = null;\n\t            for (var i = 0; i < numIntersections; i++) {\n\t                var currentIntersection = intersections[i];\n\t                var distance = anchor.squaredDistance(currentIntersection);\n\t                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n\t                    farthestIntersectionDistance = distance;\n\t                    farthestIntersection = currentIntersection;\n\t                }\n\t            }\n\n\t            // if an intersection was found in this direction, it is our rectPoint\n\t            if (farthestIntersection) {\n\t                var point = align(farthestIntersection, grid, precision);\n\n\t                // if the rectPoint lies inside the bbox, offset it by one more step\n\t                if (bbox.containsPoint(point)) {\n\t                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n\t                }\n\n\t                // then add the point to the result array\n\t                // aligned\n\t                res.push(point);\n\t            }\n\t        }\n\n\t        return res;\n\t    }, []);\n\n\t    // if anchor lies outside of bbox, add it to the array of points\n\t    if (!bbox.containsPoint(anchor)) {\n\t        // aligned\n\t        rectPoints.push(align(anchor, grid, precision));\n\t    }\n\n\t    return rectPoints;\n\t}\n\n\t// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n\t// rectangles get rect points assigned by getRectPoints()\n\tfunction findRoute(from, to, map, opt) {\n\n\t    var precision = opt.precision;\n\n\t    // Get grid for this route.\n\n\t    var sourceAnchor, targetAnchor;\n\n\t    if (from instanceof Rect) { // `from` is sourceBBox\n\t        sourceAnchor = round$1(getSourceAnchor$1(this, opt).clone(), precision);\n\t    } else {\n\t        sourceAnchor = round$1(from.clone(), precision);\n\t    }\n\n\t    if (to instanceof Rect) { // `to` is targetBBox\n\t        targetAnchor = round$1(getTargetAnchor$1(this, opt).clone(), precision);\n\t    } else {\n\t        targetAnchor = round$1(to.clone(), precision);\n\t    }\n\n\t    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n\t    // Get pathfinding points.\n\n\t    var start, end; // aligned with grid by definition\n\t    var startPoints, endPoints; // assumed to be aligned with grid already\n\n\t    // set of points we start pathfinding from\n\t    if (from instanceof Rect) { // `from` is sourceBBox\n\t        start = sourceAnchor;\n\t        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n\t    } else {\n\t        start = sourceAnchor;\n\t        startPoints = [start];\n\t    }\n\n\t    // set of points we want the pathfinding to finish at\n\t    if (to instanceof Rect) { // `to` is targetBBox\n\t        end = targetAnchor;\n\t        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n\t    } else {\n\t        end = targetAnchor;\n\t        endPoints = [end];\n\t    }\n\n\t    // take into account only accessible rect points (those not under obstacles)\n\t    startPoints = startPoints.filter(map.isPointAccessible, map);\n\t    endPoints = endPoints.filter(map.isPointAccessible, map);\n\n\t    // Check that there is an accessible route point on both sides.\n\t    // Otherwise, use fallbackRoute().\n\t    if (startPoints.length > 0 && endPoints.length > 0) {\n\n\t        // The set of tentative points to be evaluated, initially containing the start points.\n\t        // Rounded to nearest integer for simplicity.\n\t        var openSet = new SortedSet();\n\t        // Keeps reference to actual points for given elements of the open set.\n\t        var points = {};\n\t        // Keeps reference to a point that is immediate predecessor of given element.\n\t        var parents = {};\n\t        // Cost from start to a point along best known path.\n\t        var costs = {};\n\n\t        for (var i = 0, n = startPoints.length; i < n; i++) {\n\t            // startPoint is assumed to be aligned already\n\t            var startPoint = startPoints[i];\n\n\t            var key = getKey(startPoint);\n\n\t            openSet.add(key, estimateCost(startPoint, endPoints));\n\t            points[key] = startPoint;\n\t            costs[key] = 0;\n\t        }\n\n\t        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n\t        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n\t        // directions\n\t        var direction, directionChange;\n\t        var directions = opt.directions;\n\t        getGridOffsets(directions, grid, opt);\n\n\t        var numDirections = directions.length;\n\n\t        var endPointsKeys = toArray(endPoints).reduce(function(res, endPoint) {\n\t            // endPoint is assumed to be aligned already\n\n\t            var key = getKey(endPoint);\n\t            res.push(key);\n\t            return res;\n\t        }, []);\n\n\t        // main route finding loop\n\t        var loopsRemaining = opt.maximumLoops;\n\t        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n\t            // remove current from the open list\n\t            var currentKey = openSet.pop();\n\t            var currentPoint = points[currentKey];\n\t            var currentParent = parents[currentKey];\n\t            var currentCost = costs[currentKey];\n\n\t            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n\t            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n\t            var previousDirectionAngle;\n\t            if (!isRouteBeginning) { previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); } // a vertex on the route\n\t            else if (!isPathBeginning) { previousDirectionAngle = previousRouteDirectionAngle; } // beginning of route on the path\n\t            else if (!isStart) { previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); } // beginning of path, start rect point\n\t            else { previousDirectionAngle = null; } // beginning of path, source anchor or `from` point\n\n\t            // check if we reached any endpoint\n\t            var samePoints = isEqual(startPoints, endPoints);\n\t            var skipEndCheck = (isRouteBeginning && samePoints);\n\t            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n\t                opt.previousDirectionAngle = previousDirectionAngle;\n\t                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n\t            }\n\n\t            // go over all possible directions and find neighbors\n\t            for (i = 0; i < numDirections; i++) {\n\t                direction = directions[i];\n\n\t                var directionAngle = direction.angle;\n\t                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n\t                // if the direction changed rapidly, don't use this point\n\t                // any direction is allowed for starting points\n\t                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) { continue; }\n\n\t                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n\t                var neighborKey = getKey(neighborPoint);\n\n\t                // Closed points from the openSet were already evaluated.\n\t                if (openSet.isClose(neighborKey) || !map.isPointAccessible(neighborPoint)) { continue; }\n\n\t                // We can only enter end points at an acceptable angle.\n\t                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n\t                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n\t                    if (!isNeighborEnd) {\n\t                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n\t                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n\t                        if (endDirectionChange > opt.maxAllowedDirectionChange) { continue; }\n\t                    }\n\t                }\n\n\t                // The current direction is ok.\n\n\t                var neighborCost = direction.cost;\n\t                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n\t                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n\t                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n\t                    // neighbor point has not been processed yet\n\t                    // or the cost of the path from start is lower than previously calculated\n\n\t                    points[neighborKey] = neighborPoint;\n\t                    parents[neighborKey] = currentPoint;\n\t                    costs[neighborKey] = costFromStart;\n\t                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n\t                }\n\t            }\n\n\t            loopsRemaining--;\n\t        }\n\t    }\n\n\t    // no route found (`to` point either wasn't accessible or finding route took\n\t    // way too much calculation)\n\t    return opt.fallbackRoute.call(this, start, end, opt);\n\t}\n\n\t// resolve some of the options\n\tfunction resolveOptions(opt) {\n\n\t    opt.directions = result(opt, 'directions');\n\t    opt.penalties = result(opt, 'penalties');\n\t    opt.paddingBox = result(opt, 'paddingBox');\n\t    opt.padding = result(opt, 'padding');\n\n\t    if (opt.padding) {\n\t        // if both provided, opt.padding wins over opt.paddingBox\n\t        var sides = normalizeSides(opt.padding);\n\t        opt.paddingBox = {\n\t            x: -sides.left,\n\t            y: -sides.top,\n\t            width: sides.left + sides.right,\n\t            height: sides.top + sides.bottom\n\t        };\n\t    }\n\n\t    toArray(opt.directions).forEach(function(direction) {\n\n\t        var point1 = new Point(0, 0);\n\t        var point2 = new Point(direction.offsetX, direction.offsetY);\n\n\t        direction.angle = normalizeAngle(point1.theta(point2));\n\t    });\n\t}\n\n\t// initialization of the route finding\n\tfunction router(vertices, opt, linkView) {\n\n\t    resolveOptions(opt);\n\n\t    // enable/disable linkView perpendicular option\n\t    linkView.options.perpendicular = !!opt.perpendicular;\n\n\t    var sourceBBox = getSourceBBox$1(linkView, opt);\n\t    var targetBBox = getTargetBBox$1(linkView, opt);\n\n\t    var sourceAnchor = getSourceAnchor$1(linkView, opt);\n\t    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n\t    // pathfinding\n\t    var map = (new ObstacleMap(opt)).build(linkView.paper.model, linkView.model);\n\t    var oldVertices = toArray(vertices).map(Point);\n\t    var newVertices = [];\n\t    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n\t    // find a route by concatenating all partial routes (routes need to pass through vertices)\n\t    // source -> vertex[1] -> ... -> vertex[n] -> target\n\t    var to, from;\n\n\t    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n\t        var partialRoute = null;\n\n\t        from = to || sourceBBox;\n\t        to = oldVertices[i];\n\n\t        if (!to) {\n\t            // this is the last iteration\n\t            // we ran through all vertices in oldVertices\n\t            // 'to' is not a vertex.\n\n\t            to = targetBBox;\n\n\t            // If the target is a point (i.e. it's not an element), we\n\t            // should use dragging route instead of main routing method if it has been provided.\n\t            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n\t            if (isEndingAtPoint && isFunction(opt.draggingRoute)) {\n\t                // Make sure we are passing points only (not rects).\n\t                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n\t                var dragTo = to.origin();\n\n\t                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n\t            }\n\t        }\n\n\t        // if partial route has not been calculated yet use the main routing method to find one\n\t        partialRoute = partialRoute || findRoute.call(linkView, from, to, map, opt);\n\n\t        if (partialRoute === null) { // the partial route cannot be found\n\t            return opt.fallbackRouter(vertices, opt, linkView);\n\t        }\n\n\t        var leadPoint = partialRoute[0];\n\n\t        // remove the first point if the previous partial route had the same point as last\n\t        if (leadPoint && leadPoint.equals(tailPoint)) { partialRoute.shift(); }\n\n\t        // save tailPoint for next iteration\n\t        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n\t        Array.prototype.push.apply(newVertices, partialRoute);\n\t    }\n\n\t    return newVertices;\n\t}\n\n\t// public function\n\tvar manhattan = function(vertices, opt, linkView) {\n\t    return router(vertices, assign({}, config$1, opt), linkView);\n\t};\n\n\tvar config$2 = {\n\n\t    maxAllowedDirectionChange: 45,\n\n\t    // cost of a diagonal step\n\t    diagonalCost: function() {\n\n\t        var step = this.step;\n\t        return Math.ceil(Math.sqrt(step * step << 1));\n\t    },\n\n\t    // an array of directions to find next points on the route\n\t    // different from start/end directions\n\t    directions: function() {\n\n\t        var step = this.step;\n\t        var cost = this.cost();\n\t        var diagonalCost = this.diagonalCost();\n\n\t        return [\n\t            { offsetX: step, offsetY: 0, cost: cost },\n\t            { offsetX: step, offsetY: step, cost: diagonalCost },\n\t            { offsetX: 0, offsetY: step, cost: cost },\n\t            { offsetX: -step, offsetY: step, cost: diagonalCost },\n\t            { offsetX: -step, offsetY: 0, cost: cost },\n\t            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n\t            { offsetX: 0, offsetY: -step, cost: cost },\n\t            { offsetX: step, offsetY: -step, cost: diagonalCost }\n\t        ];\n\t    },\n\n\t    // a simple route used in situations when main routing method fails\n\t    // (exceed max number of loop iterations, inaccessible)\n\t    fallbackRoute: function(from, to, opt) {\n\n\t        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n\t        var theta = from.theta(to);\n\n\t        var route = [];\n\n\t        var a = { x: to.x, y: from.y };\n\t        var b = { x: from.x, y: to.y };\n\n\t        if (theta % 180 > 90) {\n\t            var t = a;\n\t            a = b;\n\t            b = t;\n\t        }\n\n\t        var p1 = (theta % 90) < 45 ? a : b;\n\t        var l1 = new Line(from, p1);\n\n\t        var alpha = 90 * Math.ceil(theta / 90);\n\n\t        var p2 = Point.fromPolar(l1.squaredLength(), toRad(alpha + 135), p1);\n\t        var l2 = new Line(to, p2);\n\n\t        var intersectionPoint = l1.intersection(l2);\n\t        var point = intersectionPoint ? intersectionPoint : to;\n\n\t        var directionFrom = intersectionPoint ? point : from;\n\n\t        var quadrant = 360 / opt.directions.length;\n\t        var angleTheta = directionFrom.theta(to);\n\t        var normalizedAngle = normalizeAngle(angleTheta + (quadrant / 2));\n\t        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n\t        opt.previousDirectionAngle = directionAngle;\n\n\t        if (point) { route.push(point.round()); }\n\t        route.push(to);\n\n\t        return route;\n\t    }\n\t};\n\n\t// public function\n\tvar metro = function(vertices, opt, linkView) {\n\n\t    if (!isFunction(manhattan)) {\n\t        throw new Error('Metro requires the manhattan router.');\n\t    }\n\n\t    return manhattan(vertices, assign({}, config$2, opt), linkView);\n\t};\n\n\n\n\tvar routers = ({\n\t\tnormal: normal,\n\t\toneSide: oneSide,\n\t\torthogonal: orthogonal,\n\t\tmanhattan: manhattan,\n\t\tmetro: metro\n\t});\n\n\t// default size of jump if not specified in options\n\tvar JUMP_SIZE = 5;\n\n\t// available jump types\n\t// first one taken as default\n\tvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n\t// default radius\n\tvar RADIUS = 0;\n\n\t// takes care of math. error for case when jump is too close to end of line\n\tvar CLOSE_PROXIMITY_PADDING = 1;\n\n\t// list of connector types not to jump over.\n\tvar IGNORED_CONNECTORS = ['smooth'];\n\n\t// internal constants for round segment\n\tvar _13 = 1 / 3;\n\tvar _23 = 2 / 3;\n\n\t/**\n\t * Transform start/end and route into series of lines\n\t * @param {g.point} sourcePoint start point\n\t * @param {g.point} targetPoint end point\n\t * @param {g.point[]} route optional list of route\n\t * @return {g.line[]} [description]\n\t */\n\tfunction createLines(sourcePoint, targetPoint, route) {\n\t    // make a flattened array of all points\n\t    var points = [].concat(sourcePoint, route, targetPoint);\n\t    return points.reduce(function(resultLines, point, idx) {\n\t        // if there is a next point, make a line with it\n\t        var nextPoint = points[idx + 1];\n\t        if (nextPoint != null) {\n\t            resultLines[idx] = line(point, nextPoint);\n\t        }\n\t        return resultLines;\n\t    }, []);\n\t}\n\n\tfunction setupUpdating(jumpOverLinkView) {\n\t    var paper = jumpOverLinkView.paper;\n\t    var updateList = paper._jumpOverUpdateList;\n\n\t    // first time setup for this paper\n\t    if (updateList == null) {\n\t        updateList = paper._jumpOverUpdateList = [];\n\t        var graph = paper.model;\n\t        graph.on('batch:stop', function() {\n\t            if (this.hasActiveBatch()) { return; }\n\t            updateJumpOver(paper);\n\t        });\n\t        graph.on('reset', function() {\n\t            updateList = paper._jumpOverUpdateList = [];\n\t        });\n\t    }\n\n\t    // add this link to a list so it can be updated when some other link is updated\n\t    if (updateList.indexOf(jumpOverLinkView) < 0) {\n\t        updateList.push(jumpOverLinkView);\n\n\t        // watch for change of connector type or removal of link itself\n\t        // to remove the link from a list of jump over connectors\n\t        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n\t            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n\t        });\n\t    }\n\t}\n\n\t/**\n\t * Handler for a batch:stop event to force\n\t * update of all registered links with jump over connector\n\t * @param {object} batchEvent optional object with info about batch\n\t */\n\tfunction updateJumpOver(paper) {\n\t    var updateList = paper._jumpOverUpdateList;\n\t    for (var i = 0; i < updateList.length; i++) {\n\t        updateList[i].requestConnectionUpdate();\n\t    }\n\t}\n\n\t/**\n\t * Utility function to collect all intersection points of a single\n\t * line against group of other lines.\n\t * @param {g.line} line where to find points\n\t * @param {g.line[]} crossCheckLines lines to cross\n\t * @return {g.point[]} list of intersection points\n\t */\n\tfunction findLineIntersections(line, crossCheckLines) {\n\t    return toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n\t        var intersection = line.intersection(crossCheckLine);\n\t        if (intersection) {\n\t            res.push(intersection);\n\t        }\n\t        return res;\n\t    }, []);\n\t}\n\n\t/**\n\t * Sorting function for list of points by their distance.\n\t * @param {g.point} p1 first point\n\t * @param {g.point} p2 second point\n\t * @return {number} squared distance between points\n\t */\n\tfunction sortPoints(p1, p2) {\n\t    return line(p1, p2).squaredLength();\n\t}\n\n\t/**\n\t * Split input line into multiple based on intersection points.\n\t * @param {g.line} line input line to split\n\t * @param {g.point[]} intersections points where to split the line\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @return {g.line[]} list of lines being split\n\t */\n\tfunction createJumps(line$1, intersections, jumpSize) {\n\t    return intersections.reduce(function(resultLines, point$1, idx) {\n\t        // skipping points that were merged with the previous line\n\t        // to make bigger arc over multiple lines that are close to each other\n\t        if (point$1.skip === true) {\n\t            return resultLines;\n\t        }\n\n\t        // always grab the last line from buffer and modify it\n\t        var lastLine = resultLines.pop() || line$1;\n\n\t        // calculate start and end of jump by moving by a given size of jump\n\t        var jumpStart = point(point$1).move(lastLine.start, -(jumpSize));\n\t        var jumpEnd = point(point$1).move(lastLine.start, +(jumpSize));\n\n\t        // now try to look at the next intersection point\n\t        var nextPoint = intersections[idx + 1];\n\t        if (nextPoint != null) {\n\t            var distance = jumpEnd.distance(nextPoint);\n\t            if (distance <= jumpSize) {\n\t                // next point is close enough, move the jump end by this\n\t                // difference and mark the next point to be skipped\n\t                jumpEnd = nextPoint.move(lastLine.start, distance);\n\t                nextPoint.skip = true;\n\t            }\n\t        } else {\n\t            // this block is inside of `else` as an optimization so the distance is\n\t            // not calculated when we know there are no other intersection points\n\t            var endDistance = jumpStart.distance(lastLine.end);\n\t            // if the end is too close to possible jump, draw remaining line instead of a jump\n\t            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n\t                resultLines.push(lastLine);\n\t                return resultLines;\n\t            }\n\t        }\n\n\t        var startDistance = jumpEnd.distance(lastLine.start);\n\t        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n\t            // if the start of line is too close to jump, draw that line instead of a jump\n\t            resultLines.push(lastLine);\n\t            return resultLines;\n\t        }\n\n\t        // finally create a jump line\n\t        var jumpLine = line(jumpStart, jumpEnd);\n\t        // it's just simple line but with a `isJump` property\n\t        jumpLine.isJump = true;\n\n\t        resultLines.push(\n\t            line(lastLine.start, jumpStart),\n\t            jumpLine,\n\t            line(jumpEnd, lastLine.end)\n\t        );\n\t        return resultLines;\n\t    }, []);\n\t}\n\n\t/**\n\t * Assemble `D` attribute of a SVG path by iterating given lines.\n\t * @param {g.line[]} lines source lines to use\n\t * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n\t * @param {number} radius the radius\n\t * @return {string}\n\t */\n\tfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n\t    var path = new Path();\n\t    var segment;\n\n\t    // first move to the start of a first line\n\t    segment = Path.createSegment('M', lines[0].start);\n\t    path.appendSegment(segment);\n\n\t    // make a paths from lines\n\t    toArray(lines).forEach(function(line, index) {\n\n\t        if (line.isJump) {\n\t            var angle, diff;\n\n\t            var control1, control2;\n\n\t            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n\t                angle = -90;\n\t                // determine rotation of arc based on difference between points\n\t                diff = line.start.difference(line.end);\n\t                // make sure the arc always points up (or right)\n\t                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n\t                if (xAxisRotate) { angle += 180; }\n\n\t                var midpoint = line.midpoint();\n\t                var centerLine = new Line(midpoint, line.end).rotate(midpoint, angle);\n\n\t                var halfLine;\n\n\t                // first half\n\t                halfLine = new Line(line.start, midpoint);\n\n\t                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n\t                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n\t                segment = Path.createSegment('C', control1, control2, centerLine.end);\n\t                path.appendSegment(segment);\n\n\t                // second half\n\t                halfLine = new Line(midpoint, line.end);\n\n\t                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n\t                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n\t                segment = Path.createSegment('C', control1, control2, line.end);\n\t                path.appendSegment(segment);\n\n\t            } else if (jumpType === 'gap') {\n\t                segment = Path.createSegment('M', line.end);\n\t                path.appendSegment(segment);\n\n\t            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n\t                angle = line.start.theta(line.end);\n\n\t                var xOffset = jumpSize * 0.6;\n\t                var yOffset = jumpSize * 1.35;\n\n\t                // determine rotation of arc based on difference between points\n\t                diff = line.start.difference(line.end);\n\t                // make sure the arc always points up (or right)\n\t                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n\t                if (xAxisRotate) { yOffset *= -1; }\n\n\t                control1 = Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n\t                control2 = Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n\t                segment = Path.createSegment('C', control1, control2, line.end);\n\t                path.appendSegment(segment);\n\t            }\n\n\t        } else {\n\t            var nextLine = lines[index + 1];\n\t            if (radius == 0 || !nextLine || nextLine.isJump) {\n\t                segment = Path.createSegment('L', line.end);\n\t                path.appendSegment(segment);\n\t            } else {\n\t                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n\t            }\n\t        }\n\t    });\n\n\t    return path;\n\t}\n\n\tfunction buildRoundedSegment(offset, path, curr, prev, next) {\n\t    var prevDistance = curr.distance(prev) / 2;\n\t    var nextDistance = curr.distance(next) / 2;\n\n\t    var startMove = -Math.min(offset, prevDistance);\n\t    var endMove = -Math.min(offset, nextDistance);\n\n\t    var roundedStart = curr.clone().move(prev, startMove).round();\n\t    var roundedEnd = curr.clone().move(next, endMove).round();\n\n\t    var control1 = new Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n\t    var control2 = new Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n\t    var segment;\n\t    segment = Path.createSegment('L', roundedStart);\n\t    path.appendSegment(segment);\n\n\t    segment = Path.createSegment('C', control1, control2, roundedEnd);\n\t    path.appendSegment(segment);\n\t}\n\n\t/**\n\t * Actual connector function that will be run on every update.\n\t * @param {g.point} sourcePoint start point of this link\n\t * @param {g.point} targetPoint end point of this link\n\t * @param {g.point[]} route of this link\n\t * @param {object} opt options\n\t * @property {number} size optional size of a jump arc\n\t * @return {string} created `D` attribute of SVG path\n\t */\n\tvar jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n\t    setupUpdating(this);\n\n\t    var raw = opt.raw;\n\t    var jumpSize = opt.size || JUMP_SIZE;\n\t    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n\t    var radius = opt.radius || RADIUS;\n\t    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n\t    // grab the first jump type as a default if specified one is invalid\n\t    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n\t        jumpType = JUMP_TYPES[0];\n\t    }\n\n\t    var paper = this.paper;\n\t    var graph = paper.model;\n\t    var allLinks = graph.getLinks();\n\n\t    // there is just one link, draw it directly\n\t    if (allLinks.length === 1) {\n\t        return buildPath(\n\t            createLines(sourcePoint, targetPoint, route),\n\t            jumpSize, jumpType, radius\n\t        );\n\t    }\n\n\t    var thisModel = this.model;\n\t    var thisIndex = allLinks.indexOf(thisModel);\n\t    var defaultConnector = paper.options.defaultConnector || {};\n\n\t    // not all links are meant to be jumped over.\n\t    var links = allLinks.filter(function(link, idx) {\n\n\t        var connector = link.get('connector') || defaultConnector;\n\n\t        // avoid jumping over links with connector type listed in `ignored connectors`.\n\t        if (toArray(ignoreConnectors).includes(connector.name)) {\n\t            return false;\n\t        }\n\t        // filter out links that are above this one and  have the same connector type\n\t        // otherwise there would double hoops for each intersection\n\t        if (idx > thisIndex) {\n\t            return connector.name !== 'jumpover';\n\t        }\n\t        return true;\n\t    });\n\n\t    // find views for all links\n\t    var linkViews = links.map(function(link) {\n\t        return paper.findViewByModel(link);\n\t    });\n\n\t    // create lines for this link\n\t    var thisLines = createLines(\n\t        sourcePoint,\n\t        targetPoint,\n\t        route\n\t    );\n\n\t    // create lines for all other links\n\t    var linkLines = linkViews.map(function(linkView) {\n\t        if (linkView == null) {\n\t            return [];\n\t        }\n\t        if (linkView === this) {\n\t            return thisLines;\n\t        }\n\t        return createLines(\n\t            linkView.sourcePoint,\n\t            linkView.targetPoint,\n\t            linkView.route\n\t        );\n\t    }, this);\n\n\t    // transform lines for this link by splitting with jump lines at\n\t    // points of intersection with other links\n\t    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n\t        // iterate all links and grab the intersections with this line\n\t        // these are then sorted by distance so the line can be split more easily\n\n\t        var intersections = links.reduce(function(res, link, i) {\n\t            // don't intersection with itself\n\t            if (link !== thisModel) {\n\n\t                var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n\t                res.push.apply(res, lineIntersections);\n\t            }\n\t            return res;\n\t        }, []).sort(function(a, b) {\n\t            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n\t        });\n\n\t        if (intersections.length > 0) {\n\t            // split the line based on found intersection points\n\t            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n\t        } else {\n\t            // without any intersection the line goes uninterrupted\n\t            resultLines.push(thisLine);\n\t        }\n\t        return resultLines;\n\t    }, []);\n\n\t    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n\t    return (raw) ? path : path.serialize();\n\t};\n\n\tvar normal$1 = function(sourcePoint, targetPoint, route, opt) {\n\n\t    var raw = opt && opt.raw;\n\t    var points = [sourcePoint].concat(route).concat([targetPoint]);\n\n\t    var polyline = new Polyline(points);\n\t    var path = new Path(polyline);\n\n\t    return (raw) ? path : path.serialize();\n\t};\n\n\tvar rounded = function(sourcePoint, targetPoint, route, opt) {\n\n\t    opt || (opt = {});\n\n\t    var offset = opt.radius || 10;\n\t    var raw = opt.raw;\n\t    var path = new Path();\n\t    var segment;\n\n\t    segment = Path.createSegment('M', sourcePoint);\n\t    path.appendSegment(segment);\n\n\t    var _13 = 1 / 3;\n\t    var _23 = 2 / 3;\n\n\t    var curr;\n\t    var prev, next;\n\t    var prevDistance, nextDistance;\n\t    var startMove, endMove;\n\t    var roundedStart, roundedEnd;\n\t    var control1, control2;\n\n\t    for (var index = 0, n = route.length; index < n; index++) {\n\n\t        curr = new Point(route[index]);\n\n\t        prev = route[index - 1] || sourcePoint;\n\t        next = route[index + 1] || targetPoint;\n\n\t        prevDistance = nextDistance || (curr.distance(prev) / 2);\n\t        nextDistance = curr.distance(next) / 2;\n\n\t        startMove = -Math.min(offset, prevDistance);\n\t        endMove = -Math.min(offset, nextDistance);\n\n\t        roundedStart = curr.clone().move(prev, startMove).round();\n\t        roundedEnd = curr.clone().move(next, endMove).round();\n\n\t        control1 = new Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n\t        control2 = new Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n\t        segment = Path.createSegment('L', roundedStart);\n\t        path.appendSegment(segment);\n\n\t        segment = Path.createSegment('C', control1, control2, roundedEnd);\n\t        path.appendSegment(segment);\n\t    }\n\n\t    segment = Path.createSegment('L', targetPoint);\n\t    path.appendSegment(segment);\n\n\t    return (raw) ? path : path.serialize();\n\t};\n\n\tvar smooth = function(sourcePoint, targetPoint, route, opt) {\n\n\t    var raw = opt && opt.raw;\n\t    var path;\n\n\t    if (route && route.length !== 0) {\n\n\t        var points = [sourcePoint].concat(route).concat([targetPoint]);\n\t        var curves = Curve.throughPoints(points);\n\n\t        path = new Path(curves);\n\n\t    } else {\n\t        // if we have no route, use a default cubic bezier curve\n\t        // cubic bezier requires two control points\n\t        // the control points have `x` midway between source and target\n\t        // this produces an S-like curve\n\n\t        path = new Path();\n\n\t        var segment;\n\n\t        segment = Path.createSegment('M', sourcePoint);\n\t        path.appendSegment(segment);\n\n\t        if ((Math.abs(sourcePoint.x - targetPoint.x)) >= (Math.abs(sourcePoint.y - targetPoint.y))) {\n\t            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\n\t            segment = Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n\t            path.appendSegment(segment);\n\n\t        } else {\n\t            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\n\t            segment = Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n\t            path.appendSegment(segment);\n\n\t        }\n\t    }\n\n\t    return (raw) ? path : path.serialize();\n\t};\n\n\n\n\tvar connectors = ({\n\t\tjumpover: jumpover,\n\t\tnormal: normal$1,\n\t\trounded: rounded,\n\t\tsmooth: smooth\n\t});\n\n\t// Link base view and controller.\n\t// ----------------------------------------\n\n\tvar LinkView = CellView.extend({\n\n\t    className: function() {\n\n\t        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n\t        classNames.push('link');\n\n\t        return classNames.join(' ');\n\t    },\n\n\t    options: {\n\n\t        shortLinkLength: 105,\n\t        doubleLinkTools: false,\n\t        longLinkLength: 155,\n\t        linkToolsOffset: 40,\n\t        doubleLinkToolsOffset: 65,\n\t        sampleInterval: 50,\n\t    },\n\n\t    _labelCache: null,\n\t    _labelSelectors: null,\n\t    _markerCache: null,\n\t    _V: null,\n\t    _dragData: null, // deprecated\n\n\t    metrics: null,\n\t    decimalsRounding: 2,\n\n\t    initialize: function() {\n\n\t        CellView.prototype.initialize.apply(this, arguments);\n\n\t        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n\t        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n\t        // nodes in `updateLabelPosition()` in order to update the label positions.\n\t        this._labelCache = {};\n\n\t        // a cache of label selectors\n\t        this._labelSelectors = {};\n\n\t        // keeps markers bboxes and positions again for quicker access\n\t        this._markerCache = {};\n\n\t        // cache of default markup nodes\n\t        this._V = {};\n\n\t        // connection path metrics\n\t        this.metrics = {};\n\t    },\n\n\t    presentationAttributes: {\n\t        markup: ['RENDER'],\n\t        attrs: ['UPDATE'],\n\t        router: ['UPDATE'],\n\t        connector: ['UPDATE'],\n\t        smooth: ['UPDATE'],\n\t        manhattan: ['UPDATE'],\n\t        toolMarkup: ['LEGACY_TOOLS'],\n\t        labels: ['LABELS'],\n\t        labelMarkup: ['LABELS'],\n\t        vertices: ['VERTICES', 'UPDATE'],\n\t        vertexMarkup: ['VERTICES'],\n\t        source: ['SOURCE', 'UPDATE'],\n\t        target: ['TARGET', 'UPDATE']\n\t    },\n\n\t    initFlag: ['RENDER', 'SOURCE', 'TARGET', 'TOOLS'],\n\n\t    UPDATE_PRIORITY: 1,\n\n\t    confirmUpdate: function(flags, opt) {\n\n\t        opt || (opt = {});\n\n\t        if (this.hasFlag(flags, 'SOURCE')) {\n\t            if (!this.updateEndProperties('source')) { return flags; }\n\t            flags = this.removeFlag(flags, 'SOURCE');\n\t        }\n\n\t        if (this.hasFlag(flags, 'TARGET')) {\n\t            if (!this.updateEndProperties('target')) { return flags; }\n\t            flags = this.removeFlag(flags, 'TARGET');\n\t        }\n\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var sourceView = ref.sourceView;\n\t        var targetView = ref.targetView;\n\t        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n\t            // Wait for the sourceView and targetView to be rendered\n\t            return flags;\n\t        }\n\n\t        if (this.hasFlag(flags, 'RENDER')) {\n\t            this.render();\n\t            this.updateHighlighters(true);\n\t            this.updateTools(opt);\n\t            flags = this.removeFlag(flags, ['RENDER', 'UPDATE', 'VERTICES', 'LABELS', 'TOOLS', 'LEGACY_TOOLS']);\n\t            return flags;\n\t        }\n\n\t        var updateHighlighters = false;\n\n\t        if (this.hasFlag(flags, 'VERTICES')) {\n\t            this.renderVertexMarkers();\n\t            flags = this.removeFlag(flags, 'VERTICES');\n\t        }\n\n\t        var ref$1 = this;\n\t        var model = ref$1.model;\n\t        var attributes = model.attributes;\n\t        var updateLabels = this.hasFlag(flags, 'LABELS');\n\t        var updateLegacyTools = this.hasFlag(flags, 'LEGACY_TOOLS');\n\n\t        if (updateLabels) {\n\t            this.onLabelsChange(model, attributes.labels, opt);\n\t            flags = this.removeFlag(flags, 'LABELS');\n\t            updateHighlighters = true;\n\t        }\n\n\t        if (updateLegacyTools) {\n\t            this.renderTools();\n\t            flags = this.removeFlag(flags, 'LEGACY_TOOLS');\n\t        }\n\n\t        if (this.hasFlag(flags, 'UPDATE')) {\n\t            this.update(model, null, opt);\n\t            this.updateTools(opt);\n\t            flags = this.removeFlag(flags, ['UPDATE', 'TOOLS']);\n\t            updateLabels = false;\n\t            updateLegacyTools = false;\n\t            updateHighlighters = true;\n\t        }\n\n\t        if (updateLabels) {\n\t            this.updateLabelPositions();\n\t        }\n\n\t        if (updateLegacyTools) {\n\t            this.updateToolsPosition();\n\t        }\n\n\t        if (updateHighlighters) {\n\t            this.updateHighlighters();\n\t        }\n\n\t        if (this.hasFlag(flags, 'TOOLS')) {\n\t            this.updateTools(opt);\n\t            flags = this.removeFlag(flags, 'TOOLS');\n\t        }\n\n\t        return flags;\n\t    },\n\n\t    requestConnectionUpdate: function(opt) {\n\t        this.requestUpdate(this.getFlag('UPDATE', opt));\n\t    },\n\n\t    isLabelsRenderRequired: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var previousLabels = this.model.previous('labels');\n\t        if (!previousLabels) { return true; }\n\n\t        // Here is an optimization for cases when we know, that change does\n\t        // not require re-rendering of all labels.\n\t        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n\t            // The label is setting by `prop()` method\n\t            var pathArray = opt.propertyPathArray || [];\n\t            var pathLength = pathArray.length;\n\t            if (pathLength > 1) {\n\t                // We are changing a single label here e.g. 'labels/0/position'\n\t                var labelExists = !!previousLabels[pathArray[1]];\n\t                if (labelExists) {\n\t                    if (pathLength === 2) {\n\t                        // We are changing the entire label. Need to check if the\n\t                        // markup is also being changed.\n\t                        return ('markup' in Object(opt.propertyValue));\n\t                    } else if (pathArray[2] !== 'markup') {\n\t                        // We are changing a label property but not the markup\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return true;\n\t    },\n\n\t    onLabelsChange: function(_link, _labels, opt) {\n\n\t        // Note: this optimization works in async=false mode only\n\t        if (this.isLabelsRenderRequired(opt)) {\n\t            this.renderLabels();\n\t        } else {\n\t            this.updateLabels();\n\t        }\n\t    },\n\n\t    // Rendering.\n\t    // ----------\n\n\t    render: function() {\n\n\t        this.vel.empty();\n\t        this._V = {};\n\t        this.renderMarkup();\n\t        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n\t        // returns zero values)\n\t        this.renderLabels();\n\t        this.update();\n\n\t        return this;\n\t    },\n\n\t    renderMarkup: function() {\n\n\t        var link = this.model;\n\t        var markup = link.get('markup') || link.markup;\n\t        if (!markup) { throw new Error('dia.LinkView: markup required'); }\n\t        if (Array.isArray(markup)) { return this.renderJSONMarkup(markup); }\n\t        if (typeof markup === 'string') { return this.renderStringMarkup(markup); }\n\t        throw new Error('dia.LinkView: invalid markup');\n\t    },\n\n\t    renderJSONMarkup: function(markup) {\n\n\t        var doc = this.parseDOMJSON(markup, this.el);\n\t        // Selectors\n\t        this.selectors = doc.selectors;\n\t        // Fragment\n\t        this.vel.append(doc.fragment);\n\t    },\n\n\t    renderStringMarkup: function(markup) {\n\n\t        // A special markup can be given in the `properties.markup` property. This might be handy\n\t        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n\t        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n\t        // of elements with special meaning though. Therefore, those classes should be preserved in any\n\t        // special markup passed in `properties.markup`.\n\t        var children = V(markup);\n\t        // custom markup may contain only one children\n\t        if (!Array.isArray(children)) { children = [children]; }\n\t        // Cache all children elements for quicker access.\n\t        var cache = this._V; // vectorized markup;\n\t        for (var i = 0, n = children.length; i < n; i++) {\n\t            var child = children[i];\n\t            var className = child.attr('class');\n\t            if (className) {\n\t                // Strip the joint class name prefix, if there is one.\n\t                className = removeClassNamePrefix(className);\n\t                cache[$.camelCase(className)] = child;\n\t            }\n\t        }\n\t        // partial rendering\n\t        this.renderTools();\n\t        this.renderVertexMarkers();\n\t        this.renderArrowheadMarkers();\n\t        this.vel.append(children);\n\t    },\n\n\t    _getLabelMarkup: function(labelMarkup) {\n\n\t        if (!labelMarkup) { return undefined; }\n\n\t        if (Array.isArray(labelMarkup)) { return this.parseDOMJSON(labelMarkup, null); }\n\t        if (typeof labelMarkup === 'string') { return this._getLabelStringMarkup(labelMarkup); }\n\t        throw new Error('dia.linkView: invalid label markup');\n\t    },\n\n\t    _getLabelStringMarkup: function(labelMarkup) {\n\n\t        var children = V(labelMarkup);\n\t        var fragment = document.createDocumentFragment();\n\n\t        if (!Array.isArray(children)) {\n\t            fragment.appendChild(children.node);\n\n\t        } else {\n\t            for (var i = 0, n = children.length; i < n; i++) {\n\t                var currentChild = children[i].node;\n\t                fragment.appendChild(currentChild);\n\t            }\n\t        }\n\n\t        return { fragment: fragment, selectors: {}}; // no selectors\n\t    },\n\n\t    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n\t    // If it doesn't, add the <g /> container here.\n\t    _normalizeLabelMarkup: function(markup) {\n\n\t        if (!markup) { return undefined; }\n\n\t        var fragment = markup.fragment;\n\t        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) { throw new Error('dia.LinkView: invalid label markup.'); }\n\n\t        var vNode;\n\t        var childNodes = fragment.childNodes;\n\n\t        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n\t            // default markup fragment is not wrapped in <g />\n\t            // add a <g /> container\n\t            vNode = V('g').append(fragment);\n\t        } else {\n\t            vNode = V(childNodes[0]);\n\t        }\n\n\t        vNode.addClass('label');\n\n\t        return { node: vNode.node, selectors: markup.selectors };\n\t    },\n\n\t    renderLabels: function() {\n\n\t        var cache = this._V;\n\t        var vLabels = cache.labels;\n\t        var labelCache = this._labelCache = {};\n\t        var labelSelectors = this._labelSelectors = {};\n\t        var model = this.model;\n\t        var labels = model.attributes.labels || [];\n\t        var labelsCount = labels.length;\n\n\t        if (labelsCount === 0) {\n\t            if (vLabels) { vLabels.remove(); }\n\t            return this;\n\t        }\n\n\t        if (vLabels) {\n\t            vLabels.empty();\n\t        }  else {\n\t            // there is no label container in the markup but some labels are defined\n\t            // add a <g class=\"labels\" /> container\n\t            vLabels = cache.labels = V('g').addClass('labels');\n\t        }\n\n\t        var container = vLabels.node;\n\n\t        for (var i = 0; i < labelsCount; i++) {\n\n\t            var label = labels[i];\n\t            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n\t            var labelNode;\n\t            var selectors;\n\t            if (labelMarkup) {\n\n\t                labelNode = labelMarkup.node;\n\t                selectors = labelMarkup.selectors;\n\n\t            } else {\n\n\t                var builtinDefaultLabel =  model._builtins.defaultLabel;\n\t                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n\t                var defaultLabel = model._getDefaultLabel();\n\t                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n\t                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n\t                labelNode = defaultMarkup.node;\n\t                selectors = defaultMarkup.selectors;\n\t            }\n\n\t            labelNode.setAttribute('label-idx', i); // assign label-idx\n\t            container.appendChild(labelNode);\n\t            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n\t            var rootSelector = this.selector;\n\t            if (selectors[rootSelector]) { throw new Error('dia.LinkView: ambiguous label root selector.'); }\n\t            selectors[rootSelector] = labelNode;\n\n\t            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n\t        }\n\n\t        if (!container.parentNode) {\n\t            this.el.appendChild(container);\n\t        }\n\n\t        this.updateLabels();\n\n\t        return this;\n\t    },\n\n\t    findLabelNode: function(labelIndex, selector) {\n\t        var labelRoot = this._labelCache[labelIndex];\n\t        if (!labelRoot) { return null; }\n\t        var labelSelectors = this._labelSelectors[labelIndex];\n\t        var ref = this.findBySelector(selector, labelRoot, labelSelectors);\n\t        var node = ref[0]; if ( node === void 0 ) node = null;\n\t        return node;\n\t    },\n\n\n\t    // merge default label attrs into label attrs\n\t    // keep `undefined` or `null` because `{}` means something else\n\t    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n\t        if (labelAttrs === null) { return null; }\n\t        if (labelAttrs === undefined) {\n\n\t            if (defaultLabelAttrs === null) { return null; }\n\t            if (defaultLabelAttrs === undefined) {\n\n\t                if (hasCustomMarkup) { return undefined; }\n\t                return builtinDefaultLabelAttrs;\n\t            }\n\n\t            if (hasCustomMarkup) { return defaultLabelAttrs; }\n\t            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n\t        }\n\n\t        if (hasCustomMarkup) { return merge({}, defaultLabelAttrs, labelAttrs); }\n\t        return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n\t    },\n\n\t    updateLabels: function() {\n\n\t        if (!this._V.labels) { return this; }\n\n\t        var model = this.model;\n\t        var labels = model.get('labels') || [];\n\t        var canLabelMove = this.can('labelMove');\n\n\t        var builtinDefaultLabel = model._builtins.defaultLabel;\n\t        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n\t        var defaultLabel = model._getDefaultLabel();\n\t        var defaultLabelMarkup = defaultLabel.markup;\n\t        var defaultLabelAttrs = defaultLabel.attrs;\n\n\t        for (var i = 0, n = labels.length; i < n; i++) {\n\n\t            var labelNode = this._labelCache[i];\n\t            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n\t            var selectors = this._labelSelectors[i];\n\n\t            var label = labels[i];\n\t            var labelMarkup = label.markup;\n\t            var labelAttrs = label.attrs;\n\n\t            var attrs = this._mergeLabelAttrs(\n\t                (labelMarkup || defaultLabelMarkup),\n\t                labelAttrs,\n\t                defaultLabelAttrs,\n\t                builtinDefaultLabelAttrs\n\t            );\n\n\t            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n\t                rootBBox: new Rect(label.size),\n\t                selectors: selectors\n\t            });\n\t        }\n\n\t        return this;\n\t    },\n\n\t    renderTools: function() {\n\n\t        if (!this._V.linkTools) { return this; }\n\n\t        // Tools are a group of clickable elements that manipulate the whole link.\n\t        // A good example of this is the remove tool that removes the whole link.\n\t        // Tools appear after hovering the link close to the `source` element/point of the link\n\t        // but are offset a bit so that they don't cover the `marker-arrowhead`.\n\n\t        var $tools = $(this._V.linkTools.node).empty();\n\t        var toolTemplate = template(this.model.get('toolMarkup') || this.model.toolMarkup);\n\t        var tool = V(toolTemplate());\n\n\t        $tools.append(tool.node);\n\n\t        // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n\t        this._toolCache = tool;\n\n\t        // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n\t        // link as well but only if the link is longer than `longLinkLength`.\n\t        if (this.options.doubleLinkTools) {\n\n\t            var tool2;\n\t            if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\n\t                toolTemplate = template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\n\t                tool2 = V(toolTemplate());\n\t            } else {\n\t                tool2 = tool.clone();\n\t            }\n\n\t            $tools.append(tool2.node);\n\t            this._tool2Cache = tool2;\n\t        }\n\n\t        return this;\n\t    },\n\n\t    renderVertexMarkers: function() {\n\n\t        if (!this._V.markerVertices) { return this; }\n\n\t        var $markerVertices = $(this._V.markerVertices.node).empty();\n\n\t        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n\t        // if default styling (elements) are not desired. This makes it possible to use any\n\t        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n\t        var markupTemplate = template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\n\n\t        this.model.vertices().forEach(function(vertex, idx) {\n\t            $markerVertices.append(V(markupTemplate(assign({ idx: idx }, vertex))).node);\n\t        });\n\n\t        return this;\n\t    },\n\n\t    renderArrowheadMarkers: function() {\n\n\t        // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n\t        if (!this._V.markerArrowheads) { return this; }\n\n\t        var $markerArrowheads = $(this._V.markerArrowheads.node);\n\n\t        $markerArrowheads.empty();\n\n\t        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n\t        // if default styling (elements) are not desired. This makes it possible to use any\n\t        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n\t        var markupTemplate = template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\n\n\t        this._V.sourceArrowhead = V(markupTemplate({ end: 'source' }));\n\t        this._V.targetArrowhead = V(markupTemplate({ end: 'target' }));\n\n\t        $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n\n\t        return this;\n\t    },\n\n\t    // Updating.\n\t    // ---------\n\n\t    // Default is to process the `attrs` object and set attributes on subelements based on the selectors.\n\t    update: function(model, attributes, opt) {\n\n\t        opt || (opt = {});\n\n\t        this.cleanNodesCache();\n\n\t        // update the link path\n\t        this.updateConnection(opt);\n\n\t        // update SVG attributes defined by 'attrs/'.\n\t        this.updateDOMSubtreeAttributes(this.el, this.model.attr(), { selectors: this.selectors });\n\n\t        this.updateDefaultConnectionPath();\n\n\t        // update the label position etc.\n\t        this.updateLabelPositions();\n\t        this.updateToolsPosition();\n\t        this.updateArrowheadMarkers();\n\n\t        // *Deprecated*\n\t        // Local perpendicular flag (as opposed to one defined on paper).\n\t        // Could be enabled inside a connector/router. It's valid only\n\t        // during the update execution.\n\t        this.options.perpendicular = null;\n\n\t        return this;\n\t    },\n\n\t    // remove vertices that lie on (or nearly on) straight lines within the link\n\t    // return the number of removed points\n\t    removeRedundantLinearVertices: function(opt) {\n\n\t        var SIMPLIFY_THRESHOLD = 0.001;\n\n\t        var link = this.model;\n\t        var vertices = link.vertices();\n\t        var routePoints = [this.sourceAnchor ].concat( vertices, [this.targetAnchor]);\n\t        var numRoutePoints = routePoints.length;\n\n\t        // put routePoints into a polyline and try to simplify\n\t        var polyline = new Polyline(routePoints);\n\t        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n\t        var polylinePoints = polyline.points.map(function (point) { return (point.toJSON()); }); // JSON of points after simplification\n\t        var numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n\t        // shortcut if simplification did not remove any redundant vertices:\n\t        if (numRoutePoints === numPolylinePoints) { return 0; }\n\n\t        // else: set simplified polyline points as link vertices\n\t        // remove first and last polyline points again (= source/target anchors)\n\t        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n\t        return (numRoutePoints - numPolylinePoints);\n\t    },\n\n\t    updateDefaultConnectionPath: function() {\n\n\t        var cache = this._V;\n\n\t        if (cache.connection) {\n\t            cache.connection.attr('d', this.getSerializedConnection());\n\t        }\n\n\t        if (cache.connectionWrap) {\n\t            cache.connectionWrap.attr('d', this.getSerializedConnection());\n\t        }\n\n\t        if (cache.markerSource && cache.markerTarget) {\n\t            this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n\t        }\n\t    },\n\n\t    getEndView: function(type) {\n\t        switch (type) {\n\t            case 'source':\n\t                return this.sourceView || null;\n\t            case 'target':\n\t                return this.targetView || null;\n\t            default:\n\t                throw new Error('dia.LinkView: type parameter required.');\n\t        }\n\t    },\n\n\t    getEndAnchor: function(type) {\n\t        switch (type) {\n\t            case 'source':\n\t                return new Point(this.sourceAnchor);\n\t            case 'target':\n\t                return new Point(this.targetAnchor);\n\t            default:\n\t                throw new Error('dia.LinkView: type parameter required.');\n\t        }\n\t    },\n\n\t    getEndConnectionPoint: function(type) {\n\t        switch (type) {\n\t            case 'source':\n\t                return new Point(this.sourcePoint);\n\t            case 'target':\n\t                return new Point(this.targetPoint);\n\t            default:\n\t                throw new Error('dia.LinkView: type parameter required.');\n\t        }\n\t    },\n\n\t    getEndMagnet: function(type) {\n\t        switch (type) {\n\t            case 'source':\n\t                var sourceView = this.sourceView;\n\t                if (!sourceView) { break; }\n\t                return this.sourceMagnet || sourceView.el;\n\t            case 'target':\n\t                var targetView = this.targetView;\n\t                if (!targetView) { break; }\n\t                return this.targetMagnet || targetView.el;\n\t            default:\n\t                throw new Error('dia.LinkView: type parameter required.');\n\t        }\n\t        return null;\n\t    },\n\n\t    updateConnection: function(opt) {\n\n\t        opt = opt || {};\n\n\t        var model = this.model;\n\t        var route, path;\n\n\t        if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n\t            // The link is being translated by an ancestor that will\n\t            // shift source point, target point and all vertices\n\t            // by an equal distance.\n\t            var tx = opt.tx || 0;\n\t            var ty = opt.ty || 0;\n\n\t            route = (new Polyline(this.route)).translate(tx, ty).points;\n\n\t            // translate source and target connection and marker points.\n\t            this._translateConnectionPoints(tx, ty);\n\n\t            // translate the path itself\n\t            path = this.path;\n\t            path.translate(tx, ty);\n\n\t        } else {\n\n\t            var vertices = model.vertices();\n\t            // 1. Find Anchors\n\n\t            var anchors = this.findAnchors(vertices);\n\t            var sourceAnchor = this.sourceAnchor = anchors.source;\n\t            var targetAnchor = this.targetAnchor = anchors.target;\n\n\t            // 2. Find Route\n\t            route = this.findRoute(vertices, opt);\n\n\t            // 3. Find Connection Points\n\t            var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n\t            var sourcePoint = this.sourcePoint = connectionPoints.source;\n\t            var targetPoint = this.targetPoint = connectionPoints.target;\n\n\t            // 3b. Find Marker Connection Point - Backwards Compatibility\n\t            var markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);\n\n\t            // 4. Find Connection\n\t            path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n\t        }\n\n\t        this.route = route;\n\t        this.path = path;\n\t        this.metrics = {};\n\t    },\n\n\t    findMarkerPoints: function(route, sourcePoint, targetPoint) {\n\n\t        var firstWaypoint = route[0];\n\t        var lastWaypoint = route[route.length - 1];\n\n\t        // Move the source point by the width of the marker taking into account\n\t        // its scale around x-axis. Note that scale is the only transform that\n\t        // makes sense to be set in `.marker-source` attributes object\n\t        // as all other transforms (translate/rotate) will be replaced\n\t        // by the `translateAndAutoOrient()` function.\n\t        var cache = this._markerCache;\n\t        // cache source and target points\n\t        var sourceMarkerPoint, targetMarkerPoint;\n\n\t        if (this._V.markerSource) {\n\n\t            cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n\t            sourceMarkerPoint = Point(sourcePoint).move(\n\t                firstWaypoint || targetPoint,\n\t                cache.sourceBBox.width * this._V.markerSource.scale().sx * -1\n\t            ).round();\n\t        }\n\n\t        if (this._V.markerTarget) {\n\n\t            cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n\t            targetMarkerPoint = Point(targetPoint).move(\n\t                lastWaypoint || sourcePoint,\n\t                cache.targetBBox.width * this._V.markerTarget.scale().sx * -1\n\t            ).round();\n\t        }\n\n\t        // if there was no markup for the marker, use the connection point.\n\t        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n\t        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n\n\t        return {\n\t            source: sourceMarkerPoint,\n\t            target: targetMarkerPoint\n\t        };\n\t    },\n\n\t    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n\t        var firstAnchor, secondAnchor;\n\t        var firstAnchorRef, secondAnchorRef;\n\t        var model = this.model;\n\t        var firstDef = model.get(firstEndType);\n\t        var secondDef = model.get(secondEndType);\n\t        var firstView = this.getEndView(firstEndType);\n\t        var secondView = this.getEndView(secondEndType);\n\t        var firstMagnet = this.getEndMagnet(firstEndType);\n\t        var secondMagnet = this.getEndMagnet(secondEndType);\n\n\t        // Anchor first\n\t        if (firstView) {\n\t            if (firstRef) {\n\t                firstAnchorRef = new Point(firstRef);\n\t            } else if (secondView) {\n\t                firstAnchorRef = secondMagnet;\n\t            } else {\n\t                firstAnchorRef = new Point(secondDef);\n\t            }\n\t            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n\t        } else {\n\t            firstAnchor = new Point(firstDef);\n\t        }\n\n\t        // Anchor second\n\t        if (secondView) {\n\t            secondAnchorRef = new Point(secondRef || firstAnchor);\n\t            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n\t        } else {\n\t            secondAnchor = new Point(secondDef);\n\t        }\n\n\t        var res = {};\n\t        res[firstEndType] = firstAnchor;\n\t        res[secondEndType] = secondAnchor;\n\t        return res;\n\t    },\n\n\t    findAnchors: function(vertices) {\n\n\t        var model = this.model;\n\t        var firstVertex = vertices[0];\n\t        var lastVertex = vertices[vertices.length - 1];\n\n\t        if (model.target().priority && !model.source().priority) {\n\t            // Reversed order\n\t            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n\t        }\n\n\t        // Usual order\n\t        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n\t    },\n\n\t    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n\t        var firstWaypoint = route[0];\n\t        var lastWaypoint = route[route.length - 1];\n\t        var model = this.model;\n\t        var sourceDef = model.get('source');\n\t        var targetDef = model.get('target');\n\t        var sourceView = this.sourceView;\n\t        var targetView = this.targetView;\n\t        var paperOptions = this.paper.options;\n\t        var sourceMagnet, targetMagnet;\n\n\t        // Connection Point Source\n\t        var sourcePoint;\n\t        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n\t            sourceMagnet = (this.sourceMagnet || sourceView.el);\n\t            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n\t            var sourcePointRef = firstWaypoint || targetAnchor;\n\t            var sourceLine = new Line(sourcePointRef, sourceAnchor);\n\t            sourcePoint = this.getConnectionPoint(\n\t                sourceConnectionPointDef,\n\t                sourceView,\n\t                sourceMagnet,\n\t                sourceLine,\n\t                'source'\n\t            );\n\t        } else {\n\t            sourcePoint = sourceAnchor;\n\t        }\n\t        // Connection Point Target\n\t        var targetPoint;\n\t        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n\t            targetMagnet = (this.targetMagnet || targetView.el);\n\t            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n\t            var targetPointRef = lastWaypoint || sourceAnchor;\n\t            var targetLine = new Line(targetPointRef, targetAnchor);\n\t            targetPoint = this.getConnectionPoint(\n\t                targetConnectionPointDef,\n\t                targetView,\n\t                targetMagnet,\n\t                targetLine,\n\t                'target'\n\t            );\n\t        } else {\n\t            targetPoint = targetAnchor;\n\t        }\n\n\t        return {\n\t            source: sourcePoint,\n\t            target: targetPoint\n\t        };\n\t    },\n\n\t    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n\t        var isConnection = cellView.isNodeConnection(magnet);\n\t        var paperOptions = this.paper.options;\n\t        if (!anchorDef) {\n\t            if (isConnection) {\n\t                anchorDef = paperOptions.defaultLinkAnchor;\n\t            } else {\n\t                if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n\t                    // Backwards compatibility\n\t                    // If `perpendicularLinks` flag is set on the paper and there are vertices\n\t                    // on the link, then try to find a connection point that makes the link perpendicular\n\t                    // even though the link won't point to the center of the targeted object.\n\t                    anchorDef = { name: 'perpendicular' };\n\t                } else {\n\t                    anchorDef = paperOptions.defaultAnchor;\n\t                }\n\t            }\n\t        }\n\n\t        if (!anchorDef) { throw new Error('Anchor required.'); }\n\t        var anchorFn;\n\t        if (typeof anchorDef === 'function') {\n\t            anchorFn = anchorDef;\n\t        } else {\n\t            var anchorName = anchorDef.name;\n\t            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n\t            anchorFn = paperOptions[anchorNamespace][anchorName];\n\t            if (typeof anchorFn !== 'function') { throw new Error('Unknown anchor: ' + anchorName); }\n\t        }\n\t        var anchor = anchorFn.call(\n\t            this,\n\t            cellView,\n\t            magnet,\n\t            ref,\n\t            anchorDef.args || {},\n\t            endType,\n\t            this\n\t        );\n\t        if (!anchor) { return new Point(); }\n\t        return anchor.round(this.decimalsRounding);\n\t    },\n\n\n\t    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n\t        var connectionPoint;\n\t        var anchor = line.end;\n\t        var paperOptions = this.paper.options;\n\n\t        // Backwards compatibility\n\t        if (typeof paperOptions.linkConnectionPoint === 'function') {\n\t            var linkConnectionMagnet = (magnet === view.el) ? undefined : magnet;\n\t            connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n\t            if (connectionPoint) { return connectionPoint; }\n\t        }\n\n\t        if (!connectionPointDef) { return anchor; }\n\t        var connectionPointFn;\n\t        if (typeof connectionPointDef === 'function') {\n\t            connectionPointFn = connectionPointDef;\n\t        } else {\n\t            var connectionPointName = connectionPointDef.name;\n\t            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n\t            if (typeof connectionPointFn !== 'function') { throw new Error('Unknown connection point: ' + connectionPointName); }\n\t        }\n\t        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n\t        if (!connectionPoint) { return anchor; }\n\t        return connectionPoint.round(this.decimalsRounding);\n\t    },\n\n\t    _translateConnectionPoints: function(tx, ty) {\n\n\t        var cache = this._markerCache;\n\n\t        cache.sourcePoint.offset(tx, ty);\n\t        cache.targetPoint.offset(tx, ty);\n\t        this.sourcePoint.offset(tx, ty);\n\t        this.targetPoint.offset(tx, ty);\n\t        this.sourceAnchor.offset(tx, ty);\n\t        this.targetAnchor.offset(tx, ty);\n\t    },\n\n\t    // if label position is a number, normalize it to a position object\n\t    // this makes sure that label positions can be merged properly\n\t    _normalizeLabelPosition: function(labelPosition) {\n\n\t        if (typeof labelPosition === 'number') { return { distance: labelPosition, offset: null, angle: 0, args: null }; }\n\t        return labelPosition;\n\t    },\n\n\t    updateLabelPositions: function() {\n\n\t        if (!this._V.labels) { return this; }\n\n\t        var path = this.path;\n\t        if (!path) { return this; }\n\n\t        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n\t        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n\t        var model = this.model;\n\t        var labels = model.get('labels') || [];\n\t        if (!labels.length) { return this; }\n\n\t        var builtinDefaultLabel = model._builtins.defaultLabel;\n\t        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n\t        var defaultLabel = model._getDefaultLabel();\n\t        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n\t        var defaultPosition = merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n\n\t        for (var idx = 0, n = labels.length; idx < n; idx++) {\n\t            var labelNode = this._labelCache[idx];\n\t            if (!labelNode) { continue; }\n\t            var label = labels[idx];\n\t            var labelPosition = this._normalizeLabelPosition(label.position);\n\t            var position = merge({}, defaultPosition, labelPosition);\n\t            var transformationMatrix = this._getLabelTransformationMatrix(position);\n\t            labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n\t            this._cleanLabelMatrices(idx);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    _cleanLabelMatrices: function(index) {\n\t        // Clean magnetMatrix for all nodes of the label.\n\t        // Cached BoundingRect does not need to updated when the position changes\n\t        // TODO: this doesn't work for labels with XML String markups.\n\t        var ref = this;\n\t        var metrics = ref.metrics;\n\t        var _labelSelectors = ref._labelSelectors;\n\t        var selectors = _labelSelectors[index];\n\t        if (!selectors) { return; }\n\t        for (var selector in selectors) {\n\t            var ref$1 = selectors[selector];\n\t            var id = ref$1.id;\n\t            if (id && (id in metrics)) { delete metrics[id].magnetMatrix; }\n\t        }\n\t    },\n\n\t    updateToolsPosition: function() {\n\n\t        if (!this._V.linkTools) { return this; }\n\n\t        // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n\t        // Note that the offset is hardcoded here. The offset should be always\n\t        // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n\t        // this up all the time would be slow.\n\n\t        var scale = '';\n\t        var offset = this.options.linkToolsOffset;\n\t        var connectionLength = this.getConnectionLength();\n\n\t        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n\t        // In that case we won't update tools position at all.\n\t        if (!Number.isNaN(connectionLength)) {\n\n\t            // If the link is too short, make the tools half the size and the offset twice as low.\n\t            if (connectionLength < this.options.shortLinkLength) {\n\t                scale = 'scale(.5)';\n\t                offset /= 2;\n\t            }\n\n\t            var toolPosition = this.getPointAtLength(offset);\n\n\t            this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n\t            if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n\n\t                var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n\n\t                toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n\t                this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\t                this._tool2Cache.attr('visibility', 'visible');\n\n\t            } else if (this.options.doubleLinkTools) {\n\n\t                this._tool2Cache.attr('visibility', 'hidden');\n\t            }\n\t        }\n\n\t        return this;\n\t    },\n\n\t    updateArrowheadMarkers: function() {\n\n\t        if (!this._V.markerArrowheads) { return this; }\n\n\t        // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n\t        if ($.css(this._V.markerArrowheads.node, 'display') === 'none') { return this; }\n\n\t        var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n\t        this._V.sourceArrowhead.scale(sx);\n\t        this._V.targetArrowhead.scale(sx);\n\n\t        this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n\n\t        return this;\n\t    },\n\n\t    updateEndProperties: function(endType) {\n\n\t        var ref = this;\n\t        var model = ref.model;\n\t        var paper = ref.paper;\n\t        var endViewProperty = endType + \"View\";\n\t        var endDef = model.get(endType);\n\t        var endId = endDef && endDef.id;\n\n\t        if (!endId) {\n\t            // the link end is a point ~ rect 0x0\n\t            this[endViewProperty] = null;\n\t            this.updateEndMagnet(endType);\n\t            return true;\n\t        }\n\n\t        var endModel = paper.getModelById(endId);\n\t        if (!endModel) { throw new Error('LinkView: invalid ' + endType + ' cell.'); }\n\n\t        var endView = endModel.findView(paper);\n\t        if (!endView) {\n\t            // A view for a model should always exist\n\t            return false;\n\t        }\n\n\t        this[endViewProperty] = endView;\n\t        this.updateEndMagnet(endType);\n\t        return true;\n\t    },\n\n\t    updateEndMagnet: function(endType) {\n\n\t        var endMagnetProperty = endType + \"Magnet\";\n\t        var endView = this.getEndView(endType);\n\t        if (endView) {\n\t            var connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n\t            if (connectedMagnet === endView.el) { connectedMagnet = null; }\n\t            this[endMagnetProperty] = connectedMagnet;\n\t        } else {\n\t            this[endMagnetProperty] = null;\n\t        }\n\t    },\n\n\t    _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {\n\n\t        // Make the markers \"point\" to their sticky points being auto-oriented towards\n\t        // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n\t        var route = toArray(this.route);\n\t        if (sourceArrow) {\n\t            sourceArrow.translateAndAutoOrient(\n\t                this.sourcePoint,\n\t                route[0] || this.targetPoint,\n\t                this.paper.cells\n\t            );\n\t        }\n\n\t        if (targetArrow) {\n\t            targetArrow.translateAndAutoOrient(\n\t                this.targetPoint,\n\t                route[route.length - 1] || this.sourcePoint,\n\t                this.paper.cells\n\t            );\n\t        }\n\t    },\n\n\t    _getLabelPositionAngle: function(idx) {\n\n\t        var labelPosition = this.model.label(idx).position || {};\n\t        return (labelPosition.angle || 0);\n\t    },\n\n\t    _getLabelPositionArgs: function(idx) {\n\n\t        var labelPosition = this.model.label(idx).position || {};\n\t        return labelPosition.args;\n\t    },\n\n\t    _getDefaultLabelPositionArgs: function() {\n\n\t        var defaultLabel = this.model._getDefaultLabel();\n\t        var defaultLabelPosition = defaultLabel.position || {};\n\t        return defaultLabelPosition.args;\n\t    },\n\n\t    // merge default label position args into label position args\n\t    // keep `undefined` or `null` because `{}` means something else\n\t    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n\t        if (labelPositionArgs === null) { return null; }\n\t        if (labelPositionArgs === undefined) {\n\n\t            if (defaultLabelPositionArgs === null) { return null; }\n\t            return defaultLabelPositionArgs;\n\t        }\n\n\t        return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n\t    },\n\n\t    // Add default label at given position at end of `labels` array.\n\t    // Four signatures:\n\t    // - obj, obj = point, opt\n\t    // - obj, num, obj = point, angle, opt\n\t    // - num, num, obj = x, y, opt\n\t    // - num, num, num, obj = x, y, angle, opt\n\t    // Assigns relative coordinates by default:\n\t    // `opt.absoluteDistance` forces absolute coordinates.\n\t    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n\t    // `opt.absoluteOffset` forces absolute coordinates for offset.\n\t    // Additional args:\n\t    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n\t    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n\t    addLabel: function(p1, p2, p3, p4) {\n\n\t        // normalize data from the four possible signatures\n\t        var localX;\n\t        var localY;\n\t        var localAngle = 0;\n\t        var localOpt;\n\t        if (typeof p1 !== 'number') {\n\t            // {x, y} object provided as first parameter\n\t            localX = p1.x;\n\t            localY = p1.y;\n\t            if (typeof p2 === 'number') {\n\t                // angle and opt provided as second and third parameters\n\t                localAngle = p2;\n\t                localOpt = p3;\n\t            } else {\n\t                // opt provided as second parameter\n\t                localOpt = p2;\n\t            }\n\t        } else {\n\t            // x and y provided as first and second parameters\n\t            localX = p1;\n\t            localY = p2;\n\t            if (typeof p3 === 'number') {\n\t                // angle and opt provided as third and fourth parameters\n\t                localAngle = p3;\n\t                localOpt = p4;\n\t            } else {\n\t                // opt provided as third parameter\n\t                localOpt = p3;\n\t            }\n\t        }\n\n\t        // merge label position arguments\n\t        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\t        var labelPositionArgs = localOpt;\n\t        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n\t        // append label to labels array\n\t        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n\t        var idx = -1;\n\t        this.model.insertLabel(idx, label, localOpt);\n\t        return idx;\n\t    },\n\n\t    // Add a new vertex at calculated index to the `vertices` array.\n\t    addVertex: function(x, y, opt) {\n\n\t        // accept input in form `{ x, y }, opt` or `x, y, opt`\n\t        var isPointProvided = (typeof x !== 'number');\n\t        var localX = isPointProvided ? x.x : x;\n\t        var localY = isPointProvided ? x.y : y;\n\t        var localOpt = isPointProvided ? y : opt;\n\n\t        var vertex = { x: localX, y: localY };\n\t        var idx = this.getVertexIndex(localX, localY);\n\t        this.model.insertVertex(idx, vertex, localOpt);\n\t        return idx;\n\t    },\n\n\t    // Send a token (an SVG element, usually a circle) along the connection path.\n\t    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n\t    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n\t    // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n\t    // `opt.connection` is an optional selector to the connection path.\n\t    // `callback` is optional and is a function to be called once the token reaches the target.\n\t    sendToken: function(token, opt, callback) {\n\n\t        function onAnimationEnd(vToken, callback) {\n\t            return function() {\n\t                vToken.remove();\n\t                if (typeof callback === 'function') {\n\t                    callback();\n\t                }\n\t            };\n\t        }\n\n\t        var duration, isReversed, selector;\n\t        if (isObject$1(opt)) {\n\t            duration = opt.duration;\n\t            isReversed = (opt.direction === 'reverse');\n\t            selector = opt.connection;\n\t        } else {\n\t            // Backwards compatibility\n\t            duration = opt;\n\t            isReversed = false;\n\t            selector = null;\n\t        }\n\n\t        duration = duration || 1000;\n\n\t        var animationAttributes = {\n\t            dur: duration + 'ms',\n\t            repeatCount: 1,\n\t            calcMode: 'linear',\n\t            fill: 'freeze'\n\t        };\n\n\t        if (isReversed) {\n\t            animationAttributes.keyPoints = '1;0';\n\t            animationAttributes.keyTimes = '0;1';\n\t        }\n\n\t        var vToken = V(token);\n\t        var connection;\n\t        if (typeof selector === 'string') {\n\t            // Use custom connection path.\n\t            connection = this.findBySelector(selector, this.el, this.selectors)[0];\n\t        } else {\n\t            // Select connection path automatically.\n\t            var cache = this._V;\n\t            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n\t        }\n\n\t        if (!(connection instanceof SVGPathElement)) {\n\t            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n\t        }\n\n\t        vToken\n\t            .appendTo(this.paper.cells)\n\t            .animateAlongPath(animationAttributes, connection);\n\n\t        setTimeout(onAnimationEnd(vToken, callback), duration);\n\t    },\n\n\t    findRoute: function(vertices) {\n\n\t        vertices || (vertices = []);\n\n\t        var namespace = routers;\n\t        var router = this.model.router();\n\t        var defaultRouter = this.paper.options.defaultRouter;\n\n\t        if (!router) {\n\t            if (defaultRouter) { router = defaultRouter; }\n\t            else { return vertices.map(Point); } // no router specified\n\t        }\n\n\t        var routerFn = isFunction(router) ? router : namespace[router.name];\n\t        if (!isFunction(routerFn)) {\n\t            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n\t        }\n\n\t        var args = router.args || {};\n\n\t        var route = routerFn.call(\n\t            this, // context\n\t            vertices, // vertices\n\t            args, // options\n\t            this // linkView\n\t        );\n\n\t        if (!route) { return vertices.map(Point); }\n\t        return route;\n\t    },\n\n\t    // Return the `d` attribute value of the `<path>` element representing the link\n\t    // between `source` and `target`.\n\t    findPath: function(route, sourcePoint, targetPoint) {\n\n\t        var namespace = connectors;\n\t        var connector = this.model.connector();\n\t        var defaultConnector = this.paper.options.defaultConnector;\n\n\t        if (!connector) {\n\t            connector = defaultConnector || {};\n\t        }\n\n\t        var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n\t        if (!isFunction(connectorFn)) {\n\t            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n\t        }\n\n\t        var args = clone(connector.args || {});\n\t        args.raw = true; // Request raw g.Path as the result.\n\n\t        var path = connectorFn.call(\n\t            this, // context\n\t            sourcePoint, // start point\n\t            targetPoint, // end point\n\t            route, // vertices\n\t            args, // options\n\t            this // linkView\n\t        );\n\n\t        if (typeof path === 'string') {\n\t            // Backwards compatibility for connectors not supporting `raw` option.\n\t            path = new Path(V.normalizePathData(path));\n\t        }\n\n\t        return path;\n\t    },\n\n\t    // Public API.\n\t    // -----------\n\n\t    getConnection: function() {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.clone();\n\t    },\n\n\t    getSerializedConnection: function() {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        var metrics = this.metrics;\n\t        if (metrics.hasOwnProperty('data')) { return metrics.data; }\n\t        var data = path.serialize();\n\t        metrics.data = data;\n\t        return data;\n\t    },\n\n\t    getConnectionSubdivisions: function() {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        var metrics = this.metrics;\n\t        if (metrics.hasOwnProperty('segmentSubdivisions')) { return metrics.segmentSubdivisions; }\n\t        var subdivisions = path.getSegmentSubdivisions();\n\t        metrics.segmentSubdivisions = subdivisions;\n\t        return subdivisions;\n\t    },\n\n\t    getConnectionLength: function() {\n\n\t        var path = this.path;\n\t        if (!path) { return 0; }\n\n\t        var metrics = this.metrics;\n\t        if (metrics.hasOwnProperty('length')) { return metrics.length; }\n\t        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n\t        metrics.length = length;\n\t        return length;\n\t    },\n\n\t    getPointAtLength: function(length) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getPointAtRatio: function(ratio) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\t        if (isPercentage(ratio)) { ratio = parseFloat(ratio) / 100; }\n\t        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getTangentAtLength: function(length) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getTangentAtRatio: function(ratio) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getClosestPoint: function(point) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getClosestPointLength: function(point) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    getClosestPointRatio: function(point) {\n\n\t        var path = this.path;\n\t        if (!path) { return null; }\n\n\t        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n\t    },\n\n\t    // Get label position object based on two provided coordinates, x and y.\n\t    // (Used behind the scenes when user moves labels around.)\n\t    // Two signatures:\n\t    // - num, num, obj = x, y, options\n\t    // - num, num, num, obj = x, y, angle, options\n\t    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n\t    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n\t    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n\t    getLabelPosition: function(x, y, p3, p4) {\n\n\t        var position = {};\n\n\t        // normalize data from the two possible signatures\n\t        var localAngle = 0;\n\t        var localOpt;\n\t        if (typeof p3 === 'number') {\n\t            // angle and opt provided as third and fourth argument\n\t            localAngle = p3;\n\t            localOpt = p4;\n\t        } else {\n\t            // opt provided as third argument\n\t            localOpt = p3;\n\t        }\n\n\t        // save localOpt as `args` of the position object that is passed along\n\t        if (localOpt) { position.args = localOpt; }\n\n\t        // identify distance/offset settings\n\t        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n\t        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n\t        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n\t        // find closest point t\n\t        var path = this.path;\n\t        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\t        var labelPoint = new Point(x, y);\n\t        var t = path.closestPointT(labelPoint, pathOpt);\n\n\t        // DISTANCE:\n\t        var labelDistance = path.lengthAtT(t, pathOpt);\n\t        if (isDistanceRelative) { labelDistance = (labelDistance / this.getConnectionLength()) || 0; } // fix to prevent NaN for 0 length\n\t        if (isDistanceAbsoluteReverse) { labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; } // fix for end point (-0 => 1)\n\t        position.distance = labelDistance;\n\n\t        // OFFSET:\n\t        // use absolute offset if:\n\t        // - opt.absoluteOffset is true,\n\t        // - opt.absoluteOffset is not true but there is no tangent\n\t        var tangent;\n\t        if (!isOffsetAbsolute) { tangent = path.tangentAtT(t); }\n\t        var labelOffset;\n\t        if (tangent) {\n\t            labelOffset = tangent.pointOffset(labelPoint);\n\t        } else {\n\t            var closestPoint = path.pointAtT(t);\n\t            var labelOffsetDiff = labelPoint.difference(closestPoint);\n\t            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n\t        }\n\t        position.offset = labelOffset;\n\n\t        // ANGLE:\n\t        position.angle = localAngle;\n\n\t        return position;\n\t    },\n\n\t    _getLabelTransformationMatrix: function(labelPosition) {\n\n\t        var labelDistance;\n\t        var labelAngle = 0;\n\t        var args = {};\n\t        if (typeof labelPosition === 'number') {\n\t            labelDistance = labelPosition;\n\t        } else if (typeof labelPosition.distance === 'number') {\n\t            args = labelPosition.args || {};\n\t            labelDistance = labelPosition.distance;\n\t            labelAngle = labelPosition.angle || 0;\n\t        } else {\n\t            throw new Error('dia.LinkView: invalid label position distance.');\n\t        }\n\n\t        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n\t        var labelOffset = 0;\n\t        var labelOffsetCoordinates = { x: 0, y: 0 };\n\t        if (labelPosition.offset) {\n\t            var positionOffset = labelPosition.offset;\n\t            if (typeof positionOffset === 'number') { labelOffset = positionOffset; }\n\t            if (positionOffset.x) { labelOffsetCoordinates.x = positionOffset.x; }\n\t            if (positionOffset.y) { labelOffsetCoordinates.y = positionOffset.y; }\n\t        }\n\n\t        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n\t        var isKeepGradient = args.keepGradient;\n\t        var isEnsureLegibility = args.ensureLegibility;\n\n\t        var path = this.path;\n\t        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n\t        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n\t        var tangent = path.tangentAtLength(distance, pathOpt);\n\n\t        var translation;\n\t        var angle = labelAngle;\n\t        if (tangent) {\n\t            if (isOffsetAbsolute) {\n\t                translation = tangent.start;\n\t                translation.offset(labelOffsetCoordinates);\n\t            } else {\n\t                var normal = tangent.clone();\n\t                normal.rotate(tangent.start, -90);\n\t                normal.setLength(labelOffset);\n\t                translation = normal.end;\n\t            }\n\t            if (isKeepGradient) {\n\t                angle = (tangent.angle() + labelAngle);\n\t                if (isEnsureLegibility) {\n\t                    angle = normalizeAngle(((angle + 90) % 180) - 90);\n\t                }\n\t            }\n\t        } else {\n\t            // fallback - the connection has zero length\n\t            translation = path.start;\n\t            if (isOffsetAbsolute) { translation.offset(labelOffsetCoordinates); }\n\t        }\n\n\t        return V.createSVGMatrix()\n\t            .translate(translation.x, translation.y)\n\t            .rotate(angle);\n\t    },\n\n\t    getLabelCoordinates: function(labelPosition) {\n\n\t        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n\t        return new Point(transformationMatrix.e, transformationMatrix.f);\n\t    },\n\n\t    getVertexIndex: function(x, y) {\n\n\t        var model = this.model;\n\t        var vertices = model.vertices();\n\n\t        var vertexLength = this.getClosestPointLength(new Point(x, y));\n\n\t        var idx = 0;\n\t        for (var n = vertices.length; idx < n; idx++) {\n\t            var currentVertex = vertices[idx];\n\t            var currentVertexLength = this.getClosestPointLength(currentVertex);\n\t            if (vertexLength < currentVertexLength) { break; }\n\t        }\n\n\t        return idx;\n\t    },\n\n\t    // Interaction. The controller part.\n\t    // ---------------------------------\n\n\t    notifyPointerdown: function notifyPointerdown(evt, x, y) {\n\t        CellView.prototype.pointerdown.call(this, evt, x, y);\n\t        this.notify('link:pointerdown', evt, x, y);\n\t    },\n\n\t    notifyPointermove: function notifyPointermove(evt, x, y) {\n\t        CellView.prototype.pointermove.call(this, evt, x, y);\n\t        this.notify('link:pointermove', evt, x, y);\n\t    },\n\n\t    notifyPointerup: function notifyPointerup(evt, x, y) {\n\t        this.notify('link:pointerup', evt, x, y);\n\t        CellView.prototype.pointerup.call(this, evt, x, y);\n\t    },\n\n\t    pointerdblclick: function(evt, x, y) {\n\n\t        CellView.prototype.pointerdblclick.apply(this, arguments);\n\t        this.notify('link:pointerdblclick', evt, x, y);\n\t    },\n\n\t    pointerclick: function(evt, x, y) {\n\n\t        CellView.prototype.pointerclick.apply(this, arguments);\n\t        this.notify('link:pointerclick', evt, x, y);\n\t    },\n\n\t    contextmenu: function(evt, x, y) {\n\n\t        CellView.prototype.contextmenu.apply(this, arguments);\n\t        this.notify('link:contextmenu', evt, x, y);\n\t    },\n\n\t    pointerdown: function(evt, x, y) {\n\n\t        this.notifyPointerdown(evt, x, y);\n\n\t        // Backwards compatibility for the default markup\n\t        var className = evt.target.getAttribute('class');\n\t        switch (className) {\n\n\t            case 'marker-vertex':\n\t                this.dragVertexStart(evt, x, y);\n\t                return;\n\n\t            case 'marker-vertex-remove':\n\t            case 'marker-vertex-remove-area':\n\t                this.dragVertexRemoveStart(evt, x, y);\n\t                return;\n\n\t            case 'marker-arrowhead':\n\t                this.dragArrowheadStart(evt, x, y);\n\t                return;\n\n\t            case 'connection':\n\t            case 'connection-wrap':\n\t                this.dragConnectionStart(evt, x, y);\n\t                return;\n\n\t            case 'marker-source':\n\t            case 'marker-target':\n\t                return;\n\t        }\n\n\t        this.dragStart(evt, x, y);\n\t    },\n\n\t    pointermove: function(evt, x, y) {\n\n\t        // Backwards compatibility\n\t        var dragData = this._dragData;\n\t        if (dragData) { this.eventData(evt, dragData); }\n\n\t        var data = this.eventData(evt);\n\t        switch (data.action) {\n\n\t            case 'vertex-move':\n\t                this.dragVertex(evt, x, y);\n\t                break;\n\n\t            case 'label-move':\n\t                this.dragLabel(evt, x, y);\n\t                break;\n\n\t            case 'arrowhead-move':\n\t                this.dragArrowhead(evt, x, y);\n\t                break;\n\n\t            case 'move':\n\t                this.drag(evt, x, y);\n\t                break;\n\t        }\n\n\t        // Backwards compatibility\n\t        if (dragData) { assign(dragData, this.eventData(evt)); }\n\n\t        this.notifyPointermove(evt, x, y);\n\t    },\n\n\t    pointerup: function(evt, x, y) {\n\n\t        // Backwards compatibility\n\t        var dragData = this._dragData;\n\t        if (dragData) {\n\t            this.eventData(evt, dragData);\n\t            this._dragData = null;\n\t        }\n\n\t        var data = this.eventData(evt);\n\t        switch (data.action) {\n\n\t            case 'vertex-move':\n\t                this.dragVertexEnd(evt, x, y);\n\t                break;\n\n\t            case 'label-move':\n\t                this.dragLabelEnd(evt, x, y);\n\t                break;\n\n\t            case 'arrowhead-move':\n\t                this.dragArrowheadEnd(evt, x, y);\n\t                break;\n\n\t            case 'move':\n\t                this.dragEnd(evt, x, y);\n\t        }\n\n\t        this.notifyPointerup(evt, x, y);\n\t        this.checkMouseleave(evt);\n\t    },\n\n\t    mouseover: function(evt) {\n\n\t        CellView.prototype.mouseover.apply(this, arguments);\n\t        this.notify('link:mouseover', evt);\n\t    },\n\n\t    mouseout: function(evt) {\n\n\t        CellView.prototype.mouseout.apply(this, arguments);\n\t        this.notify('link:mouseout', evt);\n\t    },\n\n\t    mouseenter: function(evt) {\n\n\t        CellView.prototype.mouseenter.apply(this, arguments);\n\t        this.notify('link:mouseenter', evt);\n\t    },\n\n\t    mouseleave: function(evt) {\n\n\t        CellView.prototype.mouseleave.apply(this, arguments);\n\t        this.notify('link:mouseleave', evt);\n\t    },\n\n\t    mousewheel: function(evt, x, y, delta) {\n\n\t        CellView.prototype.mousewheel.apply(this, arguments);\n\t        this.notify('link:mousewheel', evt, x, y, delta);\n\t    },\n\n\t    onevent: function(evt, eventName, x, y) {\n\n\t        // Backwards compatibility\n\t        var linkTool = V(evt.target).findParentByClass('link-tool', this.el);\n\t        if (linkTool) {\n\t            // No further action to be executed\n\t            evt.stopPropagation();\n\n\t            // Allow `interactive.useLinkTools=false`\n\t            if (this.can('useLinkTools')) {\n\t                if (eventName === 'remove') {\n\t                    // Built-in remove event\n\t                    this.model.remove({ ui: true });\n\t                    // Do not trigger link pointerdown\n\t                    return;\n\n\t                } else {\n\t                    // link:options and other custom events inside the link tools\n\t                    this.notify(eventName, evt, x, y);\n\t                }\n\t            }\n\n\t            this.notifyPointerdown(evt, x, y);\n\t            this.paper.delegateDragEvents(this, evt.data);\n\n\t        } else {\n\t            CellView.prototype.onevent.apply(this, arguments);\n\t        }\n\t    },\n\n\t    onlabel: function(evt, x, y) {\n\n\t        this.notifyPointerdown(evt, x, y);\n\n\t        this.dragLabelStart(evt, x, y);\n\n\t        var stopPropagation = this.eventData(evt).stopPropagation;\n\t        if (stopPropagation) { evt.stopPropagation(); }\n\t    },\n\n\t    // Drag Start Handlers\n\n\t    dragConnectionStart: function(evt, x, y) {\n\n\t        if (!this.can('vertexAdd')) { return; }\n\n\t        // Store the index at which the new vertex has just been placed.\n\t        // We'll be update the very same vertex position in `pointermove()`.\n\t        var vertexIdx = this.addVertex({ x: x, y: y }, { ui: true });\n\t        this.eventData(evt, {\n\t            action: 'vertex-move',\n\t            vertexIdx: vertexIdx\n\t        });\n\t    },\n\n\t    dragLabelStart: function(evt, _x, _y) {\n\n\t        if (this.can('labelMove')) {\n\n\t            var labelNode = evt.currentTarget;\n\t            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n\t            var positionAngle = this._getLabelPositionAngle(labelIdx);\n\t            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n\t            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\t            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n\t            this.eventData(evt, {\n\t                action: 'label-move',\n\t                labelIdx: labelIdx,\n\t                positionAngle: positionAngle,\n\t                positionArgs: positionArgs,\n\t                stopPropagation: true\n\t            });\n\n\t        } else {\n\n\t            // Backwards compatibility:\n\t            // If labels can't be dragged no default action is triggered.\n\t            this.eventData(evt, { stopPropagation: true });\n\t        }\n\n\t        this.paper.delegateDragEvents(this, evt.data);\n\t    },\n\n\t    dragVertexStart: function(evt, x, y) {\n\n\t        if (!this.can('vertexMove')) { return; }\n\n\t        var vertexNode = evt.target;\n\t        var vertexIdx = parseInt(vertexNode.getAttribute('idx'), 10);\n\t        this.eventData(evt, {\n\t            action: 'vertex-move',\n\t            vertexIdx: vertexIdx\n\t        });\n\t    },\n\n\t    dragVertexRemoveStart: function(evt, x, y) {\n\n\t        if (!this.can('vertexRemove')) { return; }\n\n\t        var removeNode = evt.target;\n\t        var vertexIdx = parseInt(removeNode.getAttribute('idx'), 10);\n\t        this.model.removeVertex(vertexIdx);\n\t    },\n\n\t    dragArrowheadStart: function(evt, x, y) {\n\n\t        if (!this.can('arrowheadMove')) { return; }\n\n\t        var arrowheadNode = evt.target;\n\t        var arrowheadType = arrowheadNode.getAttribute('end');\n\t        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n\t        this.eventData(evt, data);\n\t    },\n\n\t    dragStart: function(evt, x, y) {\n\n\t        if (!this.can('linkMove')) { return; }\n\n\t        this.eventData(evt, {\n\t            action: 'move',\n\t            dx: x,\n\t            dy: y\n\t        });\n\t    },\n\n\t    // Drag Handlers\n\t    dragLabel: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        var label = { position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs) };\n\t        if (this.paper.options.snapLabels) { delete label.position.offset; }\n\t        this.model.label(data.labelIdx, label);\n\t    },\n\n\t    dragVertex: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        this.model.vertex(data.vertexIdx, { x: x, y: y }, { ui: true });\n\t    },\n\n\t    dragArrowhead: function(evt, x, y) {\n\n\t        if (this.paper.options.snapLinks) {\n\n\t            this._snapArrowhead(evt, x, y);\n\n\t        } else {\n\n\t            this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n\t        }\n\t    },\n\n\t    drag: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n\t        this.eventData(evt, {\n\t            dx: x,\n\t            dy: y\n\t        });\n\t    },\n\n\t    // Drag End Handlers\n\n\t    dragLabelEnd: function() {\n\t        // noop\n\t    },\n\n\t    dragVertexEnd: function() {\n\t        // noop\n\t    },\n\n\t    dragArrowheadEnd: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        var paper = this.paper;\n\n\t        if (paper.options.snapLinks) {\n\t            this._snapArrowheadEnd(data);\n\t        } else {\n\t            this._connectArrowheadEnd(data, x, y);\n\t        }\n\n\t        if (!paper.linkAllowed(this)) {\n\t            // If the changed link is not allowed, revert to its previous state.\n\t            this._disallow(data);\n\t        } else {\n\t            this._finishEmbedding(data);\n\t            this._notifyConnectEvent(data, evt);\n\t        }\n\n\t        this._afterArrowheadMove(data);\n\t    },\n\n\t    dragEnd: function() {\n\t        // noop\n\t    },\n\n\t    _disallow: function(data) {\n\n\t        switch (data.whenNotAllowed) {\n\n\t            case 'remove':\n\t                this.model.remove({ ui: true });\n\t                break;\n\n\t            case 'revert':\n\t            default:\n\t                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n\t                break;\n\t        }\n\t    },\n\n\t    _finishEmbedding: function(data) {\n\n\t        // Reparent the link if embedding is enabled\n\t        if (this.paper.options.embeddingMode && this.model.reparent()) {\n\t            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n\t            data.z = null;\n\t        }\n\t    },\n\n\t    _notifyConnectEvent: function(data, evt) {\n\n\t        var arrowhead = data.arrowhead;\n\t        var initialEnd = data.initialEnd;\n\t        var currentEnd = this.model.prop(arrowhead);\n\t        var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n\t        if (endChanged) {\n\t            var paper = this.paper;\n\t            if (initialEnd.id) {\n\t                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n\t            }\n\t            if (currentEnd.id) {\n\t                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n\t            }\n\t        }\n\t    },\n\n\t    _snapArrowhead: function(evt, x, y) {\n\n\t        var data = this.eventData(evt);\n\t        // checking view in close area of the pointer\n\n\t        var r = this.paper.options.snapLinks.radius || 50;\n\t        var viewsInArea = this.paper.findViewsInArea({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });\n\n\t        var prevClosestView = data.closestView || null;\n\t        var prevClosestMagnet = data.closestMagnet || null;\n\t        var prevMagnetProxy = data.magnetProxy || null;\n\n\t        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n\t        var minDistance = Number.MAX_VALUE;\n\t        var pointer = new Point(x, y);\n\t        var paper = this.paper;\n\n\t        viewsInArea.forEach(function(view) {\n\t            var candidates = [];\n\t            // skip connecting to the element in case '.': { magnet: false } attribute present\n\t            if (view.el.getAttribute('magnet') !== 'false') {\n\t                candidates.push({\n\t                    bbox: view.model.getBBox(),\n\t                    magnet: view.el\n\t                });\n\t            }\n\n\t            view.$('[magnet]').toArray().forEach(function (magnet) {\n\t                candidates.push({\n\t                    bbox: view.getNodeBBox(magnet),\n\t                    magnet: magnet\n\t                });\n\t            });\n\n\t            candidates.forEach(function (candidate) {\n\t                var magnet = candidate.magnet;\n\t                var bbox = candidate.bbox;\n\t                // find distance from the center of the model to pointer coordinates\n\t                var distance = bbox.center().squaredDistance(pointer);\n\t                // the connection is looked up in a circle area by `distance < r`\n\t                if (distance < minDistance) {\n\t                    var isAlreadyValidated = prevClosestMagnet === magnet;\n\t                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n\t                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n\t                    )) {\n\t                        minDistance = distance;\n\t                        data.closestView = view;\n\t                        data.closestMagnet = magnet;\n\t                    }\n\t                }\n\t            });\n\n\t        }, this);\n\n\t        var end;\n\t        var magnetProxy = null;\n\t        var closestView = data.closestView;\n\t        var closestMagnet = data.closestMagnet;\n\t        if (closestMagnet) {\n\t            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n\t        }\n\t        var endType = data.arrowhead;\n\t        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n\t        if (prevClosestView && newClosestMagnet) {\n\t            prevClosestView.unhighlight(prevMagnetProxy, {\n\t                connecting: true,\n\t                snapping: true\n\t            });\n\t        }\n\n\t        if (closestView) {\n\n\t            if (!newClosestMagnet) { return; }\n\n\t            closestView.highlight(magnetProxy, {\n\t                connecting: true,\n\t                snapping: true\n\t            });\n\t            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n\n\t        } else {\n\n\t            end = { x: x, y: y };\n\t        }\n\n\t        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n\t        if (prevClosestView) {\n\t            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n\t        }\n\t        if (closestView) {\n\t            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n\t        }\n\t    },\n\n\t    _snapArrowheadEnd: function(data) {\n\n\t        // Finish off link snapping.\n\t        // Everything except view unhighlighting was already done on pointermove.\n\t        var closestView = data.closestView;\n\t        var closestMagnet = data.closestMagnet;\n\t        if (closestView && closestMagnet) {\n\n\t            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n\t            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n\t        }\n\n\t        data.closestView = data.closestMagnet = null;\n\t    },\n\n\t    _connectArrowhead: function(target, x, y, data) {\n\n\t        // checking views right under the pointer\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var model = ref.model;\n\n\t        if (data.eventTarget !== target) {\n\t            // Unhighlight the previous view under pointer if there was one.\n\t            if (data.magnetProxy) {\n\t                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n\t                    connecting: true\n\t                });\n\t            }\n\n\t            var viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n\t            if (viewUnderPointer) {\n\t                // If we found a view that is under the pointer, we need to find the closest\n\t                // magnet based on the real target element of the event.\n\t                var magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n\t                var magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n\t                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n\t                    paper,\n\t                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n\t                )) {\n\t                    // If there was no magnet found, do not highlight anything and assume there\n\t                    // is no view under pointer we're interested in reconnecting to.\n\t                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n\t                    if (magnetProxy) {\n\t                        viewUnderPointer.highlight(magnetProxy, {\n\t                            connecting: true\n\t                        });\n\t                    }\n\t                } else {\n\t                    // This type of connection is not valid. Disregard this magnet.\n\t                    data.magnetUnderPointer = null;\n\t                    data.magnetProxy = null;\n\t                }\n\t            } else {\n\t                // Make sure we'll unset previous magnet.\n\t                data.magnetUnderPointer = null;\n\t                data.magnetProxy = null;\n\t            }\n\t        }\n\n\t        data.eventTarget = target;\n\n\t        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n\t    },\n\n\t    _connectArrowheadEnd: function(data, x, y) {\n\t        if ( data === void 0 ) data = {};\n\n\n\t        var ref = this;\n\t        var model = ref.model;\n\t        var viewUnderPointer = data.viewUnderPointer;\n\t        var magnetUnderPointer = data.magnetUnderPointer;\n\t        var magnetProxy = data.magnetProxy;\n\t        var arrowhead = data.arrowhead;\n\n\t        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) { return; }\n\n\t        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n\t        // The link end is taken from the magnet under the pointer, not the proxy.\n\t        var end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n\t        model.set(arrowhead, end, { ui: true });\n\t    },\n\n\t    _beforeArrowheadMove: function(data) {\n\n\t        data.z = this.model.get('z');\n\t        this.model.toFront();\n\n\t        // Let the pointer propagate through the link view elements so that\n\t        // the `evt.target` is another element under the pointer, not the link itself.\n\t        var style = this.el.style;\n\t        data.pointerEvents = style.pointerEvents;\n\t        style.pointerEvents = 'none';\n\n\t        if (this.paper.options.markAvailable) {\n\t            this._markAvailableMagnets(data);\n\t        }\n\t    },\n\n\t    _afterArrowheadMove: function(data) {\n\n\t        if (data.z !== null) {\n\t            this.model.set('z', data.z, { ui: true });\n\t            data.z = null;\n\t        }\n\n\t        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n\t        this.el.style.pointerEvents = data.pointerEvents;\n\n\t        if (this.paper.options.markAvailable) {\n\t            this._unmarkAvailableMagnets(data);\n\t        }\n\t    },\n\n\t    _createValidateConnectionArgs: function(arrowhead) {\n\t        // It makes sure the arguments for validateConnection have the following form:\n\t        // (source view, source magnet, target view, target magnet and link view)\n\t        var args = [];\n\n\t        args[4] = arrowhead;\n\t        args[5] = this;\n\n\t        var oppositeArrowhead;\n\t        var i = 0;\n\t        var j = 0;\n\n\t        if (arrowhead === 'source') {\n\t            i = 2;\n\t            oppositeArrowhead = 'target';\n\t        } else {\n\t            j = 2;\n\t            oppositeArrowhead = 'source';\n\t        }\n\n\t        var end = this.model.get(oppositeArrowhead);\n\n\t        if (end.id) {\n\t            var view = args[i] = this.paper.findViewByModel(end.id);\n\t            var magnet = view.getMagnetFromLinkEnd(end);\n\t            if (magnet === view.el) { magnet = undefined; }\n\t            args[i + 1] = magnet;\n\t        }\n\n\t        function validateConnectionArgs(cellView, magnet) {\n\t            args[j] = cellView;\n\t            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n\t            return args;\n\t        }\n\n\t        return validateConnectionArgs;\n\t    },\n\n\t    _markAvailableMagnets: function(data) {\n\n\t        function isMagnetAvailable(view, magnet) {\n\t            var paper = view.paper;\n\t            var validate = paper.options.validateConnection;\n\t            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n\t        }\n\n\t        var paper = this.paper;\n\t        var elements = paper.model.getCells();\n\t        data.marked = {};\n\n\t        for (var i = 0, n = elements.length; i < n; i++) {\n\t            var view = elements[i].findView(paper);\n\n\t            if (!view) {\n\t                continue;\n\t            }\n\n\t            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n\t            if (view.el.getAttribute('magnet') !== 'false') {\n\t                // Element wrapping group is also a magnet\n\t                magnets.push(view.el);\n\t            }\n\n\t            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n\t            if (availableMagnets.length > 0) {\n\t                // highlight all available magnets\n\t                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n\t                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n\t                }\n\t                // highlight the entire view\n\t                view.highlight(null, { elementAvailability: true });\n\n\t                data.marked[view.model.id] = availableMagnets;\n\t            }\n\t        }\n\t    },\n\n\t    _unmarkAvailableMagnets: function(data) {\n\n\t        var markedKeys = Object.keys(data.marked);\n\t        var id;\n\t        var markedMagnets;\n\n\t        for (var i = 0, n = markedKeys.length; i < n; i++) {\n\t            id = markedKeys[i];\n\t            markedMagnets = data.marked[id];\n\n\t            var view = this.paper.findViewByModel(id);\n\t            if (view) {\n\t                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n\t                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n\t                }\n\t                view.unhighlight(null, { elementAvailability: true });\n\t            }\n\t        }\n\n\t        data.marked = null;\n\t    },\n\n\t    startArrowheadMove: function(end, opt) {\n\n\t        opt || (opt = {});\n\n\t        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n\t        // move without need to click on the actual arrowhead dom element.\n\t        var data = {\n\t            action: 'arrowhead-move',\n\t            arrowhead: end,\n\t            whenNotAllowed: opt.whenNotAllowed || 'revert',\n\t            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n\t            initialEnd: clone(this.model.get(end)),\n\t            validateConnectionArgs: this._createValidateConnectionArgs(end)\n\t        };\n\n\t        this._beforeArrowheadMove(data);\n\n\t        if (opt.ignoreBackwardsCompatibility !== true) {\n\t            this._dragData = data;\n\t        }\n\n\t        return data;\n\t    }\n\t});\n\n\tObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n\t    enumerable: true,\n\n\t    get: function() {\n\t        var sourceView = this.sourceView;\n\t        if (!sourceView) {\n\t            var sourceDef = this.model.source();\n\t            return new Rect(sourceDef.x, sourceDef.y);\n\t        }\n\t        var sourceMagnet = this.sourceMagnet;\n\t        if (sourceView.isNodeConnection(sourceMagnet)) {\n\t            return new Rect(this.sourceAnchor);\n\t        }\n\t        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n\t    }\n\n\t});\n\n\tObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n\t    enumerable: true,\n\n\t    get: function() {\n\t        var targetView = this.targetView;\n\t        if (!targetView) {\n\t            var targetDef = this.model.target();\n\t            return new Rect(targetDef.x, targetDef.y);\n\t        }\n\t        var targetMagnet = this.targetMagnet;\n\t        if (targetView.isNodeConnection(targetMagnet)) {\n\t            return new Rect(this.targetAnchor);\n\t        }\n\t        return targetView.getNodeBBox(targetMagnet || targetView.el);\n\t    }\n\t});\n\n\tvar stroke = HighlighterView.extend({\n\n\t    tagName: 'path',\n\t    className: 'highlight-stroke',\n\t    attributes: {\n\t        'pointer-events': 'none',\n\t        'vector-effect': 'non-scaling-stroke',\n\t        'fill': 'none'\n\t    },\n\n\t    options: {\n\t        padding: 3,\n\t        rx: 0,\n\t        ry: 0,\n\t        useFirstSubpath: false,\n\t        attrs: {\n\t            'stroke-width': 3,\n\t            'stroke': '#FEB663'\n\t        }\n\t    },\n\n\t    getPathData: function getPathData(cellView, node) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var useFirstSubpath = options.useFirstSubpath;\n\t        var d;\n\t        try {\n\t            var vNode = V(node);\n\t            d = vNode.convertToPathData().trim();\n\t            if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n\t                var secondSubpathIndex = d.search(/.M/i) + 1;\n\t                if (secondSubpathIndex > 0) {\n\t                    d = d.substr(0, secondSubpathIndex);\n\t                }\n\t            }\n\t        } catch (error) {\n\t            // Failed to get path data from magnet element.\n\t            // Draw a rectangle around the node instead.\n\t            var nodeBBox = cellView.getNodeBoundingRect(node);\n\t            d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n\t        }\n\t        return d;\n\t    },\n\n\t    highlightConnection: function highlightConnection(cellView) {\n\t        this.vel.attr('d', cellView.getSerializedConnection());\n\t    },\n\n\t    highlightNode: function highlightNode(cellView, node) {\n\t        var ref = this;\n\t        var vel = ref.vel;\n\t        var options = ref.options;\n\t        var padding = options.padding;\n\t        var layer = options.layer;\n\t        var highlightMatrix = cellView.getNodeMatrix(node);\n\t        // Add padding to the highlight element.\n\t        if (padding) {\n\t            if (!layer && node === cellView.el) {\n\t                // If the highlighter is appended to the cellView\n\t                // and we measure the size of the cellView wrapping group\n\t                // it's necessary to remove the highlighter first\n\t                vel.remove();\n\t            }\n\t            var nodeBBox = cellView.getNodeBoundingRect(node);\n\t            var cx = nodeBBox.x + (nodeBBox.width / 2);\n\t            var cy = nodeBBox.y + (nodeBBox.height / 2);\n\t            nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n\t            var width = Math.max(nodeBBox.width, 1);\n\t            var height = Math.max(nodeBBox.height, 1);\n\t            var sx = (width + padding) / width;\n\t            var sy = (height + padding) / height;\n\t            var paddingMatrix = V.createSVGMatrix({\n\t                a: sx,\n\t                b: 0,\n\t                c: 0,\n\t                d: sy,\n\t                e: cx - sx * cx,\n\t                f: cy - sy * cy\n\t            });\n\t            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n\t        }\n\t        vel.attr({\n\t            'd': this.getPathData(cellView, node),\n\t            'transform': V.matrixToTransformString(highlightMatrix)\n\t        });\n\t    },\n\n\t    highlight: function highlight(cellView, node) {\n\t        var ref = this;\n\t        var vel = ref.vel;\n\t        var options = ref.options;\n\t        vel.attr(options.attrs);\n\t        if (cellView.isNodeConnection(node)) {\n\t            this.highlightConnection(cellView);\n\t        } else {\n\t            this.highlightNode(cellView, node);\n\t        }\n\t    }\n\n\t});\n\n\tvar MASK_CLIP = 20;\n\n\tfunction forEachDescendant(vel, fn) {\n\t    var descendants = vel.children();\n\t    while (descendants.length > 0) {\n\t        var descendant = descendants.shift();\n\t        if (fn(descendant)) {\n\t            descendants.push.apply(descendants, descendant.children());\n\t        }\n\t    }\n\t}\n\n\tvar mask = HighlighterView.extend({\n\n\t    tagName: 'rect',\n\t    className: 'highlight-mask',\n\t    attributes: {\n\t        'pointer-events': 'none'\n\t    },\n\n\t    options: {\n\t        padding: 3,\n\t        maskClip: MASK_CLIP,\n\t        deep: false,\n\t        attrs: {\n\t            'stroke': '#FEB663',\n\t            'stroke-width': 3,\n\t            'stroke-linecap': 'butt',\n\t            'stroke-linejoin': 'miter',\n\t        }\n\t    },\n\n\t    VISIBLE: 'white',\n\t    INVISIBLE: 'black',\n\n\t    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n\t        'marker-start',\n\t        'marker-end',\n\t        'marker-mid',\n\t        'transform',\n\t        'stroke-dasharray'\n\t    ],\n\n\t    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n\t        'stroke',\n\t        'fill',\n\t        'stroke-width',\n\t        'stroke-opacity',\n\t        'stroke-dasharray',\n\t        'fill-opacity',\n\t        'marker-start',\n\t        'marker-end',\n\t        'marker-mid'\n\t    ],\n\n\t    // TODO: change the list to a function callback\n\t    MASK_REPLACE_TAGS: [\n\t        'FOREIGNOBJECT',\n\t        'IMAGE',\n\t        'USE',\n\t        'TEXT',\n\t        'TSPAN',\n\t        'TEXTPATH'\n\t    ],\n\n\t    // TODO: change the list to a function callback\n\t    MASK_REMOVE_TAGS: [\n\t        'TEXT',\n\t        'TSPAN',\n\t        'TEXTPATH'\n\t    ],\n\n\t    transformMaskChild: function transformMaskChild(cellView, childEl) {\n\t        var ref = this;\n\t        var MASK_CHILD_ATTRIBUTE_BLACKLIST = ref.MASK_CHILD_ATTRIBUTE_BLACKLIST;\n\t        var MASK_REPLACE_TAGS = ref.MASK_REPLACE_TAGS;\n\t        var MASK_REMOVE_TAGS = ref.MASK_REMOVE_TAGS;\n\t        var childTagName = childEl.tagName();\n\t        // Do not include the element in the mask's image\n\t        if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n\t            childEl.remove();\n\t            return false;\n\t        }\n\t        // Replace the element with a rectangle\n\t        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n\t            // Note: clone() method does not change the children ids\n\t            var originalChild = cellView.vel.findOne((\"#\" + (childEl.id)));\n\t            if (originalChild) {\n\t                var originalNode = originalChild.node;\n\t                var childBBox = cellView.getNodeBoundingRect(originalNode);\n\t                if (cellView.model.isElement()) {\n\t                    childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n\t                }\n\t                var replacement = V('rect', childBBox.toJSON());\n\t                var ref$1 = childBBox.center();\n\t                var ox = ref$1.x;\n\t                var oy = ref$1.y;\n\t                var ref$2 = originalChild.rotate();\n\t                var angle = ref$2.angle;\n\t                var cx = ref$2.cx; if ( cx === void 0 ) cx = ox;\n\t                var cy = ref$2.cy; if ( cy === void 0 ) cy = oy;\n\t                if (angle) { replacement.rotate(angle, cx, cy); }\n\t                // Note: it's not important to keep the same sibling index since all subnodes are filled\n\t                childEl.parent().append(replacement);\n\t            }\n\t            childEl.remove();\n\t            return false;\n\t        }\n\t        // Keep the element, but clean it from certain attributes\n\t        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(function (attrName) {\n\t            if (attrName === 'fill' && childEl.attr('fill') === 'none') { return; }\n\t            childEl.removeAttr(attrName);\n\t        });\n\t        return true;\n\t    },\n\n\t    transformMaskRoot: function transformMaskRoot(_cellView, rootEl) {\n\t        var ref = this;\n\t        var MASK_ROOT_ATTRIBUTE_BLACKLIST = ref.MASK_ROOT_ATTRIBUTE_BLACKLIST;\n\t        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(function (attrName) {\n\t            rootEl.removeAttr(attrName);\n\t        });\n\t    },\n\n\t    getMaskShape: function getMaskShape(cellView, vel) {\n\t        var this$1 = this;\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var MASK_REPLACE_TAGS = ref.MASK_REPLACE_TAGS;\n\t        var deep = options.deep;\n\t        var tagName = vel.tagName();\n\t        var maskRoot;\n\t        if (tagName === 'G') {\n\t            if (!deep) { return null; }\n\t            maskRoot = vel.clone();\n\t            forEachDescendant(maskRoot, function (maskChild) { return this$1.transformMaskChild(cellView, maskChild); });\n\t        } else {\n\t            if (MASK_REPLACE_TAGS.includes(tagName)) { return null; }\n\t            maskRoot = vel.clone();\n\t        }\n\t        this.transformMaskRoot(cellView, maskRoot);\n\t        return maskRoot;\n\t    },\n\n\t    getMaskId: function getMaskId() {\n\t        return (\"highlight-mask-\" + (this.cid));\n\t    },\n\n\t    getMask: function getMask(cellView, vNode) {\n\n\t        var ref = this;\n\t        var VISIBLE = ref.VISIBLE;\n\t        var INVISIBLE = ref.INVISIBLE;\n\t        var options = ref.options;\n\t        var padding = options.padding;\n\t        var attrs = options.attrs;\n\n\t        var strokeWidth = ('stroke-width' in attrs) ? attrs['stroke-width'] : 1;\n\t        var hasNodeFill = vNode.attr('fill') !== 'none';\n\t        var magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n\t        if (isNaN(magnetStrokeWidth)) { magnetStrokeWidth = 1; }\n\t        // stroke of the invisible shape\n\t        var minStrokeWidth = magnetStrokeWidth + padding * 2;\n\t        // stroke of the visible shape\n\t        var maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n\t        var maskEl = this.getMaskShape(cellView, vNode);\n\t        if (!maskEl) {\n\t            var nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n\t            // Make sure the rect is visible\n\t            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n\t            maskEl =  V('rect', nodeBBox.toJSON());\n\t        }\n\t        maskEl.attr(attrs);\n\t        return V('mask', {\n\t            'id': this.getMaskId()\n\t        }).append([\n\t            maskEl.clone().attr({\n\t                'fill': hasNodeFill ? VISIBLE : 'none',\n\t                'stroke': VISIBLE,\n\t                'stroke-width': maxStrokeWidth\n\t            }),\n\t            maskEl.clone().attr({\n\t                'fill': hasNodeFill ? INVISIBLE : 'none',\n\t                'stroke': INVISIBLE,\n\t                'stroke-width': minStrokeWidth\n\t            })\n\t        ]);\n\t    },\n\n\t    removeMask: function removeMask(paper) {\n\t        var maskNode = paper.svg.getElementById(this.getMaskId());\n\t        if (maskNode) {\n\t            paper.defs.removeChild(maskNode);\n\t        }\n\t    },\n\n\t    addMask: function addMask(paper, maskEl) {\n\t        paper.defs.appendChild(maskEl.node);\n\t    },\n\n\t    highlight: function highlight(cellView, node) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var vel = ref.vel;\n\t        var padding = options.padding;\n\t        var attrs = options.attrs;\n\t        var maskClip = options.maskClip; if ( maskClip === void 0 ) maskClip = MASK_CLIP;\n\t        var layer = options.layer;\n\t        var color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n\t        if (!layer && node === cellView.el) {\n\t            // If the highlighter is appended to the cellView\n\t            // and we measure the size of the cellView wrapping group\n\t            // it's necessary to remove the highlighter first\n\t            vel.remove();\n\t        }\n\t        var highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n\t        var maskEl = this.getMask(cellView, V(node));\n\t        this.addMask(cellView.paper, maskEl);\n\t        vel.attr(highlighterBBox.toJSON());\n\t        vel.attr({\n\t            'transform': V.matrixToTransformString(cellView.getNodeMatrix(node)),\n\t            'mask': (\"url(#\" + (maskEl.id) + \")\"),\n\t            'fill': color\n\t        });\n\t    },\n\n\t    unhighlight: function unhighlight(cellView) {\n\t        this.removeMask(cellView.paper);\n\t    }\n\n\t});\n\n\tvar opacity = HighlighterView.extend({\n\n\t    UPDATABLE: false,\n\t    MOUNTABLE: false,\n\n\t    opacityClassName: addClassNamePrefix('highlight-opacity'),\n\n\t    highlight: function(_cellView, node) {\n\t        V(node).addClass(this.opacityClassName);\n\t    },\n\n\t    unhighlight: function(_cellView, node) {\n\t        V(node).removeClass(this.opacityClassName);\n\t    }\n\n\t});\n\n\tvar className = addClassNamePrefix('highlighted');\n\n\tvar addClass = HighlighterView.extend({\n\n\t    UPDATABLE: false,\n\t    MOUNTABLE: false,\n\n\t    options: {\n\t        className: className\n\t    },\n\n\t    highlight: function(_cellView, node) {\n\t        V(node).addClass(this.options.className);\n\t    },\n\n\t    unhighlight: function(_cellView, node) {\n\t        V(node).removeClass(this.options.className);\n\t    }\n\n\t}, {\n\t    // Backwards Compatibility\n\t    className: className\n\t});\n\n\n\n\tvar highlighters = ({\n\t\tstroke: stroke,\n\t\tmask: mask,\n\t\topacity: opacity,\n\t\taddClass: addClass\n\t});\n\n\tfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\n\t    var ratio = ('ratio' in opt) ? opt.ratio : 0.5;\n\t    return view.getPointAtRatio(ratio);\n\t}\n\n\tfunction connectionLength(view, _magnet, _refPoint, opt) {\n\n\t    var length = ('length' in opt) ? opt.length : 20;\n\t    return view.getPointAtLength(length);\n\t}\n\n\tfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\n\t    var OFFSET = 1e6;\n\t    var path = view.getConnection();\n\t    var segmentSubdivisions = view.getConnectionSubdivisions();\n\t    var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n\t    var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n\t    var verticalIntersections = verticalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n\t    var horizontalIntersections = horizontalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n\t    var intersections = [];\n\t    if (verticalIntersections) { Array.prototype.push.apply(intersections, verticalIntersections); }\n\t    if (horizontalIntersections) { Array.prototype.push.apply(intersections, horizontalIntersections); }\n\t    if (intersections.length > 0) { return refPoint.chooseClosest(intersections); }\n\t    if ('fallbackAt' in opt) {\n\t        return getPointAtLink(view, opt.fallbackAt);\n\t    }\n\t    return connectionClosest(view, _magnet, refPoint, opt);\n\t}\n\n\tfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\n\t    var closestPoint = view.getClosestPoint(refPoint);\n\t    if (!closestPoint) { return new Point(); }\n\t    return closestPoint;\n\t}\n\n\tfunction resolveRef(fn) {\n\t    return function(view, magnet, ref, opt) {\n\t        if (ref instanceof Element) {\n\t            var refView = this.paper.findView(ref);\n\t            var refPoint;\n\t            if (refView) {\n\t                if (refView.isNodeConnection(ref)) {\n\t                    var distance = ('fixedAt' in opt) ? opt.fixedAt : '50%';\n\t                    refPoint = getPointAtLink(refView, distance);\n\t                } else {\n\t                    refPoint = refView.getNodeBBox(ref).center();\n\t                }\n\t            } else {\n\t                // Something went wrong\n\t                refPoint = new Point();\n\t            }\n\t            return fn.call(this, view, magnet, refPoint, opt);\n\t        }\n\t        return fn.apply(this, arguments);\n\t    };\n\t}\n\n\tfunction getPointAtLink(view, value) {\n\t    var parsedValue = parseFloat(value);\n\t    if (isPercentage(value)) {\n\t        return view.getPointAtRatio(parsedValue / 100);\n\t    } else {\n\t        return view.getPointAtLength(parsedValue);\n\t    }\n\t}\n\tvar connectionPerpendicular = resolveRef(_connectionPerpendicular);\n\tvar connectionClosest = resolveRef(_connectionClosest);\n\n\tvar linkAnchors = ({\n\t\tresolveRef: resolveRef,\n\t\tconnectionRatio: connectionRatio,\n\t\tconnectionLength: connectionLength,\n\t\tconnectionPerpendicular: connectionPerpendicular,\n\t\tconnectionClosest: connectionClosest\n\t});\n\n\tfunction offsetPoint(p1, p2, offset) {\n\t    if (isPlainObject(offset)) {\n\t        var x = offset.x;\n\t        var y = offset.y;\n\t        if (isFinite(y)) {\n\t            var line =  new Line(p2, p1);\n\t            var ref = line.parallel(y);\n\t            var start = ref.start;\n\t            var end = ref.end;\n\t            p2 = start;\n\t            p1 = end;\n\t        }\n\t        offset = x;\n\t    }\n\t    if (!isFinite(offset)) { return p1; }\n\t    var length = p1.distance(p2);\n\t    if (offset === 0 && length > 0) { return p1; }\n\t    return p1.move(p2, -Math.min(offset, length - 1));\n\t}\n\n\tfunction stroke$1(magnet) {\n\n\t    var stroke = magnet.getAttribute('stroke-width');\n\t    if (stroke === null) { return 0; }\n\t    return parseFloat(stroke) || 0;\n\t}\n\n\tfunction alignLine(line, type, offset) {\n\t    if ( offset === void 0 ) offset = 0;\n\n\t    var coordinate, a, b, direction;\n\t    var start = line.start;\n\t    var end = line.end;\n\t    switch (type) {\n\t        case 'left':\n\t            coordinate = 'x';\n\t            a = end;\n\t            b = start;\n\t            direction = -1;\n\t            break;\n\t        case 'right':\n\t            coordinate = 'x';\n\t            a = start;\n\t            b = end;\n\t            direction = 1;\n\t            break;\n\t        case 'top':\n\t            coordinate = 'y';\n\t            a = end;\n\t            b = start;\n\t            direction = -1;\n\t            break;\n\t        case 'bottom':\n\t            coordinate = 'y';\n\t            a = start;\n\t            b = end;\n\t            direction = 1;\n\t            break;\n\t        default:\n\t            return;\n\t    }\n\t    if (start[coordinate] < end[coordinate]) {\n\t        a[coordinate] = b[coordinate];\n\t    } else {\n\t        b[coordinate] = a[coordinate];\n\t    }\n\t    if (isFinite(offset)) {\n\t        a[coordinate] += direction * offset;\n\t        b[coordinate] += direction * offset;\n\t    }\n\t}\n\n\t// Connection Points\n\n\tfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n\t    var offset = opt.offset;\n\t    var alignOffset = opt.alignOffset;\n\t    var align = opt.align;\n\t    if (align) { alignLine(line, align, alignOffset); }\n\t    return offsetPoint(line.end, line.start, offset);\n\t}\n\n\tfunction bboxIntersection(line, view, magnet, opt) {\n\n\t    var bbox = view.getNodeBBox(magnet);\n\t    if (opt.stroke) { bbox.inflate(stroke$1(magnet) / 2); }\n\t    var intersections = line.intersect(bbox);\n\t    var cp = (intersections)\n\t        ? line.start.chooseClosest(intersections)\n\t        : line.end;\n\t    return offsetPoint(cp, line.start, opt.offset);\n\t}\n\n\tfunction rectangleIntersection(line, view, magnet, opt) {\n\n\t    var angle = view.model.angle();\n\t    if (angle === 0) {\n\t        return bboxIntersection(line, view, magnet, opt);\n\t    }\n\n\t    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n\t    if (opt.stroke) { bboxWORotation.inflate(stroke$1(magnet) / 2); }\n\t    var center = bboxWORotation.center();\n\t    var lineWORotation = line.clone().rotate(center, angle);\n\t    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n\t    var cp = (intersections)\n\t        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n\t        : line.end;\n\t    return offsetPoint(cp, line.start, opt.offset);\n\t}\n\n\tfunction findShapeNode(magnet) {\n\t    if (!magnet) { return null; }\n\t    var node = magnet;\n\t    do {\n\t        var tagName = node.tagName;\n\t        if (typeof tagName !== 'string') { return null; }\n\t        tagName = tagName.toUpperCase();\n\t        if (tagName === 'G') {\n\t            node = node.firstElementChild;\n\t        } else if (tagName === 'TITLE') {\n\t            node = node.nextElementSibling;\n\t        } else { break; }\n\t    } while (node);\n\t    return node;\n\t}\n\n\tvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\n\tvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\n\tfunction boundaryIntersection(line, view, magnet, opt) {\n\n\t    var node, intersection;\n\t    var selector = opt.selector;\n\t    var anchor = line.end;\n\n\t    if (typeof selector === 'string') {\n\t        node = view.findBySelector(selector)[0];\n\t    } else if (Array.isArray(selector)) {\n\t        node = getByPath(magnet, selector);\n\t    } else {\n\t        node = findShapeNode(magnet);\n\t    }\n\n\t    if (!V.isSVGGraphicsElement(node)) {\n\t        if (node === magnet || !V.isSVGGraphicsElement(magnet)) { return anchor; }\n\t        node = magnet;\n\t    }\n\n\t    var localShape = view.getNodeShape(node);\n\t    var magnetMatrix = view.getNodeMatrix(node);\n\t    var translateMatrix = view.getRootTranslateMatrix();\n\t    var rotateMatrix = view.getRootRotateMatrix();\n\t    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n\t    var localMatrix = targetMatrix.inverse();\n\t    var localLine = V.transformLine(line, localMatrix);\n\t    var localRef = localLine.start.clone();\n\t    var data = view.getNodeData(node);\n\n\t    if (opt.insideout === false) {\n\t        if (!data[BNDR_SHAPE_BBOX]) { data[BNDR_SHAPE_BBOX] = localShape.bbox(); }\n\t        var localBBox = data[BNDR_SHAPE_BBOX];\n\t        if (localBBox.containsPoint(localRef)) { return anchor; }\n\t    }\n\n\t    // Caching segment subdivisions for paths\n\t    var pathOpt;\n\t    if (localShape instanceof Path) {\n\t        var precision = opt.precision || 2;\n\t        if (!data[BNDR_SUBDIVISIONS]) { data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision }); }\n\t        pathOpt = {\n\t            precision: precision,\n\t            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n\t        };\n\t    }\n\n\t    if (opt.extrapolate === true) { localLine.setLength(1e6); }\n\n\t    intersection = localLine.intersect(localShape, pathOpt);\n\t    if (intersection) {\n\t        // More than one intersection\n\t        if (V.isArray(intersection)) { intersection = localRef.chooseClosest(intersection); }\n\t    } else if (opt.sticky === true) {\n\t        // No intersection, find the closest point instead\n\t        if (localShape instanceof Rect) {\n\t            intersection = localShape.pointNearestToPoint(localRef);\n\t        } else if (localShape instanceof Ellipse) {\n\t            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n\t        } else {\n\t            intersection = localShape.closestPoint(localRef, pathOpt);\n\t        }\n\t    }\n\n\t    var cp = (intersection) ? V.transformPoint(intersection, targetMatrix) : anchor;\n\t    var cpOffset = opt.offset || 0;\n\t    if (opt.stroke) { cpOffset += stroke$1(node) / 2; }\n\n\t    return offsetPoint(cp, line.start, cpOffset);\n\t}\n\n\tvar anchor = anchorConnectionPoint;\n\tvar bbox = bboxIntersection;\n\tvar rectangle = rectangleIntersection;\n\tvar boundary = boundaryIntersection;\n\n\tvar connectionPoints = ({\n\t\tanchor: anchor,\n\t\tbbox: bbox,\n\t\trectangle: rectangle,\n\t\tboundary: boundary\n\t});\n\n\tfunction bboxWrapper(method) {\n\n\t    return function(view, magnet, ref, opt) {\n\n\t        var rotate = !!opt.rotate;\n\t        var bbox = (rotate) ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n\t        var anchor = bbox[method]();\n\n\t        var dx = opt.dx;\n\t        if (dx) {\n\t            var dxPercentage = isPercentage(dx);\n\t            dx = parseFloat(dx);\n\t            if (isFinite(dx)) {\n\t                if (dxPercentage) {\n\t                    dx /= 100;\n\t                    dx *= bbox.width;\n\t                }\n\t                anchor.x += dx;\n\t            }\n\t        }\n\n\t        var dy = opt.dy;\n\t        if (dy) {\n\t            var dyPercentage = isPercentage(dy);\n\t            dy = parseFloat(dy);\n\t            if (isFinite(dy)) {\n\t                if (dyPercentage) {\n\t                    dy /= 100;\n\t                    dy *= bbox.height;\n\t                }\n\t                anchor.y += dy;\n\t            }\n\t        }\n\n\t        return (rotate) ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n\t    };\n\t}\n\n\tfunction _perpendicular(view, magnet, refPoint, opt) {\n\n\t    var angle = view.model.angle();\n\t    var bbox = view.getNodeBBox(magnet);\n\t    var anchor = bbox.center();\n\t    var topLeft = bbox.origin();\n\t    var bottomRight = bbox.corner();\n\n\t    var padding = opt.padding;\n\t    if (!isFinite(padding)) { padding = 0; }\n\n\t    if ((topLeft.y + padding) <= refPoint.y && refPoint.y <= (bottomRight.y - padding)) {\n\t        var dy = (refPoint.y - anchor.y);\n\t        anchor.x += (angle === 0 || angle === 180) ? 0 : dy * 1 / Math.tan(toRad(angle));\n\t        anchor.y += dy;\n\t    } else if ((topLeft.x + padding) <= refPoint.x && refPoint.x <= (bottomRight.x - padding)) {\n\t        var dx = (refPoint.x - anchor.x);\n\t        anchor.y += (angle === 90 || angle === 270) ? 0 : dx * Math.tan(toRad(angle));\n\t        anchor.x += dx;\n\t    }\n\n\t    return anchor;\n\t}\n\n\tfunction _midSide(view, magnet, refPoint, opt) {\n\n\t    var rotate = !!opt.rotate;\n\t    var bbox, angle, center;\n\t    if (rotate) {\n\t        bbox = view.getNodeUnrotatedBBox(magnet);\n\t        center = view.model.getBBox().center();\n\t        angle = view.model.angle();\n\t    } else {\n\t        bbox = view.getNodeBBox(magnet);\n\t    }\n\n\t    var padding = opt.padding;\n\t    if (isFinite(padding)) { bbox.inflate(padding); }\n\n\t    if (rotate) { refPoint.rotate(center, angle); }\n\n\t    var side = bbox.sideNearestToPoint(refPoint);\n\t    var anchor;\n\t    switch (side) {\n\t        case 'left':\n\t            anchor = bbox.leftMiddle();\n\t            break;\n\t        case 'right':\n\t            anchor = bbox.rightMiddle();\n\t            break;\n\t        case 'top':\n\t            anchor = bbox.topMiddle();\n\t            break;\n\t        case 'bottom':\n\t            anchor = bbox.bottomMiddle();\n\t            break;\n\t    }\n\n\t    return (rotate) ? anchor.rotate(center, -angle) : anchor;\n\t}\n\n\t// Can find anchor from model, when there is no selector or the link end\n\t// is connected to a port\n\tfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n\t    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n\t}\n\n\t//joint.anchors\n\tvar center = bboxWrapper('center');\n\tvar top$2 = bboxWrapper('topMiddle');\n\tvar bottom$2 = bboxWrapper('bottomMiddle');\n\tvar left$2 = bboxWrapper('leftMiddle');\n\tvar right$2 = bboxWrapper('rightMiddle');\n\tvar topLeft = bboxWrapper('origin');\n\tvar topRight = bboxWrapper('topRight');\n\tvar bottomLeft = bboxWrapper('bottomLeft');\n\tvar bottomRight = bboxWrapper('corner');\n\tvar perpendicular = resolveRef(_perpendicular);\n\tvar midSide = resolveRef(_midSide);\n\tvar modelCenter = _modelCenter;\n\n\tvar anchors = ({\n\t\tcenter: center,\n\t\ttop: top$2,\n\t\tbottom: bottom$2,\n\t\tleft: left$2,\n\t\tright: right$2,\n\t\ttopLeft: topLeft,\n\t\ttopRight: topRight,\n\t\tbottomLeft: bottomLeft,\n\t\tbottomRight: bottomRight,\n\t\tperpendicular: perpendicular,\n\t\tmidSide: midSide,\n\t\tmodelCenter: modelCenter\n\t});\n\n\tvar sortingTypes = {\n\t    NONE: 'sorting-none',\n\t    APPROX: 'sorting-approximate',\n\t    EXACT: 'sorting-exact'\n\t};\n\n\tvar LayersNames = {\n\t    CELLS: 'cells',\n\t    BACK: 'back',\n\t    FRONT: 'front',\n\t    TOOLS: 'tools'\n\t};\n\n\tvar MOUNT_BATCH_SIZE = 1000;\n\tvar UPDATE_BATCH_SIZE = Infinity;\n\tvar MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\n\tvar HighlightingTypes$1 = CellView.Highlighting;\n\n\tvar defaultHighlighting = {};\n\tdefaultHighlighting[HighlightingTypes$1.DEFAULT] = {\n\t        name: 'stroke',\n\t        options: {\n\t            padding: 3\n\t        }\n\t    };\n\tdefaultHighlighting[HighlightingTypes$1.MAGNET_AVAILABILITY] = {\n\t        name: 'addClass',\n\t        options: {\n\t            className: 'available-magnet'\n\t        }\n\t    };\n\tdefaultHighlighting[HighlightingTypes$1.ELEMENT_AVAILABILITY] = {\n\t        name: 'addClass',\n\t        options: {\n\t            className: 'available-cell'\n\t        }\n\t    };\n\n\tvar Paper = View.extend({\n\n\t    className: 'paper',\n\n\t    options: {\n\n\t        width: 800,\n\t        height: 600,\n\t        origin: { x: 0, y: 0 }, // x,y coordinates in top-left corner\n\t        gridSize: 1,\n\n\t        // Whether or not to draw the grid lines on the paper's DOM element.\n\t        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n\t        drawGrid: false,\n\n\t        // Whether or not to draw the background on the paper's DOM element.\n\t        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n\t        background: false,\n\n\t        perpendicularLinks: false,\n\t        elementView: ElementView,\n\t        linkView: LinkView,\n\t        snapLabels: false, // false, true\n\t        snapLinks: false, // false, true, { radius: value }\n\n\t        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n\t        multiLinks: true,\n\n\t        // For adding custom guard logic.\n\t        guard: function(evt, view) {\n\n\t            // FALSE means the event isn't guarded.\n\t            return false;\n\t        },\n\n\t        highlighting: defaultHighlighting,\n\n\t        // Prevent the default context menu from being displayed.\n\t        preventContextMenu: true,\n\n\t        // Prevent the default action for blank:pointer<action>.\n\t        preventDefaultBlankAction: true,\n\n\t        // Restrict the translation of elements by given bounding box.\n\t        // Option accepts a boolean:\n\t        //  true - the translation is restricted to the paper area\n\t        //  false - no restrictions\n\t        // A method:\n\t        // restrictTranslate: function(elementView) {\n\t        //     var parentId = elementView.model.get('parent');\n\t        //     return parentId && this.model.getCell(parentId).getBBox();\n\t        // },\n\t        // Or a bounding box:\n\t        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n\t        restrictTranslate: false,\n\n\t        // Marks all available magnets with 'available-magnet' class name and all available cells with\n\t        // 'available-cell' class name. Marks them when dragging a link is started and unmark\n\t        // when the dragging is stopped.\n\t        markAvailable: false,\n\n\t        // Defines what link model is added to the graph after an user clicks on an active magnet.\n\t        // Value could be the Backbone.model or a function returning the Backbone.model\n\t        // defaultLink: function(elementView, magnet) { return condition ? new customLink1() : new customLink2() }\n\t        defaultLink: new Link,\n\n\t        // A connector that is used by links with no connector defined on the model.\n\t        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n\t        defaultConnector: { name: 'normal' },\n\n\t        // A router that is used by links with no router defined on the model.\n\t        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n\t        defaultRouter: { name: 'normal' },\n\n\t        defaultAnchor: { name: 'center' },\n\n\t        defaultLinkAnchor: { name: 'connectionRatio' },\n\n\t        defaultConnectionPoint: { name: 'bbox' },\n\n\t        /* CONNECTING */\n\n\t        connectionStrategy: null,\n\n\t        // Check whether to add a new link to the graph when user clicks on an a magnet.\n\t        validateMagnet: function(_cellView, magnet, _evt) {\n\t            return magnet.getAttribute('magnet') !== 'passive';\n\t        },\n\n\t        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n\t        // being changed.\n\t        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n\t            return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n\t        },\n\n\t        /* EMBEDDING */\n\n\t        // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n\t        // all links and elements are visible taken the level of embedding into account.\n\t        embeddingMode: false,\n\n\t        // Check whether to allow or disallow the element embedding while an element being translated.\n\t        validateEmbedding: function(childView, parentView) {\n\t            // by default all elements can be in relation child-parent\n\t            return true;\n\t        },\n\n\t        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n\t        // The cell with the highest z-index (visually on the top) will be chosen.\n\t        findParentBy: 'bbox', // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n\t        // If enabled only the element on the very front is taken into account for the embedding.\n\t        // If disabled the elements under the dragged view are tested one by one\n\t        // (from front to back) until a valid parent found.\n\t        frontParentOnly: true,\n\n\t        // Interactive flags. See online docs for the complete list of interactive flags.\n\t        interactive: {\n\t            labelMove: false\n\t        },\n\n\t        // When set to true the links can be pinned to the paper.\n\t        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n\t        linkPinning: true,\n\n\t        // Custom validation after an interaction with a link ends.\n\t        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n\t        // (linkView, paper) => boolean\n\t        allowLink: null,\n\n\t        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n\t        clickThreshold: 0,\n\n\t        // Number of required mousemove events before the first pointermove event will be triggered.\n\t        moveThreshold: 0,\n\n\t        // Number of required mousemove events before the a link is created out of the magnet.\n\t        // Or string `onleave` so the link is created when the pointer leaves the magnet\n\t        magnetThreshold: 0,\n\n\t        // Rendering Options\n\n\t        sorting: sortingTypes.EXACT,\n\n\t        frozen: false,\n\n\t        // no docs yet\n\t        onViewUpdate: function(view, flag, priority, opt, paper) {\n\t            if ((flag & view.FLAG_INSERT) || opt.mounting) { return; }\n\t            paper.requestConnectedLinksUpdate(view, priority, opt);\n\t        },\n\n\t        // no docs yet\n\t        onViewPostponed: function(view, flag, paper) {\n\t            return paper.forcePostponedViewUpdate(view, flag);\n\t        },\n\n\t        beforeRender: null, // function(opt, paper) { },\n\n\t        afterRender: null, // function(stats, opt, paper) {\n\n\t        viewport: null,\n\n\t        // Default namespaces\n\n\t        cellViewNamespace: null,\n\n\t        highlighterNamespace: highlighters,\n\n\t        anchorNamespace: anchors,\n\n\t        linkAnchorNamespace: linkAnchors,\n\n\t        connectionPointNamespace: connectionPoints\n\t    },\n\n\t    events: {\n\t        'dblclick': 'pointerdblclick',\n\t        'contextmenu': 'contextmenu',\n\t        'mousedown': 'pointerdown',\n\t        'touchstart': 'pointerdown',\n\t        'mouseover': 'mouseover',\n\t        'mouseout': 'mouseout',\n\t        'mouseenter': 'mouseenter',\n\t        'mouseleave': 'mouseleave',\n\t        'mousewheel': 'mousewheel',\n\t        'DOMMouseScroll': 'mousewheel',\n\t        'mouseenter .joint-cell': 'mouseenter',\n\t        'mouseleave .joint-cell': 'mouseleave',\n\t        'mouseenter .joint-tools': 'mouseenter',\n\t        'mouseleave .joint-tools': 'mouseleave',\n\t        'mousedown .joint-cell [event]': 'onevent', // interaction with cell with `event` attribute set\n\t        'touchstart .joint-cell [event]': 'onevent',\n\t        'mousedown .joint-cell [magnet]': 'onmagnet', // interaction with cell with `magnet` attribute set\n\t        'touchstart .joint-cell [magnet]': 'onmagnet',\n\t        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n\t        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n\t        'mousedown .joint-link .label': 'onlabel', // interaction with link label\n\t        'touchstart .joint-link .label': 'onlabel',\n\t        'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n\t    },\n\n\t    documentEvents: {\n\t        'mousemove': 'pointermove',\n\t        'touchmove': 'pointermove',\n\t        'mouseup': 'pointerup',\n\t        'touchend': 'pointerup',\n\t        'touchcancel': 'pointerup'\n\t    },\n\n\t    svg: null,\n\t    viewport: null,\n\t    defs: null,\n\t    tools: null,\n\t    $background: null,\n\t    layers: null,\n\t    $grid: null,\n\t    $document: null,\n\n\t    _zPivots: null,\n\t    // For storing the current transformation matrix (CTM) of the paper's viewport.\n\t    _viewportMatrix: null,\n\t    // For verifying whether the CTM is up-to-date. The viewport transform attribute\n\t    // could have been manipulated directly.\n\t    _viewportTransformString: null,\n\t    // Updates data (priorities, unmounted views etc.)\n\t    _updates: null,\n\t    // Paper Layers\n\t    _layers: null,\n\n\t    SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n\t    UPDATE_DELAYING_BATCHES: ['translate'],\n\t    MIN_SCALE: 1e-6,\n\n\t    init: function() {\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var el = ref.el;\n\t        if (!options.cellViewNamespace) {\n\t            /* global joint: true */\n\t            options.cellViewNamespace = typeof joint !== 'undefined' && has$2(joint, 'shapes') ? joint.shapes : null;\n\t            /* global joint: false */\n\t        }\n\n\t        var model = this.model = options.model || new Graph;\n\n\t        // Layers (SVGGroups)\n\t        // TODO: layer classes\n\t        this._layers = {};\n\n\t        this.setGrid(options.drawGrid);\n\t        this.cloneOptions();\n\t        this.render();\n\t        this.setDimensions();\n\t        this.startListening();\n\n\t        // Hash of all cell views.\n\t        this._views = {};\n\t        // z-index pivots\n\t        this._zPivots = {};\n\t        // Reference to the paper owner document\n\t        this.$document = $(el.ownerDocument);\n\t        // Render existing cells in the graph\n\t        this.resetViews(model.attributes.cells.models);\n\t        // Start the Rendering Loop\n\t        if (!this.isFrozen() && this.isAsync()) { this.updateViewsAsync(); }\n\t    },\n\n\t    _resetUpdates: function() {\n\t        return this._updates = {\n\t            id: null,\n\t            priorities: [{}, {}, {}],\n\t            unmountedCids: [],\n\t            mountedCids: [],\n\t            unmounted: {},\n\t            mounted: {},\n\t            count: 0,\n\t            keyFrozen: false,\n\t            freezeKey: null,\n\t            sort: false\n\t        };\n\t    },\n\n\t    startListening: function() {\n\t        var model = this.model;\n\t        this.listenTo(model, 'add', this.onCellAdded)\n\t            .listenTo(model, 'remove', this.onCellRemoved)\n\t            .listenTo(model, 'change', this.onCellChange)\n\t            .listenTo(model, 'reset', this.onGraphReset)\n\t            .listenTo(model, 'sort', this.onGraphSort)\n\t            .listenTo(model, 'batch:stop', this.onGraphBatchStop);\n\t        this.on('cell:highlight', this.onCellHighlight)\n\t            .on('cell:unhighlight', this.onCellUnhighlight)\n\t            .on('scale translate', this.update);\n\t    },\n\n\t    onCellAdded: function(cell, _, opt) {\n\t        var position = opt.position;\n\t        if (this.isAsync() || !isNumber(position)) {\n\t            this.renderView(cell, opt);\n\t        } else {\n\t            if (opt.maxPosition === position) { this.freeze({ key: 'addCells' }); }\n\t            this.renderView(cell, opt);\n\t            if (position === 0) { this.unfreeze({ key: 'addCells' }); }\n\t        }\n\t    },\n\n\t    onCellRemoved: function(cell, _, opt) {\n\t        var view = this.findViewByModel(cell);\n\t        if (view) { this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt); }\n\t    },\n\n\t    onCellChange: function(cell, opt) {\n\t        if (cell === this.model.attributes.cells) { return; }\n\t        if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n\t            var view = this.findViewByModel(cell);\n\t            if (view) { this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt); }\n\t        }\n\t    },\n\n\t    onGraphReset: function(collection, opt) {\n\t        this.removeZPivots();\n\t        this.resetViews(collection.models, opt);\n\t    },\n\n\t    onGraphSort: function() {\n\t        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) { return; }\n\t        this.sortViews();\n\t    },\n\n\t    onGraphBatchStop: function(data) {\n\t        if (this.isFrozen()) { return; }\n\t        var name = data && data.batchName;\n\t        var graph = this.model;\n\t        if (!this.isAsync()) {\n\t            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n\t            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n\t                this.updateViews(data);\n\t            }\n\t        }\n\t        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n\t        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n\t            this.sortViews();\n\t        }\n\t    },\n\n\t    cloneOptions: function() {\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var defaultConnector = options.defaultConnector;\n\t        var defaultRouter = options.defaultRouter;\n\t        var defaultConnectionPoint = options.defaultConnectionPoint;\n\t        var defaultAnchor = options.defaultAnchor;\n\t        var defaultLinkAnchor = options.defaultLinkAnchor;\n\t        var origin = options.origin;\n\t        var highlighting = options.highlighting;\n\t        var cellViewNamespace = options.cellViewNamespace;\n\t        var interactive = options.interactive;\n\n\t        // Default cellView namespace for ES5\n\t        /* global joint: true */\n\t        if (!cellViewNamespace && typeof joint !== 'undefined' && has$2(joint, 'shapes')) {\n\t            options.cellViewNamespace = joint.shapes;\n\t        }\n\t        /* global joint: false */\n\n\t        // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n\t        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n\t        if (!isFunction(defaultConnector)) {\n\t            options.defaultConnector = cloneDeep(defaultConnector);\n\t        }\n\t        if (!isFunction(defaultRouter)) {\n\t            options.defaultRouter = cloneDeep(defaultRouter);\n\t        }\n\t        if (!isFunction(defaultConnectionPoint)) {\n\t            options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n\t        }\n\t        if (!isFunction(defaultAnchor)) {\n\t            options.defaultAnchor = cloneDeep(defaultAnchor);\n\t        }\n\t        if (!isFunction(defaultLinkAnchor)) {\n\t            options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n\t        }\n\t        if (isPlainObject(interactive)) {\n\t            options.interactive = assign({}, interactive);\n\t        }\n\t        if (isPlainObject(highlighting)) {\n\t            // Return the default highlighting options into the user specified options.\n\t            options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n\t        }\n\t        options.origin = assign({}, origin);\n\t    },\n\n\t    children: function() {\n\t        var ns = V.namespace;\n\t        return [{\n\t            namespaceURI: ns.xhtml,\n\t            tagName: 'div',\n\t            className: addClassNamePrefix('paper-background'),\n\t            selector: 'background'\n\t        }, {\n\t            namespaceURI: ns.xhtml,\n\t            tagName: 'div',\n\t            className: addClassNamePrefix('paper-grid'),\n\t            selector: 'grid'\n\t        }, {\n\t            namespaceURI: ns.svg,\n\t            tagName: 'svg',\n\t            attributes: {\n\t                'width': '100%',\n\t                'height': '100%',\n\t                'xmlns:xlink': ns.xlink\n\t            },\n\t            selector: 'svg',\n\t            children: [{\n\t                // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n\t                // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n\t                tagName: 'defs',\n\t                selector: 'defs'\n\t            }, {\n\t                tagName: 'g',\n\t                className: addClassNamePrefix('layers'),\n\t                selector: 'layers',\n\t                children: [{\n\t                    tagName: 'g',\n\t                    className: addClassNamePrefix('back-layer'),\n\t                    selector: 'back',\n\t                }, {\n\t                    tagName: 'g',\n\t                    className: addClassNamePrefix('cells-layer viewport'),\n\t                    selector: 'cells',\n\t                }, {\n\t                    tagName: 'g',\n\t                    className: addClassNamePrefix('front-layer'),\n\t                    selector: 'front',\n\t                }, {\n\t                    tagName: 'g',\n\t                    className: addClassNamePrefix('tools-layer'),\n\t                    selector: 'tools'\n\t                }]\n\t            }]\n\t        }];\n\t    },\n\n\t    getLayerNode: function getLayerNode(layerName) {\n\t        var ref = this;\n\t        var _layers = ref._layers;\n\t        if (layerName in _layers) { return _layers[layerName]; }\n\t        throw new Error((\"dia.Paper: Unknown layer \\\"\" + layerName + \"\\\"\"));\n\t    },\n\n\t    render: function() {\n\t        var obj;\n\n\n\t        this.renderChildren();\n\t        var ref = this;\n\t        var childNodes = ref.childNodes;\n\t        var options = ref.options;\n\t        var svg = childNodes.svg;\n\t        var cells = childNodes.cells;\n\t        var defs = childNodes.defs;\n\t        var tools = childNodes.tools;\n\t        var layers = childNodes.layers;\n\t        var back = childNodes.back;\n\t        var front = childNodes.front;\n\t        var background = childNodes.background;\n\t        var grid = childNodes.grid;\n\n\t        this.svg = svg;\n\t        this.defs = defs;\n\t        this.tools = tools;\n\t        this.cells = cells;\n\t        this.layers = layers;\n\t        this.$background = $(background);\n\t        this.$grid = $(grid);\n\n\t        assign(this._layers, ( obj = {}, obj[LayersNames.BACK] = back, obj[LayersNames.CELLS] = cells, obj[LayersNames.FRONT] = front, obj[LayersNames.TOOLS] = tools, obj ));\n\n\t        V.ensureId(svg);\n\n\t        // backwards compatibility\n\t        this.viewport = cells;\n\n\t        if (options.background) {\n\t            this.drawBackground(options.background);\n\t        }\n\n\t        if (options.drawGrid) {\n\t            this.drawGrid();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    update: function() {\n\n\t        if (this.options.drawGrid) {\n\t            this.drawGrid();\n\t        }\n\n\t        if (this._background) {\n\t            this.updateBackgroundImage(this._background);\n\t        }\n\n\t        return this;\n\t    },\n\n\t    matrix: function(ctm) {\n\n\t        var viewport = this.layers;\n\n\t        // Getter:\n\t        if (ctm === undefined) {\n\n\t            var transformString = viewport.getAttribute('transform');\n\n\t            if ((this._viewportTransformString || null) === transformString) {\n\t                // It's ok to return the cached matrix. The transform attribute has not changed since\n\t                // the matrix was stored.\n\t                ctm = this._viewportMatrix;\n\t            } else {\n\t                // The viewport transform attribute has changed. Measure the matrix and cache again.\n\t                ctm = viewport.getCTM();\n\t                this._viewportMatrix = ctm;\n\t                this._viewportTransformString = transformString;\n\t            }\n\n\t            // Clone the cached current transformation matrix.\n\t            // If no matrix previously stored the identity matrix is returned.\n\t            return V.createSVGMatrix(ctm);\n\t        }\n\n\t        // Setter:\n\t        ctm = V.createSVGMatrix(ctm);\n\t        var ctmString = V.matrixToTransformString(ctm);\n\t        viewport.setAttribute('transform', ctmString);\n\n\t        this._viewportMatrix = ctm;\n\t        this._viewportTransformString = viewport.getAttribute('transform');\n\n\t        return this;\n\t    },\n\n\t    clientMatrix: function() {\n\n\t        return V.createSVGMatrix(this.cells.getScreenCTM());\n\t    },\n\n\t    requestConnectedLinksUpdate: function(view, priority, opt) {\n\t        if (view instanceof CellView) {\n\t            var model = view.model;\n\t            var links = this.model.getConnectedLinks(model);\n\t            for (var j = 0, n = links.length; j < n; j++) {\n\t                var link = links[j];\n\t                var linkView = this.findViewByModel(link);\n\t                if (!linkView) { continue; }\n\t                var flagLabels = ['UPDATE'];\n\t                if (link.getTargetCell() === model) { flagLabels.push('TARGET'); }\n\t                if (link.getSourceCell() === model) { flagLabels.push('SOURCE'); }\n\t                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n\t                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n\t            }\n\t        }\n\t    },\n\n\t    forcePostponedViewUpdate: function(view, flag) {\n\t        if (!view || !(view instanceof CellView)) { return false; }\n\t        var model = view.model;\n\t        if (model.isElement()) { return false; }\n\t        if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n\t            // LinkView is waiting for the target or the source cellView to be rendered\n\t            // This can happen when the cells are not in the viewport.\n\t            var sourceFlag = 0;\n\t            var sourceView = this.findViewByModel(model.getSourceCell());\n\t            if (sourceView && !this.isViewMounted(sourceView)) {\n\t                sourceFlag = this.dumpView(sourceView);\n\t                view.updateEndMagnet('source');\n\t            }\n\t            var targetFlag = 0;\n\t            var targetView = this.findViewByModel(model.getTargetCell());\n\t            if (targetView && !this.isViewMounted(targetView)) {\n\t                targetFlag = this.dumpView(targetView);\n\t                view.updateEndMagnet('target');\n\t            }\n\t            if (sourceFlag === 0 && targetFlag === 0) {\n\t                // If leftover flag is 0, all view updates were done.\n\t                return !this.dumpView(view);\n\t            }\n\t        }\n\t        return false;\n\t    },\n\n\t    requestViewUpdate: function(view, flag, priority, opt) {\n\t        opt || (opt = {});\n\t        this.scheduleViewUpdate(view, flag, priority, opt);\n\t        var isAsync = this.isAsync();\n\t        if (this.isFrozen() || (isAsync && opt.async !== false)) { return; }\n\t        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) { return; }\n\t        var stats = this.updateViews(opt);\n\t        if (isAsync) { this.notifyAfterRender(stats, opt); }\n\t    },\n\n\t    scheduleViewUpdate: function(view, type, priority, opt) {\n\t        var ref = this;\n\t        var updates = ref._updates;\n\t        var options = ref.options;\n\t        var FLAG_REMOVE = view.FLAG_REMOVE;\n\t        var FLAG_INSERT = view.FLAG_INSERT;\n\t        var UPDATE_PRIORITY = view.UPDATE_PRIORITY;\n\t        var cid = view.cid;\n\t        var priorityUpdates = updates.priorities[priority];\n\t        if (!priorityUpdates) { priorityUpdates = updates.priorities[priority] = {}; }\n\t        // Move higher priority updates to this priority\n\t        if (priority > UPDATE_PRIORITY) {\n\t            // Not the default priority for this view. It's most likely a link view\n\t            // connected to another link view, which triggered the update.\n\t            // TODO: If there is an update scheduled with a lower priority already, we should\n\t            // change the requested priority to the lowest one. Does not seem to be critical\n\t            // right now, as it \"only\" results in multiple updates on the same view.\n\t            for (var i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n\t                var prevPriorityUpdates = updates.priorities[i];\n\t                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) { continue; }\n\t                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n\t                delete prevPriorityUpdates[cid];\n\t            }\n\t        }\n\t        var currentType = priorityUpdates[cid] || 0;\n\t        // Prevent cycling\n\t        if ((currentType & type) === type) { return; }\n\t        if (!currentType) { updates.count++; }\n\t        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n\t            // When a view is removed we need to remove the insert flag as this is a reinsert\n\t            priorityUpdates[cid] ^= FLAG_INSERT;\n\t        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n\t            // When a view is added we need to remove the remove flag as this is view was previously removed\n\t            priorityUpdates[cid] ^= FLAG_REMOVE;\n\t        }\n\t        priorityUpdates[cid] |= type;\n\t        var viewUpdateFn = options.onViewUpdate;\n\t        if (typeof viewUpdateFn === 'function') { viewUpdateFn.call(this, view, type, priority, opt || {}, this); }\n\t    },\n\n\t    dumpViewUpdate: function(view) {\n\t        if (!view) { return 0; }\n\t        var updates = this._updates;\n\t        var cid = view.cid;\n\t        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n\t        var flag = this.registerMountedView(view) | priorityUpdates[cid];\n\t        delete priorityUpdates[cid];\n\t        return flag;\n\t    },\n\n\t    dumpView: function(view, opt) {\n\t        var flag = this.dumpViewUpdate(view);\n\t        if (!flag) { return 0; }\n\t        return this.updateView(view, flag, opt);\n\t    },\n\n\t    updateView: function(view, flag, opt) {\n\t        if (!view) { return 0; }\n\t        var FLAG_REMOVE = view.FLAG_REMOVE;\n\t        var FLAG_INSERT = view.FLAG_INSERT;\n\t        var model = view.model;\n\t        if (view instanceof CellView) {\n\t            if (flag & FLAG_REMOVE) {\n\t                this.removeView(model);\n\t                return 0;\n\t            }\n\t            if (flag & FLAG_INSERT) {\n\t                this.insertView(view);\n\t                flag ^= FLAG_INSERT;\n\t            }\n\t        }\n\t        if (!flag) { return 0; }\n\t        return view.confirmUpdate(flag, opt || {});\n\t    },\n\n\t    requireView: function(model, opt) {\n\t        var view = this.findViewByModel(model);\n\t        if (!view) { return null; }\n\t        this.dumpView(view, opt);\n\t        return view;\n\t    },\n\n\t    registerUnmountedView: function(view) {\n\t        var cid = view.cid;\n\t        var updates = this._updates;\n\t        if (cid in updates.unmounted) { return 0; }\n\t        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n\t        updates.unmountedCids.push(cid);\n\t        delete updates.mounted[cid];\n\t        return flag;\n\t    },\n\n\t    registerMountedView: function(view) {\n\t        var cid = view.cid;\n\t        var updates = this._updates;\n\t        if (cid in updates.mounted) { return 0; }\n\t        updates.mounted[cid] = true;\n\t        updates.mountedCids.push(cid);\n\t        var flag = updates.unmounted[cid] || 0;\n\t        delete updates.unmounted[cid];\n\t        return flag;\n\t    },\n\n\t    isViewMounted: function(view) {\n\t        if (!view) { return false; }\n\t        var cid = view.cid;\n\t        var updates = this._updates;\n\t        return (cid in updates.mounted);\n\t    },\n\n\t    dumpViews: function(opt) {\n\t        var passingOpt = defaults({}, opt, { viewport: null });\n\t        this.checkViewport(passingOpt);\n\t        this.updateViews(passingOpt);\n\t    },\n\n\t    // Synchronous views update\n\t    updateViews: function(opt) {\n\t        this.notifyBeforeRender(opt);\n\t        var batchStats;\n\t        var updateCount = 0;\n\t        var batchCount = 0;\n\t        var priority = MIN_PRIORITY;\n\t        do {\n\t            batchCount++;\n\t            batchStats = this.updateViewsBatch(opt);\n\t            updateCount += batchStats.updated;\n\t            priority = Math.min(batchStats.priority, priority);\n\t        } while (!batchStats.empty);\n\t        var stats = { updated: updateCount, batches: batchCount, priority: priority };\n\t        this.notifyAfterRender(stats, opt);\n\t        return stats;\n\t    },\n\n\t    hasScheduledUpdates: function() {\n\t        var priorities = this._updates.priorities;\n\t        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n\t        var i = priorityIndexes.length;\n\t        while (i > 0 && i--) {\n\t            // a faster way how to check if an object is empty\n\t            for (var _key in priorities[priorityIndexes[i]]) { return true; }\n\t        }\n\t        return false;\n\t    },\n\n\t    updateViewsAsync: function(opt, data) {\n\t        opt || (opt = {});\n\t        data || (data = { processed: 0, priority: MIN_PRIORITY });\n\t        var updates = this._updates;\n\t        var id = updates.id;\n\t        if (id) {\n\t            cancelFrame(id);\n\t            if (data.processed === 0 && this.hasScheduledUpdates()) {\n\t                this.notifyBeforeRender(opt);\n\t            }\n\t            var stats = this.updateViewsBatch(opt);\n\t            var passingOpt = defaults({}, opt, {\n\t                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n\t                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n\t            });\n\t            var checkStats = this.checkViewport(passingOpt);\n\t            var unmountCount = checkStats.unmounted;\n\t            var mountCount = checkStats.mounted;\n\t            var processed = data.processed;\n\t            var total = updates.count;\n\t            if (stats.updated > 0) {\n\t                // Some updates have been just processed\n\t                processed += stats.updated + stats.unmounted;\n\t                stats.processed = processed;\n\t                data.priority = Math.min(stats.priority, data.priority);\n\t                if (stats.empty && mountCount === 0) {\n\t                    stats.unmounted += unmountCount;\n\t                    stats.mounted += mountCount;\n\t                    stats.priority = data.priority;\n\t                    this.notifyAfterRender(stats, opt);\n\t                    data.processed = 0;\n\t                    updates.count = 0;\n\t                } else {\n\t                    data.processed = processed;\n\t                }\n\t            }\n\t            // Progress callback\n\t            var progressFn = opt.progress;\n\t            if (total && typeof progressFn === 'function') {\n\t                progressFn.call(this, stats.empty, processed, total, stats, this);\n\t            }\n\t            // The current frame could have been canceled in a callback\n\t            if (updates.id !== id) { return; }\n\t        }\n\t        updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n\t    },\n\n\t    notifyBeforeRender: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var beforeFn = opt.beforeRender;\n\t        if (typeof beforeFn !== 'function') {\n\t            beforeFn = this.options.beforeRender;\n\t            if (typeof beforeFn !== 'function') { return; }\n\t        }\n\t        beforeFn.call(this, opt, this);\n\t    },\n\n\t    notifyAfterRender: function(stats, opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\t        var afterFn = opt.afterRender;\n\t        if (typeof afterFn !== 'function') {\n\t            afterFn = this.options.afterRender;\n\t        }\n\t        if (typeof afterFn === 'function') {\n\t            afterFn.call(this, stats, opt, this);\n\t        }\n\t        this.trigger('render:done', stats, opt);\n\t    },\n\n\t    updateViewsBatch: function(opt) {\n\t        opt || (opt = {});\n\t        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n\t        var updates = this._updates;\n\t        var updateCount = 0;\n\t        var postponeCount = 0;\n\t        var unmountCount = 0;\n\t        var mountCount = 0;\n\t        var maxPriority = MIN_PRIORITY;\n\t        var empty = true;\n\t        var options = this.options;\n\t        var priorities = updates.priorities;\n\t        var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n\t        if (typeof viewportFn !== 'function') { viewportFn = null; }\n\t        var postponeViewFn = options.onViewPostponed;\n\t        if (typeof postponeViewFn !== 'function') { postponeViewFn = null; }\n\t        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n\t        main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n\t            var priority = priorityIndexes[i];\n\t            var priorityUpdates = priorities[priority];\n\t            for (var cid in priorityUpdates) {\n\t                if (updateCount >= batchSize) {\n\t                    empty = false;\n\t                    break main;\n\t                }\n\t                var view = views[cid];\n\t                if (!view) {\n\t                    // This should not occur\n\t                    delete priorityUpdates[cid];\n\t                    continue;\n\t                }\n\t                var currentFlag = priorityUpdates[cid];\n\t                if ((currentFlag & view.FLAG_REMOVE) === 0) {\n\t                    // We should never check a view for viewport if we are about to remove the view\n\t                    var isDetached = cid in updates.unmounted;\n\t                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n\t                        // Unmount View\n\t                        if (!isDetached) {\n\t                            this.registerUnmountedView(view);\n\t                            view.unmount();\n\t                        }\n\t                        updates.unmounted[cid] |= currentFlag;\n\t                        delete priorityUpdates[cid];\n\t                        unmountCount++;\n\t                        continue;\n\t                    }\n\t                    // Mount View\n\t                    if (isDetached) {\n\t                        currentFlag |= view.FLAG_INSERT;\n\t                        mountCount++;\n\t                    }\n\t                    currentFlag |= this.registerMountedView(view);\n\t                }\n\t                var leftoverFlag = this.updateView(view, currentFlag, opt);\n\t                if (leftoverFlag > 0) {\n\t                    // View update has not finished completely\n\t                    priorityUpdates[cid] = leftoverFlag;\n\t                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n\t                        postponeCount++;\n\t                        empty = false;\n\t                        continue;\n\t                    }\n\t                }\n\t                if (maxPriority > priority) { maxPriority = priority; }\n\t                updateCount++;\n\t                delete priorityUpdates[cid];\n\t            }\n\t        }\n\t        return {\n\t            priority: maxPriority,\n\t            updated: updateCount,\n\t            postponed: postponeCount,\n\t            unmounted: unmountCount,\n\t            mounted: mountCount,\n\t            empty: empty\n\t        };\n\t    },\n\n\t    getUnmountedViews: function() {\n\t        var updates = this._updates;\n\t        var unmountedCids = Object.keys(updates.unmounted);\n\t        var n = unmountedCids.length;\n\t        var unmountedViews = new Array(n);\n\t        for (var i = 0; i < n; i++) {\n\t            unmountedViews[i] = views[unmountedCids[i]];\n\t        }\n\t        return unmountedViews;\n\t    },\n\n\t    getMountedViews: function() {\n\t        var updates = this._updates;\n\t        var mountedCids = Object.keys(updates.mounted);\n\t        var n = mountedCids.length;\n\t        var mountedViews = new Array(n);\n\t        for (var i = 0; i < n; i++) {\n\t            mountedViews[i] = views[mountedCids[i]];\n\t        }\n\t        return mountedViews;\n\t    },\n\n\t    checkUnmountedViews: function(viewportFn, opt) {\n\t        opt || (opt  = {});\n\t        var mountCount = 0;\n\t        if (typeof viewportFn !== 'function') { viewportFn = null; }\n\t        var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n\t        var updates = this._updates;\n\t        var unmountedCids = updates.unmountedCids;\n\t        var unmounted = updates.unmounted;\n\t        for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n\t            var cid = unmountedCids[i];\n\t            if (!(cid in unmounted)) { continue; }\n\t            var view = views[cid];\n\t            if (!view) { continue; }\n\t            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n\t                // Push at the end of all unmounted ids, so this can be check later again\n\t                unmountedCids.push(cid);\n\t                continue;\n\t            }\n\t            mountCount++;\n\t            var flag = this.registerMountedView(view);\n\t            if (flag) { this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, { mounting: true }); }\n\t        }\n\t        // Get rid of views, that have been mounted\n\t        unmountedCids.splice(0, i);\n\t        return mountCount;\n\t    },\n\n\t    checkMountedViews: function(viewportFn, opt) {\n\t        opt || (opt = {});\n\t        var unmountCount = 0;\n\t        if (typeof viewportFn !== 'function') { return unmountCount; }\n\t        var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n\t        var updates = this._updates;\n\t        var mountedCids = updates.mountedCids;\n\t        var mounted = updates.mounted;\n\t        for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n\t            var cid = mountedCids[i];\n\t            if (!(cid in mounted)) { continue; }\n\t            var view = views[cid];\n\t            if (!view) { continue; }\n\t            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n\t                // Push at the end of all mounted ids, so this can be check later again\n\t                mountedCids.push(cid);\n\t                continue;\n\t            }\n\t            unmountCount++;\n\t            var flag = this.registerUnmountedView(view);\n\t            if (flag) { view.unmount(); }\n\t        }\n\t        // Get rid of views, that have been unmounted\n\t        mountedCids.splice(0, i);\n\t        return unmountCount;\n\t    },\n\n\t    checkViewport: function(opt) {\n\t        var passingOpt = defaults({}, opt, {\n\t            mountBatchSize: Infinity,\n\t            unmountBatchSize: Infinity\n\t        });\n\t        var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n\t        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n\t        if (unmountedCount > 0) {\n\t            // Do not check views, that have been just unmounted and pushed at the end of the cids array\n\t            var unmountedCids = this._updates.unmountedCids;\n\t            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n\t        }\n\t        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n\t        return {\n\t            mounted: mountedCount,\n\t            unmounted: unmountedCount\n\t        };\n\t    },\n\n\t    freeze: function(opt) {\n\t        opt || (opt = {});\n\t        var updates = this._updates;\n\t        var key = opt.key;\n\t        var isFrozen = this.options.frozen;\n\t        var freezeKey = updates.freezeKey;\n\t        if (key && key !== freezeKey)  {\n\t            // key passed, but the paper is already freezed with another key\n\t            if (isFrozen && freezeKey) { return; }\n\t            updates.freezeKey = key;\n\t            updates.keyFrozen = isFrozen;\n\t        }\n\t        this.options.frozen = true;\n\t        var id = updates.id;\n\t        updates.id = null;\n\t        if (this.isAsync() && id) { cancelFrame(id); }\n\t    },\n\n\t    unfreeze: function(opt) {\n\t        opt || (opt = {});\n\t        var updates = this._updates;\n\t        var key = opt.key;\n\t        var freezeKey = updates.freezeKey;\n\t        // key passed, but the paper is already freezed with another key\n\t        if (key && freezeKey && key !== freezeKey) { return; }\n\t        updates.freezeKey = null;\n\t        // key passed, but the paper is already freezed\n\t        if (key && key === freezeKey && updates.keyFrozen) { return; }\n\t        if (this.isAsync()) {\n\t            this.freeze();\n\t            this.updateViewsAsync(opt);\n\t        } else {\n\t            this.updateViews(opt);\n\t        }\n\t        this.options.frozen = updates.keyFrozen = false;\n\t        if (updates.sort) {\n\t            this.sortViews();\n\t            updates.sort = false;\n\t        }\n\t    },\n\n\t    isAsync: function() {\n\t        return !!this.options.async;\n\t    },\n\n\t    isFrozen: function() {\n\t        return !!this.options.frozen;\n\t    },\n\n\t    isExactSorting: function() {\n\t        return this.options.sorting === sortingTypes.EXACT;\n\t    },\n\n\t    onRemove: function() {\n\n\t        this.freeze();\n\t        //clean up all DOM elements/views to prevent memory leaks\n\t        this.removeViews();\n\t    },\n\n\t    getComputedSize: function() {\n\n\t        var options = this.options;\n\t        var w = options.width;\n\t        var h = options.height;\n\t        if (!isNumber(w)) { w = this.el.clientWidth; }\n\t        if (!isNumber(h)) { h = this.el.clientHeight; }\n\t        return { width: w, height: h };\n\t    },\n\n\t    setDimensions: function(width, height) {\n\n\t        var options = this.options;\n\t        var w = (width === undefined) ? options.width : width;\n\t        var h = (height === undefined) ? options.height : height;\n\t        this.options.width = w;\n\t        this.options.height = h;\n\t        if (isNumber(w)) { w = Math.round(w); }\n\t        if (isNumber(h)) { h = Math.round(h); }\n\t        this.$el.css({\n\t            width: (w === null) ? '' : w,\n\t            height: (h === null) ? '' : h\n\t        });\n\t        var computedSize = this.getComputedSize();\n\t        this.trigger('resize', computedSize.width, computedSize.height);\n\t    },\n\n\t    setOrigin: function(ox, oy) {\n\n\t        return this.translate(ox || 0, oy || 0, { absolute: true });\n\t    },\n\n\t    // Expand/shrink the paper to fit the content. Snap the width/height to the grid\n\t    // defined in `gridWidth`, `gridHeight`. `padding` adds to the resulting width/height of the paper.\n\t    // When options { fitNegative: true } it also translates the viewport in order to make all\n\t    // the content visible.\n\t    fitToContent: function(gridWidth, gridHeight, padding, opt) { // alternatively function(opt)\n\n\t        if (isObject$1(gridWidth)) {\n\t            // first parameter is an option object\n\t            opt = gridWidth;\n\t            gridWidth = opt.gridWidth || 1;\n\t            gridHeight = opt.gridHeight || 1;\n\t            padding = opt.padding || 0;\n\n\t        } else {\n\n\t            opt || (opt = {});\n\t            gridWidth = gridWidth || 1;\n\t            gridHeight = gridHeight || 1;\n\t            padding = padding || 0;\n\t        }\n\n\t        // Calculate the paper size to accomodate all the graph's elements.\n\n\t        padding = normalizeSides(padding);\n\n\t        var area = ('contentArea' in opt) ? new Rect(opt.contentArea) : this.getContentArea(opt);\n\n\t        var currentScale = this.scale();\n\t        var currentTranslate = this.translate();\n\t        var sx = currentScale.sx;\n\t        var sy = currentScale.sy;\n\n\t        area.x *= sx;\n\t        area.y *= sy;\n\t        area.width *= sx;\n\t        area.height *= sy;\n\n\t        var calcWidth = Math.max(Math.ceil((area.width + area.x) / gridWidth), 1) * gridWidth;\n\t        var calcHeight = Math.max(Math.ceil((area.height + area.y) / gridHeight), 1) * gridHeight;\n\n\t        var tx = 0;\n\t        var ty = 0;\n\n\t        if ((opt.allowNewOrigin == 'negative' && area.x < 0) || (opt.allowNewOrigin == 'positive' && area.x >= 0) || opt.allowNewOrigin == 'any') {\n\t            tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n\t            tx += padding.left;\n\t            calcWidth += tx;\n\t        }\n\n\t        if ((opt.allowNewOrigin == 'negative' && area.y < 0) || (opt.allowNewOrigin == 'positive' && area.y >= 0) || opt.allowNewOrigin == 'any') {\n\t            ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n\t            ty += padding.top;\n\t            calcHeight += ty;\n\t        }\n\n\t        calcWidth += padding.right;\n\t        calcHeight += padding.bottom;\n\n\t        // Make sure the resulting width and height are greater than minimum.\n\t        calcWidth = Math.max(calcWidth, opt.minWidth || 0);\n\t        calcHeight = Math.max(calcHeight, opt.minHeight || 0);\n\n\t        // Make sure the resulting width and height are lesser than maximum.\n\t        calcWidth = Math.min(calcWidth, opt.maxWidth || Number.MAX_VALUE);\n\t        calcHeight = Math.min(calcHeight, opt.maxHeight || Number.MAX_VALUE);\n\n\t        var computedSize = this.getComputedSize();\n\t        var dimensionChange = calcWidth != computedSize.width || calcHeight != computedSize.height;\n\t        var originChange = tx != currentTranslate.tx || ty != currentTranslate.ty;\n\n\t        // Change the dimensions only if there is a size discrepency or an origin change\n\t        if (originChange) {\n\t            this.translate(tx, ty);\n\t        }\n\t        if (dimensionChange) {\n\t            this.setDimensions(calcWidth, calcHeight);\n\t        }\n\n\t        return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n\t    },\n\n\t    scaleContentToFit: function(opt) {\n\n\t        opt || (opt = {});\n\n\t        var contentBBox, contentLocalOrigin;\n\t        if ('contentArea' in opt) {\n\t            var contentArea = opt.contentArea;\n\t            contentBBox = this.localToPaperRect(contentArea);\n\t            contentLocalOrigin = new Point(contentArea);\n\t        } else {\n\t            contentBBox = this.getContentBBox(opt);\n\t            contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n\t        }\n\n\t        if (!contentBBox.width || !contentBBox.height) { return; }\n\n\t        defaults(opt, {\n\t            padding: 0,\n\t            preserveAspectRatio: true,\n\t            scaleGrid: null,\n\t            minScale: 0,\n\t            maxScale: Number.MAX_VALUE\n\t            //minScaleX\n\t            //minScaleY\n\t            //maxScaleX\n\t            //maxScaleY\n\t            //fittingBBox\n\t        });\n\n\t        var padding = normalizeSides(opt.padding);\n\n\t        var minScaleX = opt.minScaleX || opt.minScale;\n\t        var maxScaleX = opt.maxScaleX || opt.maxScale;\n\t        var minScaleY = opt.minScaleY || opt.minScale;\n\t        var maxScaleY = opt.maxScaleY || opt.maxScale;\n\n\t        var fittingBBox;\n\t        if (opt.fittingBBox) {\n\t            fittingBBox = opt.fittingBBox;\n\t        } else {\n\t            var currentTranslate = this.translate();\n\t            var computedSize = this.getComputedSize();\n\t            fittingBBox = {\n\t                x: currentTranslate.tx,\n\t                y: currentTranslate.ty,\n\t                width: computedSize.width,\n\t                height: computedSize.height\n\t            };\n\t        }\n\n\t        fittingBBox = new Rect(fittingBBox).moveAndExpand({\n\t            x: padding.left,\n\t            y: padding.top,\n\t            width: -padding.left - padding.right,\n\t            height: -padding.top - padding.bottom\n\t        });\n\n\t        var currentScale = this.scale();\n\n\t        var newSx = fittingBBox.width / contentBBox.width * currentScale.sx;\n\t        var newSy = fittingBBox.height / contentBBox.height * currentScale.sy;\n\n\t        if (opt.preserveAspectRatio) {\n\t            newSx = newSy = Math.min(newSx, newSy);\n\t        }\n\n\t        // snap scale to a grid\n\t        if (opt.scaleGrid) {\n\n\t            var gridSize = opt.scaleGrid;\n\n\t            newSx = gridSize * Math.floor(newSx / gridSize);\n\t            newSy = gridSize * Math.floor(newSy / gridSize);\n\t        }\n\n\t        // scale min/max boundaries\n\t        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n\t        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\n\t        var origin = this.options.origin;\n\t        var newOx = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x;\n\t        var newOy = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y;\n\n\t        this.scale(newSx, newSy);\n\t        this.translate(newOx, newOy);\n\t    },\n\n\t    // Return the dimensions of the content area in local units (without transformations).\n\t    getContentArea: function(opt) {\n\n\t        if (opt && opt.useModelGeometry) {\n\t            return this.model.getBBox() || new Rect();\n\t        }\n\n\t        return V(this.cells).getBBox();\n\t    },\n\n\t    // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n\t    getContentBBox: function(opt) {\n\n\t        return this.localToPaperRect(this.getContentArea(opt));\n\t    },\n\n\t    // Returns a geometry rectangle representing the entire\n\t    // paper area (coordinates from the left paper border to the right one\n\t    // and the top border to the bottom one).\n\t    getArea: function() {\n\n\t        return this.paperToLocalRect(this.getComputedSize());\n\t    },\n\n\t    getRestrictedArea: function() {\n\t        var args = [], len = arguments.length;\n\t        while ( len-- ) args[ len ] = arguments[ len ];\n\n\n\t        var ref = this.options;\n\t        var restrictTranslate = ref.restrictTranslate;\n\n\t        var restrictedArea;\n\t        if (isFunction(restrictTranslate)) {\n\t            // A method returning a bounding box\n\t            restrictedArea = restrictTranslate.apply(this, args);\n\t        } else if (restrictTranslate === true) {\n\t            // The paper area\n\t            restrictedArea = this.getArea();\n\t        } else if (!restrictTranslate) {\n\t            // falsy value\n\t            restrictedArea = null;\n\t        } else {\n\t            // any other value\n\t            restrictedArea = new Rect(restrictTranslate);\n\t        }\n\n\t        return restrictedArea;\n\t    },\n\n\t    createViewForModel: function(cell) {\n\n\t        // A class taken from the paper options.\n\t        var optionalViewClass;\n\n\t        // A default basic class (either dia.ElementView or dia.LinkView)\n\t        var defaultViewClass;\n\n\t        // A special class defined for this model in the corresponding namespace.\n\t        // e.g. joint.shapes.basic.Rect searches for joint.shapes.basic.RectView\n\t        var namespace = this.options.cellViewNamespace;\n\t        var type = cell.get('type') + 'View';\n\t        var namespaceViewClass = getByPath(namespace, type, '.');\n\n\t        if (cell.isLink()) {\n\t            optionalViewClass = this.options.linkView;\n\t            defaultViewClass = LinkView;\n\t        } else {\n\t            optionalViewClass = this.options.elementView;\n\t            defaultViewClass = ElementView;\n\t        }\n\n\t        // a) the paper options view is a class (deprecated)\n\t        //  1. search the namespace for a view\n\t        //  2. if no view was found, use view from the paper options\n\t        // b) the paper options view is a function\n\t        //  1. call the function from the paper options\n\t        //  2. if no view was return, search the namespace for a view\n\t        //  3. if no view was found, use the default\n\t        var ViewClass = (optionalViewClass.prototype instanceof Backbone.View)\n\t            ? namespaceViewClass || optionalViewClass\n\t            : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\n\t        return new ViewClass({\n\t            model: cell,\n\t            interactive: this.options.interactive\n\t        });\n\t    },\n\n\t    removeView: function(cell) {\n\n\t        var id = cell.id;\n\t        var ref = this;\n\t        var _views = ref._views;\n\t        var _updates = ref._updates;\n\t        var view = _views[id];\n\t        if (view) {\n\t            var cid = view.cid;\n\t            var mounted = _updates.mounted;\n\t            var unmounted = _updates.unmounted;\n\t            view.remove();\n\t            delete _views[id];\n\t            delete mounted[cid];\n\t            delete unmounted[cid];\n\t        }\n\t        return view;\n\t    },\n\n\t    renderView: function(cell, opt) {\n\n\t        var id = cell.id;\n\t        var views = this._views;\n\t        var view, flag;\n\t        if (id in views) {\n\t            view = views[id];\n\t            flag = view.FLAG_INSERT;\n\t        } else {\n\t            view = views[cell.id] = this.createViewForModel(cell);\n\t            view.paper = this;\n\t            flag = this.registerUnmountedView(view) | view.getFlag(view.initFlag);\n\t        }\n\t        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n\t        return view;\n\t    },\n\n\t    onImageDragStart: function() {\n\t        // This is the only way to prevent image dragging in Firefox that works.\n\t        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n\t        return false;\n\t    },\n\n\t    resetViews: function(cells, opt) {\n\t        opt || (opt = {});\n\t        cells || (cells = []);\n\t        this._resetUpdates();\n\t        // clearing views removes any event listeners\n\t        this.removeViews();\n\t        this.freeze({ key: 'reset' });\n\t        for (var i = 0, n = cells.length; i < n; i++) {\n\t            this.renderView(cells[i], opt);\n\t        }\n\t        this.unfreeze({ key: 'reset' });\n\t        this.sortViews();\n\t    },\n\n\t    removeViews: function() {\n\n\t        invoke(this._views, 'remove');\n\n\t        this._views = {};\n\t    },\n\n\t    sortViews: function() {\n\n\t        if (!this.isExactSorting()) {\n\t            // noop\n\t            return;\n\t        }\n\t        if (this.isFrozen()) {\n\t            // sort views once unfrozen\n\t            this._updates.sort = true;\n\t            return;\n\t        }\n\t        this.sortViewsExact();\n\t    },\n\n\t    sortViewsExact: function() {\n\n\t        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n\t        // associated model `z` attribute.\n\n\t        var $cells = $(this.cells).children('[model-id]');\n\t        var cells = this.model.get('cells');\n\n\t        sortElements($cells, function(a, b) {\n\t            var cellA = cells.get(a.getAttribute('model-id'));\n\t            var cellB = cells.get(b.getAttribute('model-id'));\n\t            var zA = cellA.attributes.z || 0;\n\t            var zB = cellB.attributes.z || 0;\n\t            return (zA === zB) ? 0 : (zA < zB) ? -1 : 1;\n\t        });\n\t    },\n\n\n\t    insertView: function(view) {\n\t        var layer = this.cells;\n\t        switch (this.options.sorting) {\n\t            case sortingTypes.APPROX:\n\t                var z = view.model.get('z');\n\t                var pivot = this.addZPivot(z);\n\t                layer.insertBefore(view.el, pivot);\n\t                break;\n\t            case sortingTypes.EXACT:\n\t            default:\n\t                layer.appendChild(view.el);\n\t                break;\n\t        }\n\t    },\n\n\t    addZPivot: function(z) {\n\t        z = +z;\n\t        z || (z = 0);\n\t        var pivots = this._zPivots;\n\t        var pivot = pivots[z];\n\t        if (pivot) { return pivot; }\n\t        pivot = pivots[z] = document.createComment('z-index:' + (z + 1));\n\t        var neighborZ = -Infinity;\n\t        for (var currentZ in pivots) {\n\t            currentZ = +currentZ;\n\t            if (currentZ < z && currentZ > neighborZ) {\n\t                neighborZ = currentZ;\n\t                if (neighborZ === z - 1) { continue; }\n\t            }\n\t        }\n\t        var layer = this.cells;\n\t        if (neighborZ !== -Infinity) {\n\t            var neighborPivot = pivots[neighborZ];\n\t            // Insert After\n\t            layer.insertBefore(pivot, neighborPivot.nextSibling);\n\t        } else {\n\t            // First Child\n\t            layer.insertBefore(pivot, layer.firstChild);\n\t        }\n\t        return pivot;\n\t    },\n\n\t    removeZPivots: function() {\n\t        var ref = this;\n\t        var pivots = ref._zPivots;\n\t        var viewport = ref.viewport;\n\t        for (var z in pivots) { viewport.removeChild(pivots[z]); }\n\t        this._zPivots = {};\n\t    },\n\n\t    scale: function(sx, sy, ox, oy) {\n\n\t        // getter\n\t        if (sx === undefined) {\n\t            return V.matrixToScale(this.matrix());\n\t        }\n\n\t        // setter\n\t        if (sy === undefined) {\n\t            sy = sx;\n\t        }\n\t        if (ox === undefined) {\n\t            ox = 0;\n\t            oy = 0;\n\t        }\n\n\t        var translate = this.translate();\n\n\t        if (ox || oy || translate.tx || translate.ty) {\n\t            var newTx = translate.tx - ox * (sx - 1);\n\t            var newTy = translate.ty - oy * (sy - 1);\n\t            this.translate(newTx, newTy);\n\t        }\n\n\t        sx = Math.max(sx || 0, this.MIN_SCALE);\n\t        sy = Math.max(sy || 0, this.MIN_SCALE);\n\n\t        var ctm = this.matrix();\n\t        ctm.a = sx;\n\t        ctm.d = sy;\n\n\t        this.matrix(ctm);\n\n\t        this.trigger('scale', sx, sy, ox, oy);\n\n\t        return this;\n\t    },\n\n\t    // Experimental - do not use in production.\n\t    rotate: function(angle, cx, cy) {\n\n\t        // getter\n\t        if (angle === undefined) {\n\t            return V.matrixToRotate(this.matrix());\n\t        }\n\n\t        // setter\n\n\t        // If the origin is not set explicitely, rotate around the center. Note that\n\t        // we must use the plain bounding box (`this.el.getBBox()` instead of the one that gives us\n\t        // the real bounding box (`bbox()`) including transformations).\n\t        if (cx === undefined) {\n\t            var bbox = this.cells.getBBox();\n\t            cx = bbox.width / 2;\n\t            cy = bbox.height / 2;\n\t        }\n\n\t        var ctm = this.matrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);\n\t        this.matrix(ctm);\n\n\t        return this;\n\t    },\n\n\t    translate: function(tx, ty) {\n\n\t        // getter\n\t        if (tx === undefined) {\n\t            return V.matrixToTranslate(this.matrix());\n\t        }\n\n\t        // setter\n\n\t        var ctm = this.matrix();\n\t        ctm.e = tx || 0;\n\t        ctm.f = ty || 0;\n\n\t        this.matrix(ctm);\n\n\t        var newTranslate = this.translate();\n\t        var origin = this.options.origin;\n\t        origin.x = newTranslate.tx;\n\t        origin.y = newTranslate.ty;\n\n\t        this.trigger('translate', newTranslate.tx, newTranslate.ty);\n\n\t        if (this.options.drawGrid) {\n\t            this.drawGrid();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n\t    // be a selector or a jQuery object.\n\t    findView: function($el) {\n\n\t        var el = isString($el)\n\t            ? this.cells.querySelector($el)\n\t            : $el instanceof $ ? $el[0] : $el;\n\n\t        var id = this.findAttribute('model-id', el);\n\t        if (id) { return this._views[id]; }\n\n\t        return undefined;\n\t    },\n\n\t    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n\t    findViewByModel: function(cell) {\n\n\t        var id = (isString(cell) || isNumber(cell)) ? cell : (cell && cell.id);\n\n\t        return this._views[id];\n\t    },\n\n\t    // Find all views at given point\n\t    findViewsFromPoint: function(p) {\n\n\t        p = new Point(p);\n\n\t        var views = this.model.getElements().map(this.findViewByModel, this);\n\n\t        return views.filter(function(view) {\n\t            return view && view.vel.getBBox({ target: this.cells }).containsPoint(p);\n\t        }, this);\n\t    },\n\n\t    // Find all views in given area\n\t    findViewsInArea: function(rect, opt) {\n\n\t        opt = defaults(opt || {}, { strict: false });\n\t        rect = new Rect(rect);\n\n\t        var views = this.model.getElements().map(this.findViewByModel, this);\n\t        var method = opt.strict ? 'containsRect' : 'intersect';\n\n\t        return views.filter(function(view) {\n\t            return view && rect[method](view.vel.getBBox({ target: this.cells }));\n\t        }, this);\n\t    },\n\n\t    removeTools: function() {\n\t        this.dispatchToolsEvent('remove');\n\t        return this;\n\t    },\n\n\t    hideTools: function() {\n\t        this.dispatchToolsEvent('hide');\n\t        return this;\n\t    },\n\n\t    showTools: function() {\n\t        this.dispatchToolsEvent('show');\n\t        return this;\n\t    },\n\n\t    dispatchToolsEvent: function(event) {\n\t        var ref;\n\n\t        var args = [], len = arguments.length - 1;\n\t        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t        if (typeof event !== 'string') { return; }\n\t        (ref = this).trigger.apply(ref, [ 'tools:event', event ].concat( args ));\n\t    },\n\n\n\t    getModelById: function(id) {\n\n\t        return this.model.getCell(id);\n\t    },\n\n\t    snapToGrid: function(x, y) {\n\n\t        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n\t        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n\t        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n\t    },\n\n\t    localToPaperPoint: function(x, y) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var localPoint = new Point(x, y);\n\t        var paperPoint = V.transformPoint(localPoint, this.matrix());\n\t        return paperPoint;\n\t    },\n\n\t    localToPaperRect: function(x, y, width, height) {\n\t        // allow `x` to be a rectangle and rest arguments undefined\n\t        var localRect = new Rect(x, y, width, height);\n\t        var paperRect = V.transformRect(localRect, this.matrix());\n\t        return paperRect;\n\t    },\n\n\t    paperToLocalPoint: function(x, y) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var paperPoint = new Point(x, y);\n\t        var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n\t        return localPoint;\n\t    },\n\n\t    paperToLocalRect: function(x, y, width, height) {\n\t        // allow `x` to be a rectangle and rest arguments undefined\n\t        var paperRect = new Rect(x, y, width, height);\n\t        var localRect = V.transformRect(paperRect, this.matrix().inverse());\n\t        return localRect;\n\t    },\n\n\t    localToClientPoint: function(x, y) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var localPoint = new Point(x, y);\n\t        var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n\t        return clientPoint;\n\t    },\n\n\t    localToClientRect: function(x, y, width, height) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var localRect = new Rect(x, y, width, height);\n\t        var clientRect = V.transformRect(localRect, this.clientMatrix());\n\t        return clientRect;\n\t    },\n\n\t    // Transform client coordinates to the paper local coordinates.\n\t    // Useful when you have a mouse event object and you'd like to get coordinates\n\t    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n\t    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n\t    clientToLocalPoint: function(x, y) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var clientPoint = new Point(x, y);\n\t        var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n\t        return localPoint;\n\t    },\n\n\t    clientToLocalRect: function(x, y, width, height) {\n\t        // allow `x` to be a point and `y` undefined\n\t        var clientRect = new Rect(x, y, width, height);\n\t        var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n\t        return localRect;\n\t    },\n\n\t    localToPagePoint: function(x, y) {\n\n\t        return this.localToPaperPoint(x, y).offset(this.pageOffset());\n\t    },\n\n\t    localToPageRect: function(x, y, width, height) {\n\n\t        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n\t    },\n\n\t    pageToLocalPoint: function(x, y) {\n\n\t        var pagePoint = new Point(x, y);\n\t        var paperPoint = pagePoint.difference(this.pageOffset());\n\t        return this.paperToLocalPoint(paperPoint);\n\t    },\n\n\t    pageToLocalRect: function(x, y, width, height) {\n\n\t        var pageOffset = this.pageOffset();\n\t        var paperRect = new Rect(x, y, width, height);\n\t        paperRect.x -= pageOffset.x;\n\t        paperRect.y -= pageOffset.y;\n\t        return this.paperToLocalRect(paperRect);\n\t    },\n\n\t    clientOffset: function() {\n\n\t        var clientRect = this.svg.getBoundingClientRect();\n\t        return new Point(clientRect.left, clientRect.top);\n\t    },\n\n\t    pageOffset: function() {\n\n\t        return this.clientOffset().offset(window.scrollX, window.scrollY);\n\t    },\n\n\t    linkAllowed: function(linkView) {\n\n\t        if (!(linkView instanceof LinkView)) {\n\t            throw new Error('Must provide a linkView.');\n\t        }\n\n\t        var link = linkView.model;\n\t        var paperOptions = this.options;\n\t        var graph = this.model;\n\t        var ns = graph.constructor.validations;\n\n\t        if (!paperOptions.multiLinks) {\n\t            if (!ns.multiLinks.call(this, graph, link)) { return false; }\n\t        }\n\n\t        if (!paperOptions.linkPinning) {\n\t            // Link pinning is not allowed and the link is not connected to the target.\n\t            if (!ns.linkPinning.call(this, graph, link)) { return false; }\n\t        }\n\n\t        if (typeof paperOptions.allowLink === 'function') {\n\t            if (!paperOptions.allowLink.call(this, linkView, this)) { return false; }\n\t        }\n\n\t        return true;\n\t    },\n\n\t    getDefaultLink: function(cellView, magnet) {\n\n\t        return isFunction(this.options.defaultLink)\n\t        // default link is a function producing link model\n\t            ? this.options.defaultLink.call(this, cellView, magnet)\n\t        // default link is the Backbone model\n\t            : this.options.defaultLink.clone();\n\t    },\n\n\t    // Cell highlighting.\n\t    // ------------------\n\n\t    resolveHighlighter: function(opt) {\n\t        if ( opt === void 0 ) opt = {};\n\n\n\t        var highlighterDef = opt.highlighter;\n\t        var type = opt.type;\n\t        var ref = this.options;\n\t        var highlighting = ref.highlighting;\n\t        var highlighterNamespace = ref.highlighterNamespace;\n\n\t        /*\n\t            Expecting opt.highlighter to have the following structure:\n\t            {\n\t                name: 'highlighter-name',\n\t                options: {\n\t                    some: 'value'\n\t                }\n\t            }\n\t        */\n\t        if (highlighterDef === undefined) {\n\n\t            // Is highlighting disabled?\n\t            if (!highlighting) { return false; }\n\t            // check for built-in types\n\t            if (type) {\n\t                highlighterDef = highlighting[type];\n\t                // Is a specific type highlight disabled?\n\t                if (highlighterDef === false) { return false; }\n\t            }\n\t            if (!highlighterDef) {\n\t                // Type not defined use default highlight\n\t                highlighterDef = highlighting['default'];\n\t            }\n\t        }\n\n\t        // Do nothing if opt.highlighter is falsy.\n\t        // This allows the case to not highlight cell(s) in certain cases.\n\t        // For example, if you want to NOT highlight when embedding elements\n\t        // or use a custom highlighter.\n\t        if (!highlighterDef) { return false; }\n\n\t        // Allow specifying a highlighter by name.\n\t        if (isString(highlighterDef)) {\n\t            highlighterDef = {\n\t                name: highlighterDef\n\t            };\n\t        }\n\n\t        var name = highlighterDef.name;\n\t        var highlighter = highlighterNamespace[name];\n\n\t        // Highlighter validation\n\t        if (!highlighter) {\n\t            throw new Error('Unknown highlighter (\"' + name + '\")');\n\t        }\n\t        if (typeof highlighter.highlight !== 'function') {\n\t            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n\t        }\n\t        if (typeof highlighter.unhighlight !== 'function') {\n\t            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n\t        }\n\n\t        return {\n\t            highlighter: highlighter,\n\t            options: highlighterDef.options || {},\n\t            name: name\n\t        };\n\t    },\n\n\t    onCellHighlight: function(cellView, magnetEl, opt) {\n\t        var highlighterDescriptor = this.resolveHighlighter(opt);\n\t        if (!highlighterDescriptor) { return; }\n\t        var highlighter = highlighterDescriptor.highlighter;\n\t        var options = highlighterDescriptor.options;\n\t        highlighter.highlight(cellView, magnetEl, options);\n\t    },\n\n\t    onCellUnhighlight: function(cellView, magnetEl, opt) {\n\t        var highlighterDescriptor = this.resolveHighlighter(opt);\n\t        if (!highlighterDescriptor) { return; }\n\t        var highlighter = highlighterDescriptor.highlighter;\n\t        var options = highlighterDescriptor.options;\n\t        highlighter.unhighlight(cellView, magnetEl, options);\n\t    },\n\n\t    // Interaction.\n\t    // ------------\n\n\t    pointerdblclick: function(evt) {\n\n\t        evt.preventDefault();\n\n\t        // magnetpointerdblclick can stop propagation\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t        if (view) {\n\t            view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\n\t        } else {\n\t            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n\t        }\n\t    },\n\n\t    pointerclick: function(evt) {\n\n\t        // magnetpointerclick can stop propagation\n\n\t        var data = this.eventData(evt);\n\t        // Trigger event only if mouse has not moved.\n\t        if (data.mousemoved <= this.options.clickThreshold) {\n\n\t            evt = normalizeEvent(evt);\n\n\t            var view = this.findView(evt.target);\n\t            if (this.guard(evt, view)) { return; }\n\n\t            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t            if (view) {\n\t                view.pointerclick(evt, localPoint.x, localPoint.y);\n\n\t            } else {\n\t                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n\t            }\n\t        }\n\t    },\n\n\t    contextmenu: function(evt) {\n\n\t        if (this.options.preventContextMenu) { evt.preventDefault(); }\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t        if (view) {\n\t            view.contextmenu(evt, localPoint.x, localPoint.y);\n\n\t        } else {\n\t            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n\t        }\n\t    },\n\n\t    pointerdown: function(evt) {\n\n\t        // onmagnet stops propagation when `addLinkFromMagnet` is allowed\n\t        // onevent can stop propagation\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t        if (view) {\n\n\t            evt.preventDefault();\n\t            view.pointerdown(evt, localPoint.x, localPoint.y);\n\n\t        } else {\n\n\t            if (this.options.preventDefaultBlankAction) { evt.preventDefault(); }\n\n\t            this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n\t        }\n\n\t        this.delegateDragEvents(view, evt.data);\n\t    },\n\n\t    pointermove: function(evt) {\n\n\t        // mouse moved counter\n\t        var data = this.eventData(evt);\n\t        data.mousemoved || (data.mousemoved = 0);\n\t        var mousemoved = ++data.mousemoved;\n\n\t        if (mousemoved <= this.options.moveThreshold) { return; }\n\n\t        evt = normalizeEvent(evt);\n\n\t        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n\t        var view = data.sourceView;\n\t        if (view) {\n\t            view.pointermove(evt, localPoint.x, localPoint.y);\n\t        } else {\n\t            this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n\t        }\n\n\t        this.eventData(evt, data);\n\t    },\n\n\t    pointerup: function(evt) {\n\n\t        this.undelegateDocumentEvents();\n\n\t        var normalizedEvt = normalizeEvent(evt);\n\n\t        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\n\t        var view = this.eventData(evt).sourceView;\n\t        if (view) {\n\t            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n\t        } else {\n\t            this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n\t        }\n\n\t        if (!normalizedEvt.isPropagationStopped()) {\n\t            this.pointerclick($.Event(evt, { type: 'click', data: evt.data }));\n\t        }\n\n\t        evt.stopImmediatePropagation();\n\t        this.delegateEvents();\n\t    },\n\n\t    mouseover: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        if (view) {\n\t            view.mouseover(evt);\n\n\t        } else {\n\t            if (this.el === evt.target) { return; } // prevent border of paper from triggering this\n\t            this.trigger('blank:mouseover', evt);\n\t        }\n\t    },\n\n\t    mouseout: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        if (view) {\n\t            view.mouseout(evt);\n\n\t        } else {\n\t            if (this.el === evt.target) { return; } // prevent border of paper from triggering this\n\t            this.trigger('blank:mouseout', evt);\n\t        }\n\t    },\n\n\t    mouseenter: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\t        var relatedView = this.findView(evt.relatedTarget);\n\t        if (view) {\n\t            // mouse moved from tool over view?\n\t            if (relatedView === view) { return; }\n\t            view.mouseenter(evt);\n\t        } else {\n\t            if (relatedView) { return; }\n\t            // `paper` (more descriptive), not `blank`\n\t            this.trigger('paper:mouseenter', evt);\n\t        }\n\t    },\n\n\t    mouseleave: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\t        var relatedView = this.findView(evt.relatedTarget);\n\t        if (view) {\n\t            // mouse moved from view over tool?\n\t            if (relatedView === view) { return; }\n\t            view.mouseleave(evt);\n\t        } else {\n\t            if (relatedView) { return; }\n\t            // `paper` (more descriptive), not `blank`\n\t            this.trigger('paper:mouseleave', evt);\n\t        }\n\t    },\n\n\t    mousewheel: function(evt) {\n\n\t        evt = normalizeEvent(evt);\n\n\t        var view = this.findView(evt.target);\n\t        if (this.guard(evt, view)) { return; }\n\n\t        var originalEvent = evt.originalEvent;\n\t        var localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n\t        var delta = Math.max(-1, Math.min(1, (originalEvent.wheelDelta || -originalEvent.detail)));\n\n\t        if (view) {\n\t            view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\n\t        } else {\n\t            this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n\t        }\n\t    },\n\n\t    onevent: function(evt) {\n\n\t        var eventNode = evt.currentTarget;\n\t        var eventName = eventNode.getAttribute('event');\n\t        if (eventName) {\n\t            var view = this.findView(eventNode);\n\t            if (view) {\n\n\t                evt = normalizeEvent(evt);\n\t                if (this.guard(evt, view)) { return; }\n\n\t                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t                view.onevent(evt, eventName, localPoint.x, localPoint.y);\n\t            }\n\t        }\n\t    },\n\n\t    magnetEvent: function(evt, handler) {\n\n\t        var magnetNode = evt.currentTarget;\n\t        var magnetValue = magnetNode.getAttribute('magnet');\n\t        if (magnetValue) {\n\t            var view = this.findView(magnetNode);\n\t            if (view) {\n\t                evt = normalizeEvent(evt);\n\t                if (this.guard(evt, view)) { return; }\n\t                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n\t            }\n\t        }\n\t    },\n\n\t    onmagnet: function(evt) {\n\n\t        this.magnetEvent(evt, function(view, evt, _, x, y) {\n\t            view.onmagnet(evt, x, y);\n\t        });\n\t    },\n\n\n\t    magnetpointerdblclick: function(evt) {\n\n\t        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n\t            view.magnetpointerdblclick(evt, magnet, x, y);\n\t        });\n\t    },\n\n\t    magnetcontextmenu: function(evt) {\n\n\t        if (this.options.preventContextMenu) { evt.preventDefault(); }\n\t        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n\t            view.magnetcontextmenu(evt, magnet, x, y);\n\t        });\n\t    },\n\n\t    onlabel: function(evt) {\n\n\t        var labelNode = evt.currentTarget;\n\t        var view = this.findView(labelNode);\n\t        if (view) {\n\n\t            evt = normalizeEvent(evt);\n\t            if (this.guard(evt, view)) { return; }\n\n\t            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\t            view.onlabel(evt, localPoint.x, localPoint.y);\n\t        }\n\t    },\n\n\t    getPointerArgs: function getPointerArgs(evt) {\n\t        var normalizedEvt = normalizeEvent(evt);\n\t        var ref = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\t        var x = ref.x;\n\t        var y = ref.y;\n\t        return [normalizedEvt, x, y];\n\t    },\n\n\t    delegateDragEvents: function(view, data) {\n\n\t        data || (data = {});\n\t        this.eventData({ data: data }, { sourceView: view || null, mousemoved: 0 });\n\t        this.delegateDocumentEvents(null, data);\n\t        this.undelegateEvents();\n\t    },\n\n\t    // Guard the specified event. If the event is not interesting, guard returns `true`.\n\t    // Otherwise, it returns `false`.\n\t    guard: function(evt, view) {\n\n\t        if (evt.type === 'mousedown' && evt.button === 2) {\n\t            // handled as `contextmenu` type\n\t            return true;\n\t        }\n\n\t        if (this.options.guard && this.options.guard(evt, view)) {\n\t            return true;\n\t        }\n\n\t        if (evt.data && evt.data.guarded !== undefined) {\n\t            return evt.data.guarded;\n\t        }\n\n\t        if (view && view.model && (view.model instanceof Cell)) {\n\t            return false;\n\t        }\n\n\t        if (this.svg === evt.target || this.el === evt.target || $.contains(this.svg, evt.target)) {\n\t            return false;\n\t        }\n\n\t        return true;    // Event guarded. Paper should not react on it in any way.\n\t    },\n\n\t    setGridSize: function(gridSize) {\n\n\t        this.options.gridSize = gridSize;\n\n\t        if (this.options.drawGrid) {\n\t            this.drawGrid();\n\t        }\n\n\t        return this;\n\t    },\n\n\t    clearGrid: function() {\n\n\t        if (this.$grid) {\n\t            this.$grid.css('backgroundImage', 'none');\n\t        }\n\t        return this;\n\t    },\n\n\t    _getGridRefs: function() {\n\n\t        if (!this._gridCache) {\n\n\t            this._gridCache = {\n\t                root: V('svg', { width: '100%', height: '100%' }, V('defs')),\n\t                patterns: {},\n\t                add: function(id, vel) {\n\t                    V(this.root.node.childNodes[0]).append(vel);\n\t                    this.patterns[id] = vel;\n\t                    this.root.append(V('rect', { width: '100%', height: '100%', fill: 'url(#' + id + ')' }));\n\t                },\n\t                get: function(id) {\n\t                    return this.patterns[id];\n\t                },\n\t                exist: function(id) {\n\t                    return this.patterns[id] !== undefined;\n\t                }\n\t            };\n\t        }\n\n\t        return this._gridCache;\n\t    },\n\n\t    setGrid: function(drawGrid) {\n\n\t        this.clearGrid();\n\n\t        this._gridCache = null;\n\t        this._gridSettings = [];\n\n\t        var optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n\t        optionsList.forEach(function(item) {\n\t            this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(item));\n\t        }, this);\n\t        return this;\n\t    },\n\n\t    _resolveDrawGridOption: function(opt) {\n\n\t        var namespace = this.constructor.gridPatterns;\n\t        if (isString(opt) && Array.isArray(namespace[opt])) {\n\t            return namespace[opt].map(function(item) {\n\t                return assign({}, item);\n\t            });\n\t        }\n\n\t        var options = opt || { args: [{}] };\n\t        var isArray = Array.isArray(options);\n\t        var name = options.name;\n\n\t        if (!isArray && !name && !options.markup) {\n\t            name = 'dot';\n\t        }\n\n\t        if (name && Array.isArray(namespace[name])) {\n\t            var pattern = namespace[name].map(function(item) {\n\t                return assign({}, item);\n\t            });\n\n\t            var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\n\t            defaults(args[0], omit(opt, 'args'));\n\t            for (var i = 0; i < args.length; i++) {\n\t                if (pattern[i]) {\n\t                    assign(pattern[i], args[i]);\n\t                }\n\t            }\n\t            return pattern;\n\t        }\n\n\t        return isArray ? options : [options];\n\t    },\n\n\t    drawGrid: function(opt) {\n\n\t        var gridSize = this.options.gridSize;\n\t        if (gridSize <= 1) {\n\t            return this.clearGrid();\n\t        }\n\n\t        var localOptions = Array.isArray(opt) ? opt : [opt];\n\n\t        var ctm = this.matrix();\n\t        var refs = this._getGridRefs();\n\n\t        this._gridSettings.forEach(function(gridLayerSetting, index) {\n\n\t            var id = 'pattern_' + index;\n\t            var options = merge(gridLayerSetting, localOptions[index], {\n\t                sx: ctm.a || 1,\n\t                sy: ctm.d || 1,\n\t                ox: ctm.e || 0,\n\t                oy: ctm.f || 0\n\t            });\n\n\t            options.width = gridSize * (ctm.a || 1) * (options.scaleFactor || 1);\n\t            options.height = gridSize * (ctm.d || 1) * (options.scaleFactor || 1);\n\n\t            if (!refs.exist(id)) {\n\t                refs.add(id, V('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, V(options.markup)));\n\t            }\n\n\t            var patternDefVel = refs.get(id);\n\n\t            if (isFunction(options.update)) {\n\t                options.update(patternDefVel.node.childNodes[0], options);\n\t            }\n\n\t            var x = options.ox % options.width;\n\t            if (x < 0) { x += options.width; }\n\n\t            var y = options.oy % options.height;\n\t            if (y < 0) { y += options.height; }\n\n\t            patternDefVel.attr({\n\t                x: x,\n\t                y: y,\n\t                width: options.width,\n\t                height: options.height\n\t            });\n\t        });\n\n\t        var patternUri = new XMLSerializer().serializeToString(refs.root.node);\n\t        patternUri = 'url(data:image/svg+xml;base64,' + btoa(patternUri) + ')';\n\n\t        this.$grid.css('backgroundImage', patternUri);\n\n\t        return this;\n\t    },\n\n\t    updateBackgroundImage: function(opt) {\n\n\t        opt = opt || {};\n\n\t        var backgroundPosition = opt.position || 'center';\n\t        var backgroundSize = opt.size || 'auto auto';\n\n\t        var currentScale = this.scale();\n\t        var currentTranslate = this.translate();\n\n\t        // backgroundPosition\n\t        if (isObject$1(backgroundPosition)) {\n\t            var x = currentTranslate.tx + (currentScale.sx * (backgroundPosition.x || 0));\n\t            var y = currentTranslate.ty + (currentScale.sy * (backgroundPosition.y || 0));\n\t            backgroundPosition = x + 'px ' + y + 'px';\n\t        }\n\n\t        // backgroundSize\n\t        if (isObject$1(backgroundSize)) {\n\t            backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n\t            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n\t        }\n\n\t        this.$background.css({\n\t            backgroundSize: backgroundSize,\n\t            backgroundPosition: backgroundPosition\n\t        });\n\t    },\n\n\t    drawBackgroundImage: function(img, opt) {\n\n\t        // Clear the background image if no image provided\n\t        if (!(img instanceof HTMLImageElement)) {\n\t            this.$background.css('backgroundImage', '');\n\t            return;\n\t        }\n\n\t        opt = opt || {};\n\n\t        var backgroundImage;\n\t        var backgroundSize = opt.size;\n\t        var backgroundRepeat = opt.repeat || 'no-repeat';\n\t        var backgroundOpacity = opt.opacity || 1;\n\t        var backgroundQuality = Math.abs(opt.quality) || 1;\n\t        var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n\n\t        if (isFunction(backgroundPattern)) {\n\t            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n\t            img.width *= backgroundQuality;\n\t            img.height *= backgroundQuality;\n\t            var canvas = backgroundPattern(img, opt);\n\t            if (!(canvas instanceof HTMLCanvasElement)) {\n\t                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n\t            }\n\n\t            backgroundImage = canvas.toDataURL('image/png');\n\t            backgroundRepeat = 'repeat';\n\t            if (isObject$1(backgroundSize)) {\n\t                // recalculate the tile size if an object passed in\n\t                backgroundSize.width *= canvas.width / img.width;\n\t                backgroundSize.height *= canvas.height / img.height;\n\t            } else if (backgroundSize === undefined) {\n\t                // calculate the tile size if no provided\n\t                opt.size = {\n\t                    width: canvas.width / backgroundQuality,\n\t                    height: canvas.height / backgroundQuality\n\t                };\n\t            }\n\t        } else {\n\t            // backgroundRepeat:\n\t            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n\t            backgroundImage = img.src;\n\t            if (backgroundSize === undefined) {\n\t                // pass the image size for  the backgroundSize if no size provided\n\t                opt.size = {\n\t                    width: img.width,\n\t                    height: img.height\n\t                };\n\t            }\n\t        }\n\n\t        this.$background.css({\n\t            opacity: backgroundOpacity,\n\t            backgroundRepeat: backgroundRepeat,\n\t            backgroundImage: 'url(' + backgroundImage + ')'\n\t        });\n\n\t        this.updateBackgroundImage(opt);\n\t    },\n\n\t    updateBackgroundColor: function(color) {\n\n\t        this.$el.css('backgroundColor', color || '');\n\t    },\n\n\t    drawBackground: function(opt) {\n\n\t        opt = opt || {};\n\n\t        this.updateBackgroundColor(opt.color);\n\n\t        if (opt.image) {\n\t            opt = this._background = cloneDeep(opt);\n\t            var img = document.createElement('img');\n\t            img.onload = this.drawBackgroundImage.bind(this, img, opt);\n\t            img.src = opt.image;\n\t        } else {\n\t            this.drawBackgroundImage(null);\n\t            this._background = null;\n\t        }\n\n\t        return this;\n\t    },\n\n\t    setInteractivity: function(value) {\n\n\t        this.options.interactive = value;\n\n\t        invoke(this._views, 'setInteractivity', value);\n\t    },\n\n\t    // Paper definitions.\n\t    // ------------------\n\n\t    isDefined: function(defId) {\n\n\t        return !!this.svg.getElementById(defId);\n\t    },\n\n\t    defineFilter: function(filter$1) {\n\n\t        if (!isObject$1(filter$1)) {\n\t            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n\t        }\n\n\t        var filterId = filter$1.id;\n\t        var name = filter$1.name;\n\t        // Generate a hash code from the stringified filter definition. This gives us\n\t        // a unique filter ID for different definitions.\n\t        if (!filterId) {\n\t            filterId = name + this.svg.id + hashCode(JSON.stringify(filter$1));\n\t        }\n\t        // If the filter already exists in the document,\n\t        // we're done and we can just use it (reference it using `url()`).\n\t        // If not, create one.\n\t        if (!this.isDefined(filterId)) {\n\n\t            var namespace = filter;\n\t            var filterSVGString = namespace[name] && namespace[name](filter$1.args || {});\n\t            if (!filterSVGString) {\n\t                throw new Error('Non-existing filter ' + name);\n\t            }\n\n\t            // Set the filter area to be 3x the bounding box of the cell\n\t            // and center the filter around the cell.\n\t            var filterAttrs = assign({\n\t                filterUnits: 'objectBoundingBox',\n\t                x: -1,\n\t                y: -1,\n\t                width: 3,\n\t                height: 3\n\t            }, filter$1.attrs, {\n\t                id: filterId\n\t            });\n\n\t            V(filterSVGString, filterAttrs).appendTo(this.defs);\n\t        }\n\n\t        return filterId;\n\t    },\n\n\t    defineGradient: function(gradient) {\n\n\t        if (!isObject$1(gradient)) {\n\t            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n\t        }\n\n\t        var gradientId = gradient.id;\n\t        var type = gradient.type;\n\t        var stops = gradient.stops;\n\t        // Generate a hash code from the stringified filter definition. This gives us\n\t        // a unique filter ID for different definitions.\n\t        if (!gradientId) {\n\t            gradientId = type + this.svg.id + hashCode(JSON.stringify(gradient));\n\t        }\n\t        // If the gradient already exists in the document,\n\t        // we're done and we can just use it (reference it using `url()`).\n\t        // If not, create one.\n\t        if (!this.isDefined(gradientId)) {\n\n\t            var stopTemplate = template('<stop offset=\"${offset}\" stop-color=\"${color}\" stop-opacity=\"${opacity}\"/>');\n\t            var gradientStopsStrings = toArray(stops).map(function(stop) {\n\t                return stopTemplate({\n\t                    offset: stop.offset,\n\t                    color: stop.color,\n\t                    opacity: Number.isFinite(stop.opacity) ? stop.opacity : 1\n\t                });\n\t            });\n\n\t            var gradientSVGString = [\n\t                '<' + type + '>',\n\t                gradientStopsStrings.join(''),\n\t                '</' + type + '>'\n\t            ].join('');\n\n\t            var gradientAttrs = assign({ id: gradientId }, gradient.attrs);\n\n\t            V(gradientSVGString, gradientAttrs).appendTo(this.defs);\n\t        }\n\n\t        return gradientId;\n\t    },\n\n\t    defineMarker: function(marker) {\n\n\t        if (!isObject$1(marker)) {\n\t            throw new TypeError('dia.Paper: defineMarker() requires 1. argument to be an object.');\n\t        }\n\n\t        var markerId = marker.id;\n\n\t        // Generate a hash code from the stringified filter definition. This gives us\n\t        // a unique filter ID for different definitions.\n\t        if (!markerId) {\n\t            markerId = this.svg.id + hashCode(JSON.stringify(marker));\n\t        }\n\n\t        if (!this.isDefined(markerId)) {\n\n\t            var attrs = omit(marker, 'type', 'userSpaceOnUse');\n\t            var pathMarker = V('marker', {\n\t                id: markerId,\n\t                orient: 'auto',\n\t                overflow: 'visible',\n\t                markerUnits: marker.markerUnits || 'userSpaceOnUse'\n\t            }, [\n\t                V(marker.type || 'path', attrs)\n\t            ]);\n\n\t            pathMarker.appendTo(this.defs);\n\t        }\n\n\t        return markerId;\n\t    }\n\n\t}, {\n\n\t    sorting: sortingTypes,\n\n\t    Layers: LayersNames,\n\n\t    backgroundPatterns: {\n\n\t        flipXy: function(img) {\n\t            // d b\n\t            // q p\n\n\t            var canvas = document.createElement('canvas');\n\t            var imgWidth = img.width;\n\t            var imgHeight = img.height;\n\n\t            canvas.width = 2 * imgWidth;\n\t            canvas.height = 2 * imgHeight;\n\n\t            var ctx = canvas.getContext('2d');\n\t            // top-left image\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // xy-flipped bottom-right image\n\t            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // x-flipped top-right image\n\t            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // y-flipped bottom-left image\n\t            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n\t            return canvas;\n\t        },\n\n\t        flipX: function(img) {\n\t            // d b\n\t            // d b\n\n\t            var canvas = document.createElement('canvas');\n\t            var imgWidth = img.width;\n\t            var imgHeight = img.height;\n\n\t            canvas.width = imgWidth * 2;\n\t            canvas.height = imgHeight;\n\n\t            var ctx = canvas.getContext('2d');\n\t            // left image\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // flipped right image\n\t            ctx.translate(2 * imgWidth, 0);\n\t            ctx.scale(-1, 1);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n\t            return canvas;\n\t        },\n\n\t        flipY: function(img) {\n\t            // d d\n\t            // q q\n\n\t            var canvas = document.createElement('canvas');\n\t            var imgWidth = img.width;\n\t            var imgHeight = img.height;\n\n\t            canvas.width = imgWidth;\n\t            canvas.height = imgHeight * 2;\n\n\t            var ctx = canvas.getContext('2d');\n\t            // top image\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\t            // flipped bottom image\n\t            ctx.translate(0, 2 * imgHeight);\n\t            ctx.scale(1, -1);\n\t            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n\t            return canvas;\n\t        },\n\n\t        watermark: function(img, opt) {\n\t            //   d\n\t            // d\n\n\t            opt = opt || {};\n\n\t            var imgWidth = img.width;\n\t            var imgHeight = img.height;\n\n\t            var canvas = document.createElement('canvas');\n\t            canvas.width = imgWidth * 3;\n\t            canvas.height = imgHeight * 3;\n\n\t            var ctx = canvas.getContext('2d');\n\t            var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n\t            var radians = toRad(angle);\n\t            var stepX = canvas.width / 4;\n\t            var stepY = canvas.height / 4;\n\n\t            for (var i = 0; i < 4; i++) {\n\t                for (var j = 0; j < 4; j++) {\n\t                    if ((i + j) % 2 > 0) {\n\t                        // reset the current transformations\n\t                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n\t                        ctx.rotate(radians);\n\t                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n\t                    }\n\t                }\n\t            }\n\n\t            return canvas;\n\t        }\n\t    },\n\n\t    gridPatterns: {\n\t        dot: [{\n\t            color: '#AAAAAA',\n\t            thickness: 1,\n\t            markup: 'rect',\n\t            update: function(el, opt) {\n\t                V(el).attr({\n\t                    width: opt.thickness * opt.sx,\n\t                    height: opt.thickness * opt.sy,\n\t                    fill: opt.color\n\t                });\n\t            }\n\t        }],\n\t        fixedDot: [{\n\t            color: '#AAAAAA',\n\t            thickness: 1,\n\t            markup: 'rect',\n\t            update: function(el, opt) {\n\t                var size = opt.sx <= 1 ? opt.thickness * opt.sx : opt.thickness;\n\t                V(el).attr({ width: size, height: size, fill: opt.color });\n\t            }\n\t        }],\n\t        mesh: [{\n\t            color: '#AAAAAA',\n\t            thickness: 1,\n\t            markup: 'path',\n\t            update: function(el, opt) {\n\n\t                var d;\n\t                var width = opt.width;\n\t                var height = opt.height;\n\t                var thickness = opt.thickness;\n\n\t                if (width - thickness >= 0 && height - thickness >= 0) {\n\t                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t                } else {\n\t                    d = 'M 0 0 0 0';\n\t                }\n\n\t                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n\t            }\n\t        }],\n\t        doubleMesh: [{\n\t            color: '#AAAAAA',\n\t            thickness: 1,\n\t            markup: 'path',\n\t            update: function(el, opt) {\n\n\t                var d;\n\t                var width = opt.width;\n\t                var height = opt.height;\n\t                var thickness = opt.thickness;\n\n\t                if (width - thickness >= 0 && height - thickness >= 0) {\n\t                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t                } else {\n\t                    d = 'M 0 0 0 0';\n\t                }\n\n\t                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n\t            }\n\t        }, {\n\t            color: '#000000',\n\t            thickness: 3,\n\t            scaleFactor: 4,\n\t            markup: 'path',\n\t            update: function(el, opt) {\n\n\t                var d;\n\t                var width = opt.width;\n\t                var height = opt.height;\n\t                var thickness = opt.thickness;\n\n\t                if (width - thickness >= 0 && height - thickness >= 0) {\n\t                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n\t                } else {\n\t                    d = 'M 0 0 0 0';\n\t                }\n\n\t                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n\t            }\n\t        }]\n\t    }\n\t});\n\n\tvar ToolView = View.extend({\n\t    name: null,\n\t    tagName: 'g',\n\t    className: 'tool',\n\t    svgElement: true,\n\t    _visible: true,\n\n\t    init: function() {\n\t        var name = this.name;\n\t        if (name) { this.vel.attr('data-tool-name', name); }\n\t    },\n\n\t    configure: function(view, toolsView) {\n\t        this.relatedView = view;\n\t        this.paper = view.paper;\n\t        this.parentView = toolsView;\n\t        this.simulateRelatedView(this.el);\n\t        // Delegate events in case the ToolView was removed from the DOM and reused.\n\t        this.delegateEvents();\n\t        return this;\n\t    },\n\n\t    simulateRelatedView: function(el) {\n\t        if (el) { el.setAttribute('model-id', this.relatedView.model.id); }\n\t    },\n\n\t    getName: function() {\n\t        return this.name;\n\t    },\n\n\t    show: function() {\n\t        this.el.style.display = '';\n\t        this._visible = true;\n\t    },\n\n\t    hide: function() {\n\t        this.el.style.display = 'none';\n\t        this._visible = false;\n\t    },\n\n\t    isVisible: function() {\n\t        return !!this._visible;\n\t    },\n\n\t    focus: function() {\n\t        var opacity = this.options.focusOpacity;\n\t        if (isFinite(opacity)) { this.el.style.opacity = opacity; }\n\t        this.parentView.focusTool(this);\n\t    },\n\n\t    blur: function() {\n\t        this.el.style.opacity = '';\n\t        this.parentView.blurTool(this);\n\t    },\n\n\t    update: function() {\n\t        // to be overridden\n\t    },\n\n\t    guard: function(evt) {\n\t        // Let the context-menu event bubble up to the relatedView\n\t        var ref = this;\n\t        var paper = ref.paper;\n\t        var relatedView = ref.relatedView;\n\t        if (!paper || !relatedView) { return true; }\n\t        return paper.guard(evt, relatedView);\n\t    }\n\t});\n\n\tvar ToolsView = View.extend({\n\t    tagName: 'g',\n\t    className: 'tools',\n\t    svgElement: true,\n\t    tools: null,\n\t    isRendered: false,\n\t    options: {\n\t        tools: null,\n\t        relatedView: null,\n\t        name: null,\n\t        component: false\n\t    },\n\n\t    configure: function(options) {\n\t        options = assign(this.options, options);\n\t        var tools = options.tools;\n\t        if (!Array.isArray(tools)) { return this; }\n\t        var relatedView = options.relatedView;\n\t        if (!(relatedView instanceof CellView)) { return this; }\n\t        var views = this.tools = [];\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            var tool = tools[i];\n\t            if (!(tool instanceof ToolView)) { continue; }\n\t            tool.configure(relatedView, this);\n\t            this.vel.append(tool.el);\n\t            views.push(tool);\n\t        }\n\t        this.isRendered = false;\n\t        relatedView.requestUpdate(relatedView.getFlag('TOOLS'));\n\t        return this;\n\t    },\n\n\t    getName: function() {\n\t        return this.options.name;\n\t    },\n\n\t    update: function(opt) {\n\n\t        opt || (opt = {});\n\t        var tools = this.tools;\n\t        if (!tools) { return this; }\n\t        var isRendered = this.isRendered;\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            var tool = tools[i];\n\t            if (!isRendered) {\n\t                // First update executes render()\n\t                tool.render();\n\t            } else if (opt.tool !== tool.cid && tool.isVisible()) {\n\t                tool.update();\n\t            }\n\t        }\n\t        if (!isRendered) {\n\t            this.mount();\n\t            // Make sure tools are visible (if they were hidden and the tool removed)\n\t            this.blurTool();\n\t            this.isRendered = true;\n\t        }\n\t        return this;\n\t    },\n\n\t    focusTool: function(focusedTool) {\n\n\t        var tools = this.tools;\n\t        if (!tools) { return this; }\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            var tool = tools[i];\n\t            if (focusedTool === tool) {\n\t                tool.show();\n\t            } else {\n\t                tool.hide();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\n\t    blurTool: function(blurredTool) {\n\t        var tools = this.tools;\n\t        if (!tools) { return this; }\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            var tool = tools[i];\n\t            if (tool !== blurredTool && !tool.isVisible()) {\n\t                tool.show();\n\t                tool.update();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\n\t    hide: function() {\n\t        return this.focusTool(null);\n\t    },\n\n\t    show: function() {\n\t        return this.blurTool(null);\n\t    },\n\n\t    onRemove: function() {\n\t        var tools = this.tools;\n\t        if (!tools) { return this; }\n\t        for (var i = 0, n = tools.length; i < n; i++) {\n\t            tools[i].remove();\n\t        }\n\t        this.tools = null;\n\t    },\n\n\t    mount: function() {\n\t        var options = this.options;\n\t        var relatedView = options.relatedView;\n\t        if (relatedView) {\n\t            var container = (options.component) ? relatedView.el : relatedView.paper.tools;\n\t            container.appendChild(this.el);\n\t        }\n\t        return this;\n\t    }\n\n\t});\n\n\n\n\tvar index$2 = ({\n\t\tGraph: Graph,\n\t\tattributes: attributes,\n\t\tCell: Cell,\n\t\tCellView: CellView,\n\t\tElement: Element$1,\n\t\tElementView: ElementView,\n\t\tLink: Link,\n\t\tLinkView: LinkView,\n\t\tPaper: Paper,\n\t\tToolView: ToolView,\n\t\tToolsView: ToolsView,\n\t\tHighlighterView: HighlighterView\n\t});\n\n\tvar DirectedGraph = {\n\n\t    exportElement: function(element) {\n\n\t        // The width and height of the element.\n\t        return element.size();\n\t    },\n\n\t    exportLink: function(link) {\n\n\t        var labelSize = link.get('labelSize') || {};\n\t        var edge = {\n\t            // The number of ranks to keep between the source and target of the edge.\n\t            minLen: link.get('minLen') || 1,\n\t            // The weight to assign edges. Higher weight edges are generally\n\t            // made shorter and straighter than lower weight edges.\n\t            weight: link.get('weight') || 1,\n\t            // Where to place the label relative to the edge.\n\t            // l = left, c = center r = right.\n\t            labelpos: link.get('labelPosition') || 'c',\n\t            // How many pixels to move the label away from the edge.\n\t            // Applies only when labelpos is l or r.\n\t            labeloffset: link.get('labelOffset') || 0,\n\t            // The width of the edge label in pixels.\n\t            width: labelSize.width || 0,\n\t            // The height of the edge label in pixels.\n\t            height: labelSize.height || 0\n\t        };\n\n\t        return edge;\n\t    },\n\n\t    importElement: function(opt, v, gl) {\n\n\t        var element = this.getCell(v);\n\t        var glNode = gl.node(v);\n\n\t        if (opt.setPosition) {\n\t            opt.setPosition(element, glNode);\n\t        } else {\n\t            element.set('position', {\n\t                x: glNode.x - glNode.width / 2,\n\t                y: glNode.y - glNode.height / 2\n\t            });\n\t        }\n\t    },\n\n\t    importLink: function(opt, edgeObj, gl) {\n\n\t        var SIMPLIFY_THRESHOLD = 0.001;\n\n\t        var link = this.getCell(edgeObj.name);\n\t        var glEdge = gl.edge(edgeObj);\n\t        var points = glEdge.points || [];\n\t        var polyline = new Polyline(points);\n\n\t        // check the `setLinkVertices` here for backwards compatibility\n\t        if (opt.setVertices || opt.setLinkVertices) {\n\t            if (isFunction(opt.setVertices)) {\n\t                opt.setVertices(link, points);\n\t            } else {\n\t                // simplify the `points` polyline\n\t                polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n\t                var polylinePoints = polyline.points.map(function (point) { return (point.toJSON()); }); // JSON of points after simplification\n\t                var numPolylinePoints = polylinePoints.length; // number of points after simplification\n\t                // set simplified polyline points as link vertices\n\t                // remove first and last polyline points (= source/target sonnectionPoints)\n\t                link.set('vertices', polylinePoints.slice(1, numPolylinePoints - 1));\n\t            }\n\t        }\n\n\t        if (opt.setLabels && ('x' in glEdge) && ('y' in glEdge)) {\n\t            var labelPosition = { x: glEdge.x, y: glEdge.y };\n\t            if (isFunction(opt.setLabels)) {\n\t                opt.setLabels(link, labelPosition, points);\n\t            } else {\n\t                // convert the absolute label position to a relative position\n\t                // towards the closest point on the edge\n\t                var length = polyline.closestPointLength(labelPosition);\n\t                var closestPoint = polyline.pointAtLength(length);\n\t                var distance = (length / polyline.length());\n\t                var offset = new Point(labelPosition).difference(closestPoint).toJSON();\n\t                link.label(0, {\n\t                    position: {\n\t                        distance: distance,\n\t                        offset: offset\n\t                    }\n\t                });\n\t            }\n\t        }\n\t    },\n\n\t    layout: function(graphOrCells, opt) {\n\n\t        var graph;\n\n\t        if (graphOrCells instanceof Graph) {\n\t            graph = graphOrCells;\n\t        } else {\n\t            // Reset cells in dry mode so the graph reference is not stored on the cells.\n\t            // `sort: false` to prevent elements to change their order based on the z-index\n\t            graph = (new Graph()).resetCells(graphOrCells, { dry: true, sort: false });\n\t        }\n\n\t        // This is not needed anymore.\n\t        graphOrCells = null;\n\n\t        opt = defaults(opt || {}, {\n\t            resizeClusters: true,\n\t            clusterPadding: 10,\n\t            exportElement: this.exportElement,\n\t            exportLink: this.exportLink\n\t        });\n\n\t        /* global dagre: true */\n\t        var dagreUtil = opt.dagre || (typeof dagre !== 'undefined' ? dagre : undefined);\n\t        /* global dagre: false */\n\n\t        if (dagreUtil === undefined) { throw new Error('The the \"dagre\" utility is a mandatory dependency.'); }\n\n\t        // create a graphlib.Graph that represents the joint.dia.Graph\n\t        // var glGraph = graph.toGraphLib({\n\t        var glGraph = DirectedGraph.toGraphLib(graph, {\n\t            graphlib: opt.graphlib,\n\t            directed: true,\n\t            // We are about to use edge naming feature.\n\t            multigraph: true,\n\t            // We are able to layout graphs with embeds.\n\t            compound: true,\n\t            setNodeLabel: opt.exportElement,\n\t            setEdgeLabel: opt.exportLink,\n\t            setEdgeName: function(link) {\n\t                // Graphlib edges have no ids. We use edge name property\n\t                // to store and retrieve ids instead.\n\t                return link.id;\n\t            }\n\t        });\n\n\t        var glLabel = {};\n\t        var marginX = opt.marginX || 0;\n\t        var marginY = opt.marginY || 0;\n\n\t        // Dagre layout accepts options as lower case.\n\t        // Direction for rank nodes. Can be TB, BT, LR, or RL\n\t        if (opt.rankDir) { glLabel.rankdir = opt.rankDir; }\n\t        // Alignment for rank nodes. Can be UL, UR, DL, or DR\n\t        if (opt.align) { glLabel.align = opt.align; }\n\t        // Number of pixels that separate nodes horizontally in the layout.\n\t        if (opt.nodeSep) { glLabel.nodesep = opt.nodeSep; }\n\t        // Number of pixels that separate edges horizontally in the layout.\n\t        if (opt.edgeSep) { glLabel.edgesep = opt.edgeSep; }\n\t        // Number of pixels between each rank in the layout.\n\t        if (opt.rankSep) { glLabel.ranksep = opt.rankSep; }\n\t        // Type of algorithm to assign a rank to each node in the input graph.\n\t        // Possible values: network-simplex, tight-tree or longest-path\n\t        if (opt.ranker) { glLabel.ranker = opt.ranker; }\n\t        // Number of pixels to use as a margin around the left and right of the graph.\n\t        if (marginX) { glLabel.marginx = marginX; }\n\t        // Number of pixels to use as a margin around the top and bottom of the graph.\n\t        if (marginY) { glLabel.marginy = marginY; }\n\n\t        // Set the option object for the graph label.\n\t        glGraph.setGraph(glLabel);\n\n\t        // Executes the layout.\n\t        dagreUtil.layout(glGraph, { debugTiming: !!opt.debugTiming });\n\n\t        // Wrap all graph changes into a batch.\n\t        graph.startBatch('layout');\n\n\t        DirectedGraph.fromGraphLib(glGraph, {\n\t            importNode: this.importElement.bind(graph, opt),\n\t            importEdge: this.importLink.bind(graph, opt)\n\t        });\n\n\t        // // Update the graph.\n\t        // graph.fromGraphLib(glGraph, {\n\t        //     importNode: this.importElement.bind(graph, opt),\n\t        //     importEdge: this.importLink.bind(graph, opt)\n\t        // });\n\n\t        if (opt.resizeClusters) {\n\t            // Resize and reposition cluster elements (parents of other elements)\n\t            // to fit their children.\n\t            // 1. filter clusters only\n\t            // 2. map id on cells\n\t            // 3. sort cells by their depth (the deepest first)\n\t            // 4. resize cell to fit their direct children only.\n\t            var clusters = glGraph.nodes()\n\t                .filter(function(v) { return glGraph.children(v).length > 0; })\n\t                .map(graph.getCell.bind(graph))\n\t                .sort(function(aCluster, bCluster) {\n\t                    return bCluster.getAncestors().length - aCluster.getAncestors().length;\n\t                });\n\n\t            invoke(clusters, 'fitEmbeds', { padding: opt.clusterPadding });\n\t        }\n\n\t        graph.stopBatch('layout');\n\n\t        // Width and height of the graph extended by margins.\n\t        var glSize = glGraph.graph();\n\t        // Return the bounding box of the graph after the layout.\n\t        return new Rect(\n\t            marginX,\n\t            marginY,\n\t            Math.abs(glSize.width - 2 * marginX),\n\t            Math.abs(glSize.height - 2 * marginY)\n\t        );\n\t    },\n\n\t    fromGraphLib: function(glGraph, opt) {\n\n\t        opt = opt || {};\n\n\t        var importNode = opt.importNode || noop;\n\t        var importEdge = opt.importEdge || noop;\n\t        var graph = (this instanceof Graph) ? this : new Graph;\n\n\t        // Import all nodes.\n\t        glGraph.nodes().forEach(function(node) {\n\t            importNode.call(graph, node, glGraph, graph, opt);\n\t        });\n\n\t        // Import all edges.\n\t        glGraph.edges().forEach(function(edge) {\n\t            importEdge.call(graph, edge, glGraph, graph, opt);\n\t        });\n\n\t        return graph;\n\t    },\n\n\t    // Create new graphlib graph from existing JointJS graph.\n\t    toGraphLib: function(graph, opt) {\n\n\t        opt = opt || {};\n\n\t        /* global graphlib: true */\n\t        var graphlibUtil = opt.graphlib || (typeof graphlib !== 'undefined' ? graphlib : undefined);\n\t        /* global graphlib: false */\n\n\t        if (graphlibUtil === undefined) { throw new Error('The the \"graphlib\" utility is a mandatory dependency.'); }\n\n\t        var glGraphType = pick(opt, 'directed', 'compound', 'multigraph');\n\t        var glGraph = new graphlibUtil.Graph(glGraphType);\n\t        var setNodeLabel = opt.setNodeLabel || noop;\n\t        var setEdgeLabel = opt.setEdgeLabel || noop;\n\t        var setEdgeName = opt.setEdgeName || noop;\n\t        var collection = graph.get('cells');\n\n\t        for (var i = 0, n = collection.length; i < n; i++) {\n\n\t            var cell = collection.at(i);\n\t            if (cell.isLink()) {\n\n\t                var source = cell.get('source');\n\t                var target = cell.get('target');\n\n\t                // Links that end at a point are ignored.\n\t                if (!source.id || !target.id) { break; }\n\n\t                // Note that if we are creating a multigraph we can name the edges. If\n\t                // we try to name edges on a non-multigraph an exception is thrown.\n\t                glGraph.setEdge(source.id, target.id, setEdgeLabel(cell), setEdgeName(cell));\n\n\t            } else {\n\n\t                glGraph.setNode(cell.id, setNodeLabel(cell));\n\n\t                // For the compound graphs we have to take embeds into account.\n\t                if (glGraph.isCompound() && cell.has('parent')) {\n\t                    var parentId = cell.get('parent');\n\t                    if (collection.has(parentId)) {\n\t                        // Make sure the parent cell is included in the graph (this can\n\t                        // happen when the layout is run on part of the graph only).\n\t                        glGraph.setParent(cell.id, parentId);\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return glGraph;\n\t    }\n\t};\n\n\tGraph.prototype.toGraphLib = function(opt) {\n\n\t    return DirectedGraph.toGraphLib(this, opt);\n\t};\n\n\tGraph.prototype.fromGraphLib = function(glGraph, opt) {\n\n\t    return DirectedGraph.fromGraphLib.call(this, glGraph, opt);\n\t};\n\n\tvar env = {\n\n\t    _results: {},\n\n\t    _tests: {\n\n\t        svgforeignobject: function() {\n\t            return !!document.createElementNS &&\n\t                /SVGForeignObject/.test(({}).toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\n\t        }\n\t    },\n\n\t    addTest: function(name, fn) {\n\n\t        return this._tests[name] = fn;\n\t    },\n\n\t    test: function(name) {\n\n\t        var fn = this._tests[name];\n\n\t        if (!fn) {\n\t            throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n\t        }\n\n\t        var result = this._results[name];\n\n\t        if (typeof result !== 'undefined') {\n\t            return result;\n\t        }\n\n\t        try {\n\t            result = fn();\n\t        } catch (error) {\n\t            result = false;\n\t        }\n\n\t        // Cache the test result.\n\t        this._results[name] = result;\n\n\t        return result;\n\t    }\n\t};\n\n\tvar Generic = Element$1.define('basic.Generic', {\n\t    attrs: {\n\t        '.': { fill: '#ffffff', stroke: 'none' }\n\t    }\n\t});\n\n\tvar Rect$1 = Generic.define('basic.Rect', {\n\t    attrs: {\n\t        'rect': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            width: 100,\n\t            height: 60\n\t        },\n\t        'text': {\n\t            fill: '#000000',\n\t            text: '',\n\t            'font-size': 14,\n\t            'ref-x': .5,\n\t            'ref-y': .5,\n\t            'text-anchor': 'middle',\n\t            'y-alignment': 'middle',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect/></g><text/></g>'\n\t});\n\n\tvar TextView = ElementView.extend({\n\n\t    presentationAttributes: ElementView.addPresentationAttributes({\n\t        // The element view is not automatically re-scaled to fit the model size\n\t        // when the attribute 'attrs' is changed.\n\t        attrs: ['SCALE']\n\t    }),\n\n\t    confirmUpdate: function() {\n\t        var flags = ElementView.prototype.confirmUpdate.apply(this, arguments);\n\t        if (this.hasFlag(flags, 'SCALE')) {\n\t            this.resize();\n\t            flags = this.removeFlag(flags, 'SCALE');\n\t        }\n\t        return flags;\n\t    }\n\t});\n\n\tvar Text = Generic.define('basic.Text', {\n\t    attrs: {\n\t        'text': {\n\t            'font-size': 18,\n\t            fill: '#000000'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><text/></g></g>',\n\t});\n\n\tvar Circle = Generic.define('basic.Circle', {\n\t    size: { width: 60, height: 60 },\n\t    attrs: {\n\t        'circle': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            r: 30,\n\t            cx: 30,\n\t            cy: 30\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-y': .5,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g><text/></g>',\n\t});\n\n\tvar Ellipse$1 = Generic.define('basic.Ellipse', {\n\t    size: { width: 60, height: 40 },\n\t    attrs: {\n\t        'ellipse': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            rx: 30,\n\t            ry: 20,\n\t            cx: 30,\n\t            cy: 20\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-y': .5,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse/></g><text/></g>',\n\t});\n\n\tvar Polygon = Generic.define('basic.Polygon', {\n\t    size: { width: 60, height: 40 },\n\t    attrs: {\n\t        'polygon': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000'\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-dy': 20,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>',\n\t});\n\n\tvar Polyline$1 = Generic.define('basic.Polyline', {\n\t    size: { width: 60, height: 40 },\n\t    attrs: {\n\t        'polyline': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000'\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-dy': 20,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polyline/></g><text/></g>',\n\t});\n\n\tvar Image = Generic.define('basic.Image', {\n\t    attrs: {\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-dy': 20,\n\t            'y-alignment': 'middle',\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image/></g><text/></g>',\n\t});\n\n\tvar Path$1 = Generic.define('basic.Path', {\n\t    size: { width: 60, height: 60 },\n\t    attrs: {\n\t        'path': {\n\t            fill: '#ffffff',\n\t            stroke: '#000000'\n\t        },\n\t        'text': {\n\t            'font-size': 14,\n\t            text: '',\n\t            'text-anchor': 'middle',\n\t            'ref': 'path',\n\t            'ref-x': .5,\n\t            'ref-dy': 10,\n\t            fill: '#000000',\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        }\n\t    }\n\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path/></g><text/></g>',\n\t});\n\n\tvar Rhombus = Path$1.define('basic.Rhombus', {\n\t    attrs: {\n\t        'path': {\n\t            d: 'M 30 0 L 60 30 30 60 0 30 z'\n\t        },\n\t        'text': {\n\t            'ref-y': .5,\n\t            'ref-dy': null,\n\t            'y-alignment': 'middle'\n\t        }\n\t    }\n\t});\n\n\tvar svgForeignObjectSupported = env.test('svgforeignobject');\n\n\tvar TextBlock = Generic.define('basic.TextBlock', {\n\t    // see joint.css for more element styles\n\t    attrs: {\n\t        rect: {\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            width: 80,\n\t            height: 100\n\t        },\n\t        text: {\n\t            fill: '#000000',\n\t            'font-size': 14,\n\t            'font-family': 'Arial, helvetica, sans-serif'\n\t        },\n\t        '.content': {\n\t            text: '',\n\t            'ref-x': .5,\n\t            'ref-y': .5,\n\t            'y-alignment': 'middle',\n\t            'x-alignment': 'middle'\n\t        }\n\t    },\n\n\t    content: ''\n\t}, {\n\t    markup: [\n\t        '<g class=\"rotatable\">',\n\t        '<g class=\"scalable\"><rect/></g>',\n\t        svgForeignObjectSupported\n\t            ? '<foreignObject class=\"fobj\"><body xmlns=\"http://www.w3.org/1999/xhtml\"><div class=\"content\"/></body></foreignObject>'\n\t            : '<text class=\"content\"/>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    initialize: function() {\n\n\t        this.listenTo(this, 'change:size', this.updateSize);\n\t        this.listenTo(this, 'change:content', this.updateContent);\n\t        this.updateSize(this, this.get('size'));\n\t        this.updateContent(this, this.get('content'));\n\t        Generic.prototype.initialize.apply(this, arguments);\n\t    },\n\n\t    updateSize: function(cell, size) {\n\n\t        // Selector `foreignObject' doesn't work across all browsers, we're using class selector instead.\n\t        // We have to clone size as we don't want attributes.div.style to be same object as attributes.size.\n\t        this.attr({\n\t            '.fobj': assign({}, size),\n\t            div: {\n\t                style: assign({}, size)\n\t            }\n\t        });\n\t    },\n\n\t    updateContent: function(cell, content) {\n\n\t        if (svgForeignObjectSupported) {\n\n\t            // Content element is a <div> element.\n\t            this.attr({\n\t                '.content': {\n\t                    html: sanitizeHTML(content)\n\t                }\n\t            });\n\n\t        } else {\n\n\t            // Content element is a <text> element.\n\t            // SVG elements don't have innerHTML attribute.\n\t            this.attr({\n\t                '.content': {\n\t                    text: content\n\t                }\n\t            });\n\t        }\n\t    },\n\n\t    // Here for backwards compatibility:\n\t    setForeignObjectSize: function() {\n\n\t        this.updateSize.apply(this, arguments);\n\t    },\n\n\t    // Here for backwards compatibility:\n\t    setDivContent: function() {\n\n\t        this.updateContent.apply(this, arguments);\n\t    }\n\t});\n\n\t// TextBlockView implements the fallback for IE when no foreignObject exists and\n\t// the text needs to be manually broken.\n\tvar TextBlockView = ElementView.extend({\n\n\t    presentationAttributes: svgForeignObjectSupported\n\t        ? ElementView.prototype.presentationAttributes\n\t        : ElementView.addPresentationAttributes({\n\t            content: ['CONTENT'],\n\t            size: ['CONTENT']\n\t        }),\n\n\t    initFlag: ['RENDER', 'CONTENT'],\n\n\t    confirmUpdate: function() {\n\t        var flags = ElementView.prototype.confirmUpdate.apply(this, arguments);\n\t        if (this.hasFlag(flags, 'CONTENT')) {\n\t            this.updateContent(this.model);\n\t            flags = this.removeFlag(flags, 'CONTENT');\n\t        }\n\t        return flags;\n\t    },\n\n\t    update: function(_, renderingOnlyAttrs) {\n\n\t        var model = this.model;\n\n\t        if (!svgForeignObjectSupported) {\n\n\t            // Update everything but the content first.\n\t            var noTextAttrs = omit(renderingOnlyAttrs || model.get('attrs'), '.content');\n\t            ElementView.prototype.update.call(this, model, noTextAttrs);\n\n\t            if (!renderingOnlyAttrs || has$2(renderingOnlyAttrs, '.content')) {\n\t                // Update the content itself.\n\t                this.updateContent(model, renderingOnlyAttrs);\n\t            }\n\n\t        } else {\n\n\t            ElementView.prototype.update.call(this, model, renderingOnlyAttrs);\n\t        }\n\t    },\n\n\t    updateContent: function(cell, renderingOnlyAttrs) {\n\n\t        // Create copy of the text attributes\n\t        var textAttrs = merge({}, (renderingOnlyAttrs || cell.get('attrs'))['.content']);\n\n\t        textAttrs = omit(textAttrs, 'text');\n\n\t        // Break the content to fit the element size taking into account the attributes\n\t        // set on the model.\n\t        var text = breakText(cell.get('content'), cell.get('size'), textAttrs, {\n\t            // measuring sandbox svg document\n\t            svgDocument: this.paper.svg\n\t        });\n\n\t        // Create a new attrs with same structure as the model attrs { text: { *textAttributes* }}\n\t        var attrs = setByPath({}, '.content', textAttrs, '/');\n\n\t        // Replace text attribute with the one we just processed.\n\t        attrs['.content'].text = text;\n\n\t        // Update the view using renderingOnlyAttributes parameter.\n\t        ElementView.prototype.update.call(this, cell, attrs);\n\t    }\n\t});\n\n\tvar basic = ({\n\t\tGeneric: Generic,\n\t\tRect: Rect$1,\n\t\tTextView: TextView,\n\t\tText: Text,\n\t\tCircle: Circle,\n\t\tEllipse: Ellipse$1,\n\t\tPolygon: Polygon,\n\t\tPolyline: Polyline$1,\n\t\tImage: Image,\n\t\tPath: Path$1,\n\t\tRhombus: Rhombus,\n\t\tTextBlock: TextBlock,\n\t\tTextBlockView: TextBlockView\n\t});\n\n\t// ELEMENTS\n\n\tvar Rectangle = Element$1.define('standard.Rectangle', {\n\t    attrs: {\n\t        body: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            strokeWidth: 2,\n\t            stroke: '#000000',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'body',\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Circle$1 = Element$1.define('standard.Circle', {\n\t    attrs: {\n\t        body: {\n\t            refCx: '50%',\n\t            refCy: '50%',\n\t            refR: '50%',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'circle',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Ellipse$2 = Element$1.define('standard.Ellipse', {\n\t    attrs: {\n\t        body: {\n\t            refCx: '50%',\n\t            refCy: '50%',\n\t            refRx: '50%',\n\t            refRy: '50%',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'ellipse',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Path$2 = Element$1.define('standard.Path', {\n\t    attrs: {\n\t        body: {\n\t            refD: 'M 0 0 L 10 0 10 10 0 10 Z',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Polygon$1 = Element$1.define('standard.Polygon', {\n\t    attrs: {\n\t        body: {\n\t            refPoints: '0 0 10 0 10 10 0 10',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'polygon',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Polyline$2 = Element$1.define('standard.Polyline', {\n\t    attrs: {\n\t        body: {\n\t            refPoints: '0 0 10 0 10 10 0 10 0 0',\n\t            strokeWidth: 2,\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'polyline',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar Image$1 = Element$1.define('standard.Image', {\n\t    attrs: {\n\t        image: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            // xlinkHref: '[URL]'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'top',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '100%',\n\t            refY2: 10,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'image',\n\t        selector: 'image'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar BorderedImage = Element$1.define('standard.BorderedImage', {\n\t    attrs: {\n\t        border: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            stroke: '#333333',\n\t            strokeWidth: 2\n\t        },\n\t        background: {\n\t            refWidth: -1,\n\t            refHeight: -1,\n\t            x: 0.5,\n\t            y: 0.5,\n\t            fill: '#FFFFFF'\n\t        },\n\t        image: {\n\t            // xlinkHref: '[URL]'\n\t            refWidth: -1,\n\t            refHeight: -1,\n\t            x: 0.5,\n\t            y: 0.5\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'top',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '100%',\n\t            refY2: 10,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'background',\n\t        attributes: {\n\t            'stroke': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'image',\n\t        selector: 'image'\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'border',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar EmbeddedImage = Element$1.define('standard.EmbeddedImage', {\n\t    attrs: {\n\t        body: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            stroke: '#333333',\n\t            fill: '#FFFFFF',\n\t            strokeWidth: 2\n\t        },\n\t        image: {\n\t            // xlinkHref: '[URL]'\n\t            refWidth: '30%',\n\t            refHeight: -20,\n\t            x: 10,\n\t            y: 10,\n\t            preserveAspectRatio: 'xMidYMin'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'top',\n\t            textAnchor: 'left',\n\t            refX: '30%',\n\t            refX2: 20, // 10 + 10\n\t            refY: 10,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'image',\n\t        selector: 'image'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar InscribedImage = Element$1.define('standard.InscribedImage', {\n\t    attrs: {\n\t        border: {\n\t            refRx: '50%',\n\t            refRy: '50%',\n\t            refCx: '50%',\n\t            refCy: '50%',\n\t            stroke: '#333333',\n\t            strokeWidth: 2\n\t        },\n\t        background: {\n\t            refRx: '50%',\n\t            refRy: '50%',\n\t            refCx: '50%',\n\t            refCy: '50%',\n\t            fill: '#FFFFFF'\n\t        },\n\t        image: {\n\t            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n\t            refWidth: '68%',\n\t            refHeight: '68%',\n\t            // The image offset is calculated as (100% - 68%) / 2\n\t            refX: '16%',\n\t            refY: '16%',\n\t            preserveAspectRatio: 'xMidYMid'\n\t            // xlinkHref: '[URL]'\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'top',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '100%',\n\t            refY2: 10,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'ellipse',\n\t        selector: 'background'\n\t    }, {\n\t        tagName: 'image',\n\t        selector: 'image'\n\t    }, {\n\t        tagName: 'ellipse',\n\t        selector: 'border',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }]\n\t});\n\n\tvar HeaderedRectangle = Element$1.define('standard.HeaderedRectangle', {\n\t    attrs: {\n\t        body: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            strokeWidth: 2,\n\t            stroke: '#000000',\n\t            fill: '#FFFFFF'\n\t        },\n\t        header: {\n\t            refWidth: '100%',\n\t            height: 30,\n\t            strokeWidth: 2,\n\t            stroke: '#000000',\n\t            fill: '#FFFFFF'\n\t        },\n\t        headerText: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: 15,\n\t            fontSize: 16,\n\t            fill: '#333333'\n\t        },\n\t        bodyText: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '50%',\n\t            refY2: 15,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'header'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'headerText'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'bodyText'\n\t    }]\n\t});\n\n\tvar CYLINDER_TILT = 10;\n\n\tvar Cylinder = Element$1.define('standard.Cylinder', {\n\t    attrs: {\n\t        body: {\n\t            lateralArea: CYLINDER_TILT,\n\t            fill: '#FFFFFF',\n\t            stroke: '#333333',\n\t            strokeWidth: 2\n\t        },\n\t        top: {\n\t            refCx: '50%',\n\t            cy: CYLINDER_TILT,\n\t            refRx: '50%',\n\t            ry: CYLINDER_TILT,\n\t            fill: '#FFFFFF',\n\t            stroke: '#333333',\n\t            strokeWidth: 2\n\t        },\n\t        label: {\n\t            textVerticalAnchor: 'middle',\n\t            textAnchor: 'middle',\n\t            refX: '50%',\n\t            refY: '100%',\n\t            refY2: 15,\n\t            fontSize: 14,\n\t            fill: '#333333'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'body'\n\t    }, {\n\t        tagName: 'ellipse',\n\t        selector: 'top'\n\t    }, {\n\t        tagName: 'text',\n\t        selector: 'label'\n\t    }],\n\n\t    topRy: function(t, opt) {\n\t        // getter\n\t        if (t === undefined) { return this.attr('body/lateralArea'); }\n\n\t        // setter\n\t        var isPercentageSetter = isPercentage(t);\n\n\t        var bodyAttrs = { lateralArea: t };\n\t        var topAttrs = isPercentageSetter\n\t            ? { refCy: t, refRy: t, cy: null, ry: null }\n\t            : { refCy: null, refRy: null, cy: t, ry: t };\n\n\t        return this.attr({ body: bodyAttrs, top: topAttrs }, opt);\n\t    }\n\n\t}, {\n\t    attributes: {\n\t        lateralArea: {\n\t            set: function(t, refBBox) {\n\t                var isPercentageSetter = isPercentage(t);\n\t                if (isPercentageSetter) { t = parseFloat(t) / 100; }\n\n\t                var x = refBBox.x;\n\t                var y = refBBox.y;\n\t                var w = refBBox.width;\n\t                var h = refBBox.height;\n\n\t                // curve control point variables\n\t                var rx = w / 2;\n\t                var ry = isPercentageSetter ? (h * t) : t;\n\n\t                var kappa = V.KAPPA;\n\t                var cx = kappa * rx;\n\t                var cy = kappa * (isPercentageSetter ? (h * t) : t);\n\n\t                // shape variables\n\t                var xLeft = x;\n\t                var xCenter = x + (w / 2);\n\t                var xRight = x + w;\n\n\t                var ySideTop = y + ry;\n\t                var yCurveTop = ySideTop - ry;\n\t                var ySideBottom = y + h - ry;\n\t                var yCurveBottom = y + h;\n\n\t                // return calculated shape\n\t                var data = [\n\t                    'M', xLeft, ySideTop,\n\t                    'L', xLeft, ySideBottom,\n\t                    'C', x, (ySideBottom + cy), (xCenter - cx), yCurveBottom, xCenter, yCurveBottom,\n\t                    'C', (xCenter + cx), yCurveBottom, xRight, (ySideBottom + cy), xRight, ySideBottom,\n\t                    'L', xRight, ySideTop,\n\t                    'C', xRight, (ySideTop - cy), (xCenter + cx), yCurveTop, xCenter, yCurveTop,\n\t                    'C', (xCenter - cx), yCurveTop, xLeft, (ySideTop - cy), xLeft, ySideTop,\n\t                    'Z'\n\t                ];\n\t                return { d: data.join(' ') };\n\t            }\n\t        }\n\t    }\n\t});\n\n\tvar foLabelMarkup = {\n\t    tagName: 'foreignObject',\n\t    selector: 'foreignObject',\n\t    attributes: {\n\t        'overflow': 'hidden'\n\t    },\n\t    children: [{\n\t        tagName: 'div',\n\t        namespaceURI: 'http://www.w3.org/1999/xhtml',\n\t        selector: 'label',\n\t        style: {\n\t            width: '100%',\n\t            height: '100%',\n\t            position: 'static',\n\t            backgroundColor: 'transparent',\n\t            textAlign: 'center',\n\t            margin: 0,\n\t            padding: '0px 5px',\n\t            boxSizing: 'border-box',\n\t            display: 'flex',\n\t            alignItems: 'center',\n\t            justifyContent: 'center'\n\t        }\n\t    }]\n\t};\n\n\tvar svgLabelMarkup = {\n\t    tagName: 'text',\n\t    selector: 'label',\n\t    attributes: {\n\t        'text-anchor': 'middle'\n\t    }\n\t};\n\n\tvar labelMarkup = (env.test('svgforeignobject')) ? foLabelMarkup : svgLabelMarkup;\n\n\tvar TextBlock$1 = Element$1.define('standard.TextBlock', {\n\t    attrs: {\n\t        body: {\n\t            refWidth: '100%',\n\t            refHeight: '100%',\n\t            stroke: '#333333',\n\t            fill: '#ffffff',\n\t            strokeWidth: 2\n\t        },\n\t        foreignObject: {\n\t            refWidth: '100%',\n\t            refHeight: '100%'\n\t        },\n\t        label: {\n\t            style: {\n\t                fontSize: 14\n\t            }\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'rect',\n\t        selector: 'body'\n\t    }, labelMarkup]\n\t}, {\n\t    attributes: {\n\t        text: {\n\t            set: function(text, refBBox, node, attrs) {\n\t                if (node instanceof HTMLElement) {\n\t                    node.textContent = text;\n\t                } else {\n\t                    // No foreign object\n\t                    var style = attrs.style || {};\n\t                    var wrapValue = { text: text, width: -5, height: '100%' };\n\t                    var wrapAttrs = assign({ textVerticalAnchor: 'middle' }, style);\n\t                    attributes.textWrap.set.call(this, wrapValue, refBBox, node, wrapAttrs);\n\t                    return { fill: style.color || null };\n\t                }\n\t            },\n\t            position: function(text, refBBox, node) {\n\t                // No foreign object\n\t                if (node instanceof SVGElement) { return refBBox.center(); }\n\t            }\n\t        }\n\t    }\n\t});\n\n\t// LINKS\n\n\tvar Link$1 = Link.define('standard.Link', {\n\t    attrs: {\n\t        line: {\n\t            connection: true,\n\t            stroke: '#333333',\n\t            strokeWidth: 2,\n\t            strokeLinejoin: 'round',\n\t            targetMarker: {\n\t                'type': 'path',\n\t                'd': 'M 10 -5 0 0 10 5 z'\n\t            }\n\t        },\n\t        wrapper: {\n\t            connection: true,\n\t            strokeWidth: 10,\n\t            strokeLinejoin: 'round'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'wrapper',\n\t        attributes: {\n\t            'fill': 'none',\n\t            'cursor': 'pointer',\n\t            'stroke': 'transparent',\n\t            'stroke-linecap': 'round'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'line',\n\t        attributes: {\n\t            'fill': 'none',\n\t            'pointer-events': 'none'\n\t        }\n\t    }]\n\t});\n\n\tvar DoubleLink = Link.define('standard.DoubleLink', {\n\t    attrs: {\n\t        line: {\n\t            connection: true,\n\t            stroke: '#DDDDDD',\n\t            strokeWidth: 4,\n\t            strokeLinejoin: 'round',\n\t            targetMarker: {\n\t                type: 'path',\n\t                stroke: '#000000',\n\t                d: 'M 10 -3 10 -10 -2 0 10 10 10 3'\n\t            }\n\t        },\n\t        outline: {\n\t            connection: true,\n\t            stroke: '#000000',\n\t            strokeWidth: 6,\n\t            strokeLinejoin: 'round'\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'outline',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'line',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }]\n\t});\n\n\tvar ShadowLink = Link.define('standard.ShadowLink', {\n\t    attrs: {\n\t        line: {\n\t            connection: true,\n\t            stroke: '#FF0000',\n\t            strokeWidth: 20,\n\t            strokeLinejoin: 'round',\n\t            targetMarker: {\n\t                'type': 'path',\n\t                'stroke': 'none',\n\t                'd': 'M 0 -10 -10 0 0 10 z'\n\t            },\n\t            sourceMarker: {\n\t                'type': 'path',\n\t                'stroke': 'none',\n\t                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n\t            }\n\t        },\n\t        shadow: {\n\t            connection: true,\n\t            refX: 3,\n\t            refY: 6,\n\t            stroke: '#000000',\n\t            strokeOpacity: 0.2,\n\t            strokeWidth: 20,\n\t            strokeLinejoin: 'round',\n\t            targetMarker: {\n\t                'type': 'path',\n\t                'd': 'M 0 -10 -10 0 0 10 z',\n\t                'stroke': 'none'\n\t            },\n\t            sourceMarker: {\n\t                'type': 'path',\n\t                'stroke': 'none',\n\t                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n\t            }\n\t        }\n\t    }\n\t}, {\n\t    markup: [{\n\t        tagName: 'path',\n\t        selector: 'shadow',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'line',\n\t        attributes: {\n\t            'fill': 'none'\n\t        }\n\t    }]\n\t});\n\n\tvar standard = ({\n\t\tRectangle: Rectangle,\n\t\tCircle: Circle$1,\n\t\tEllipse: Ellipse$2,\n\t\tPath: Path$2,\n\t\tPolygon: Polygon$1,\n\t\tPolyline: Polyline$2,\n\t\tImage: Image$1,\n\t\tBorderedImage: BorderedImage,\n\t\tEmbeddedImage: EmbeddedImage,\n\t\tInscribedImage: InscribedImage,\n\t\tHeaderedRectangle: HeaderedRectangle,\n\t\tCylinder: Cylinder,\n\t\tTextBlock: TextBlock$1,\n\t\tLink: Link$1,\n\t\tDoubleLink: DoubleLink,\n\t\tShadowLink: ShadowLink\n\t});\n\n\t/**\n\t * @deprecated use the port api instead\n\t */\n\tvar Model = Generic.define('devs.Model', {\n\t    inPorts: [],\n\t    outPorts: [],\n\t    size: {\n\t        width: 80,\n\t        height: 80\n\t    },\n\t    attrs: {\n\t        '.': {\n\t            magnet: false\n\t        },\n\t        '.label': {\n\t            text: 'Model',\n\t            'ref-x': .5,\n\t            'ref-y': 10,\n\t            'font-size': 18,\n\t            'text-anchor': 'middle',\n\t            fill: '#000'\n\t        },\n\t        '.body': {\n\t            'ref-width': '100%',\n\t            'ref-height': '100%',\n\t            stroke: '#000'\n\t        }\n\t    },\n\t    ports: {\n\t        groups: {\n\t            'in': {\n\t                position: {\n\t                    name: 'left'\n\t                },\n\t                attrs: {\n\t                    '.port-label': {\n\t                        fill: '#000'\n\t                    },\n\t                    '.port-body': {\n\t                        fill: '#fff',\n\t                        stroke: '#000',\n\t                        r: 10,\n\t                        magnet: true\n\t                    }\n\t                },\n\t                label: {\n\t                    position: {\n\t                        name: 'left',\n\t                        args: {\n\t                            y: 10\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            'out': {\n\t                position: {\n\t                    name: 'right'\n\t                },\n\t                attrs: {\n\t                    '.port-label': {\n\t                        fill: '#000'\n\t                    },\n\t                    '.port-body': {\n\t                        fill: '#fff',\n\t                        stroke: '#000',\n\t                        r: 10,\n\t                        magnet: true\n\t                    }\n\t                },\n\t                label: {\n\t                    position: {\n\t                        name: 'right',\n\t                        args: {\n\t                            y: 10\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><rect class=\"body\"/><text class=\"label\"/></g>',\n\t    portMarkup: '<circle class=\"port-body\"/>',\n\t    portLabelMarkup: '<text class=\"port-label\"/>',\n\n\t    initialize: function() {\n\n\t        Generic.prototype.initialize.apply(this, arguments);\n\n\t        this.on('change:inPorts change:outPorts', this.updatePortItems, this);\n\t        this.updatePortItems();\n\t    },\n\n\t    updatePortItems: function(model, changed, opt) {\n\n\t        // Make sure all ports are unique.\n\t        var inPorts = uniq(this.get('inPorts'));\n\t        var outPorts = difference(uniq(this.get('outPorts')), inPorts);\n\n\t        var inPortItems = this.createPortItems('in', inPorts);\n\t        var outPortItems = this.createPortItems('out', outPorts);\n\n\t        this.prop('ports/items', inPortItems.concat(outPortItems), assign({ rewrite: true }, opt));\n\t    },\n\n\t    createPortItem: function(group, port) {\n\n\t        return {\n\t            id: port,\n\t            group: group,\n\t            attrs: {\n\t                '.port-label': {\n\t                    text: port\n\t                }\n\t            }\n\t        };\n\t    },\n\n\t    createPortItems: function(group, ports) {\n\n\t        return toArray(ports).map(this.createPortItem.bind(this, group));\n\t    },\n\n\t    _addGroupPort: function(port, group, opt) {\n\n\t        var ports = this.get(group);\n\t        return this.set(group, Array.isArray(ports) ? ports.concat(port) : [port], opt);\n\t    },\n\n\t    addOutPort: function(port, opt) {\n\n\t        return this._addGroupPort(port, 'outPorts', opt);\n\t    },\n\n\t    addInPort: function(port, opt) {\n\n\t        return this._addGroupPort(port, 'inPorts', opt);\n\t    },\n\n\t    _removeGroupPort: function(port, group, opt) {\n\n\t        return this.set(group, without(this.get(group), port), opt);\n\t    },\n\n\t    removeOutPort: function(port, opt) {\n\n\t        return this._removeGroupPort(port, 'outPorts', opt);\n\t    },\n\n\t    removeInPort: function(port, opt) {\n\n\t        return this._removeGroupPort(port, 'inPorts', opt);\n\t    },\n\n\t    _changeGroup: function(group, properties, opt) {\n\n\t        return this.prop('ports/groups/' + group, isObject$1(properties) ? properties : {}, opt);\n\t    },\n\n\t    changeInGroup: function(properties, opt) {\n\n\t        return this._changeGroup('in', properties, opt);\n\t    },\n\n\t    changeOutGroup: function(properties, opt) {\n\n\t        return this._changeGroup('out', properties, opt);\n\t    }\n\t});\n\n\tvar Atomic = Model.define('devs.Atomic', {\n\t    size: {\n\t        width: 80,\n\t        height: 80\n\t    },\n\t    attrs: {\n\t        '.label': {\n\t            text: 'Atomic'\n\t        }\n\t    }\n\t});\n\n\tvar Coupled = Model.define('devs.Coupled', {\n\t    size: {\n\t        width: 200,\n\t        height: 300\n\t    },\n\t    attrs: {\n\t        '.label': {\n\t            text: 'Coupled'\n\t        }\n\t    }\n\t});\n\n\tvar Link$2 = Link.define('devs.Link', {\n\t    attrs: {\n\t        '.connection': {\n\t            'stroke-width': 2\n\t        }\n\t    }\n\t});\n\n\tvar devs = ({\n\t\tModel: Model,\n\t\tAtomic: Atomic,\n\t\tCoupled: Coupled,\n\t\tLink: Link$2\n\t});\n\n\tvar Gate = Generic.define('logic.Gate', {\n\t    size: { width: 80, height: 40 },\n\t    attrs: {\n\t        '.': { magnet: false },\n\t        '.body': { width: 100, height: 50 },\n\t        circle: { r: 7, stroke: 'black', fill: 'transparent', 'stroke-width': 2 }\n\t    }\n\t}, {\n\t    operation: function() {\n\t        return true;\n\t    }\n\t});\n\n\tvar IO = Gate.define('logic.IO', {\n\t    size: { width: 60, height: 30 },\n\t    attrs: {\n\t        '.body': { fill: 'white', stroke: 'black', 'stroke-width': 2 },\n\t        '.wire': { ref: '.body', 'ref-y': .5, stroke: 'black' },\n\t        text: {\n\t            fill: 'black',\n\t            ref: '.body', 'ref-x': .5, 'ref-y': .5, 'y-alignment': 'middle',\n\t            'text-anchor': 'middle',\n\t            'font-weight': 'bold',\n\t            'font-variant': 'small-caps',\n\t            'text-transform': 'capitalize',\n\t            'font-size': '14px'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"body\"/></g><path class=\"wire\"/><circle/><text/></g>',\n\t});\n\n\tvar Input = IO.define('logic.Input', {\n\t    attrs: {\n\t        '.wire': { 'ref-dx': 0, d: 'M 0 0 L 23 0' },\n\t        circle: { ref: '.body', 'ref-dx': 30, 'ref-y': 0.5, magnet: true, 'class': 'output', port: 'out' },\n\t        text: { text: 'input' }\n\t    }\n\t});\n\n\tvar Output = IO.define('logic.Output', {\n\t    attrs: {\n\t        '.wire': { 'ref-x': 0, d: 'M 0 0 L -23 0' },\n\t        circle: { ref: '.body', 'ref-x': -30, 'ref-y': 0.5, magnet: 'passive', 'class': 'input', port: 'in' },\n\t        text: { text: 'output' }\n\t    }\n\t});\n\n\tvar Gate11 = Gate.define('logic.Gate11', {\n\t    attrs: {\n\t        '.input': { ref: '.body', 'ref-x': -2, 'ref-y': 0.5, magnet: 'passive', port: 'in' },\n\t        '.output': { ref: '.body', 'ref-dx': 2, 'ref-y': 0.5, magnet: true, port: 'out' }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input\"/><circle class=\"output\"/></g>',\n\t});\n\n\tvar Gate21 = Gate.define('logic.Gate21', {\n\t    attrs: {\n\t        '.input1': { ref: '.body', 'ref-x': -2, 'ref-y': 0.3, magnet: 'passive', port: 'in1' },\n\t        '.input2': { ref: '.body', 'ref-x': -2, 'ref-y': 0.7, magnet: 'passive', port: 'in2' },\n\t        '.output': { ref: '.body', 'ref-dx': 2, 'ref-y': 0.5, magnet: true, port: 'out' }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><image class=\"body\"/></g><circle class=\"input input1\"/><circle  class=\"input input2\"/><circle class=\"output\"/></g>',\n\t});\n\n\tvar Repeater = Gate11.define('logic.Repeater', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo=' }}\n\t}, {\n\t    operation: function(input) {\n\t        return input;\n\t    }\n\t});\n\n\tvar Not = Gate11.define('logic.Not', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K' }}\n\t}, {\n\t    operation: function(input) {\n\t        return !input;\n\t    }\n\t});\n\n\tvar Or = Gate21.define('logic.Or', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo=' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return input1 || input2;\n\t    }\n\t});\n\n\tvar And = Gate21.define('logic.And', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\n\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return input1 && input2;\n\t    }\n\t});\n\n\tvar Nor = Gate21.define('logic.Nor', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return !(input1 || input2);\n\t    }\n\t});\n\n\tvar Nand = Gate21.define('logic.Nand', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return !(input1 && input2);\n\t    }\n\t});\n\n\tvar Xor = Gate21.define('logic.Xor', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return (!input1 || input2) && (input1 || !input2);\n\t    }\n\t});\n\n\tvar Xnor = Gate21.define('logic.Xnor', {\n\t    attrs: { image: { 'xlink:href': 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==' }}\n\t}, {\n\t    operation: function(input1, input2) {\n\t        return (!input1 || !input2) && (input1 || input2);\n\t    }\n\t});\n\n\tvar Wire = Link.define('logic.Wire', {\n\t    attrs: {\n\t        '.connection': { 'stroke-width': 2 },\n\t        '.marker-vertex': { r: 7 }\n\t    },\n\n\t    router: { name: 'orthogonal' },\n\t    connector: { name: 'rounded', args: { radius: 10 }}\n\t}, {\n\t    arrowheadMarkup: [\n\t        '<g class=\"marker-arrowhead-group marker-arrowhead-group-<%= end %>\">',\n\t        '<circle class=\"marker-arrowhead\" end=\"<%= end %>\" r=\"7\"/>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    vertexMarkup: [\n\t        '<g class=\"marker-vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">',\n\t        '<circle class=\"marker-vertex\" idx=\"<%= idx %>\" r=\"10\" />',\n\t        '<g class=\"marker-vertex-remove-group\">',\n\t        '<path class=\"marker-vertex-remove-area\" idx=\"<%= idx %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>',\n\t        '<path class=\"marker-vertex-remove\" idx=\"<%= idx %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">',\n\t        '<title>Remove vertex.</title>',\n\t        '</path>',\n\t        '</g>',\n\t        '</g>'\n\t    ].join('')\n\t});\n\n\tvar logic = ({\n\t\tGate: Gate,\n\t\tIO: IO,\n\t\tInput: Input,\n\t\tOutput: Output,\n\t\tGate11: Gate11,\n\t\tGate21: Gate21,\n\t\tRepeater: Repeater,\n\t\tNot: Not,\n\t\tOr: Or,\n\t\tAnd: And,\n\t\tNor: Nor,\n\t\tNand: Nand,\n\t\tXor: Xor,\n\t\tXnor: Xnor,\n\t\tWire: Wire\n\t});\n\n\tvar KingWhite = Generic.define('chess.KingWhite', {\n\t    size: { width: 42, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\"><path      d=\"M 22.5,11.63 L 22.5,6\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 20,8 L 25,8\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path      d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"      style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 11.5,30 C 17,27 27,27 32.5,30\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5\"      style=\"fill:none; stroke:#000000;\" />    <path      d=\"M 11.5,37 C 17,34 27,34 32.5,37\"      style=\"fill:none; stroke:#000000;\" />  </g></g></g>'\n\t});\n\n\tvar KingBlack = Generic.define('chess.KingBlack', {\n\t    size: { width: 42, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path       d=\"M 22.5,11.63 L 22.5,6\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\"       id=\"path6570\" />    <path       d=\"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\"       style=\"fill:#000000;fill-opacity:1; stroke-linecap:butt; stroke-linejoin:miter;\" />    <path       d=\"M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z \"       style=\"fill:#000000; stroke:#000000;\" />    <path       d=\"M 20,8 L 25,8\"       style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />    <path       d=\"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>'\n\t});\n\n\tvar QueenWhite = Generic.define('chess.QueenWhite', {\n\t    size: { width: 42, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(-1,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(15.5,-5.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(32,-1)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(7,-4.5)\" />    <path      d=\"M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z\"      transform=\"translate(24,-4)\" />    <path      d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11.5,30 C 15,29 30,29 33.5,30\"      style=\"fill:none;\" />    <path      d=\"M 12,33.5 C 18,32.5 27,32.5 33,33.5\"      style=\"fill:none;\" />  </g></g></g>'\n\t});\n\n\tvar QueenBlack = Generic.define('chess.QueenBlack', {\n\t    size: { width: 42, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:none;\">      <circle cx=\"6\"    cy=\"12\" r=\"2.75\" />      <circle cx=\"14\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"22.5\" cy=\"8\"  r=\"2.75\" />      <circle cx=\"31\"   cy=\"9\"  r=\"2.75\" />      <circle cx=\"39\"   cy=\"12\" r=\"2.75\" />    </g>    <path       d=\"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"       style=\"stroke-linecap:butt; stroke:#000000;\" />    <path       d=\"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"       style=\"stroke-linecap:butt;\" />    <path       d=\"M 11,38.5 A 35,35 1 0 0 34,38.5\"       style=\"fill:none; stroke:#000000; stroke-linecap:butt;\" />    <path       d=\"M 11,29 A 35,35 1 0 1 34,29\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 12.5,31.5 L 32.5,31.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"       style=\"fill:none; stroke:#ffffff;\" />    <path       d=\"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"       style=\"fill:none; stroke:#ffffff;\" />  </g></g></g>'\n\t});\n\n\tvar RookWhite = Generic.define('chess.RookWhite', {\n\t    size: { width: 32, height: 34 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 34,14 L 31,17 L 14,17 L 11,14\" />    <path      d=\"M 31,17 L 31,29.5 L 14,29.5 L 14,17\"      style=\"stroke-linecap:butt; stroke-linejoin:miter;\" />    <path      d=\"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>'\n\t});\n\n\tvar RookBlack = Generic.define('chess.RookBlack', {\n\t    size: { width: 32, height: 34 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \"      style=\"stroke-linecap:butt;stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \"      style=\"stroke-linecap:butt;\" />    <path      d=\"M 12,35.5 L 33,35.5 L 33,35.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 13,31.5 L 32,31.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,29.5 L 31,29.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 14,16.5 L 31,16.5\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />    <path      d=\"M 11,14 L 34,14\"      style=\"fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;\" />  </g></g></g>'\n\t});\n\n\tvar BishopWhite = Generic.define('chess.BishopWhite', {\n\t    size: { width: 38, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#ffffff; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path      d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"      style=\"fill:none; stroke:#000000; stroke-linejoin:miter;\" />  </g></g></g>'\n\t});\n\n\tvar BishopBlack = Generic.define('chess.BishopBlack', {\n\t    size: { width: 38, height: 38 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <g style=\"fill:#000000; stroke:#000000; stroke-linecap:butt;\">       <path        d=\"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z\" />      <path        d=\"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" />      <path        d=\"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" />    </g>    <path       d=\"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\"       style=\"fill:none; stroke:#ffffff; stroke-linejoin:miter;\" />  </g></g></g>'\n\t});\n\n\tvar KnightWhite = Generic.define('chess.KnightWhite', {\n\t    size: { width: 38, height: 37 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#ffffff; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#000000; stroke:#000000;\" />  </g></g></g>'\n\t});\n\n\tvar KnightBlack = Generic.define('chess.KnightBlack', {\n\t    size: { width: 38, height: 37 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><g style=\"opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\">    <path      d=\"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\"      style=\"fill:#000000; stroke:#000000;\" />    <path      d=\"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\"      transform=\"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\"      style=\"fill:#ffffff; stroke:#ffffff;\" />    <path      d=\"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \"      style=\"fill:#ffffff; stroke:none;\" />  </g></g></g>'\n\t});\n\n\tvar PawnWhite = Generic.define('chess.PawnWhite', {\n\t    size: { width: 28, height: 33 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>'\n\t});\n\n\tvar PawnBlack = Generic.define('chess.PawnBlack', {\n\t    size: { width: 28, height: 33 }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><path d=\"M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z \"  style=\"opacity:1; fill:#000000; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;\" /></g></g>'\n\t});\n\n\tvar chess = ({\n\t\tKingWhite: KingWhite,\n\t\tKingBlack: KingBlack,\n\t\tQueenWhite: QueenWhite,\n\t\tQueenBlack: QueenBlack,\n\t\tRookWhite: RookWhite,\n\t\tRookBlack: RookBlack,\n\t\tBishopWhite: BishopWhite,\n\t\tBishopBlack: BishopBlack,\n\t\tKnightWhite: KnightWhite,\n\t\tKnightBlack: KnightBlack,\n\t\tPawnWhite: PawnWhite,\n\t\tPawnBlack: PawnBlack\n\t});\n\n\tvar Entity = Element$1.define('erd.Entity', {\n\t    size: { width: 150, height: 60 },\n\t    attrs: {\n\t        '.outer': {\n\t            fill: '#2ECC71', stroke: '#27AE60', 'stroke-width': 2,\n\t            points: '100,0 100,60 0,60 0,0'\n\t        },\n\t        '.inner': {\n\t            fill: '#2ECC71', stroke: '#27AE60', 'stroke-width': 2,\n\t            points: '95,5 95,55 5,55 5,5',\n\t            display: 'none'\n\t        },\n\t        text: {\n\t            text: 'Entity',\n\t            'font-family': 'Arial', 'font-size': 14,\n\t            'ref-x': .5, 'ref-y': .5,\n\t            'y-alignment': 'middle', 'text-anchor': 'middle'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>',\n\t});\n\n\tvar WeakEntity = Entity.define('erd.WeakEntity', {\n\t    attrs: {\n\t        '.inner': { display: 'auto' },\n\t        text: { text: 'Weak Entity' }\n\t    }\n\t});\n\n\tvar Relationship = Element$1.define('erd.Relationship', {\n\t    size: { width: 80, height: 80 },\n\t    attrs: {\n\t        '.outer': {\n\t            fill: '#3498DB', stroke: '#2980B9', 'stroke-width': 2,\n\t            points: '40,0 80,40 40,80 0,40'\n\t        },\n\t        '.inner': {\n\t            fill: '#3498DB', stroke: '#2980B9', 'stroke-width': 2,\n\t            points: '40,5 75,40 40,75 5,40',\n\t            display: 'none'\n\t        },\n\t        text: {\n\t            text: 'Relationship',\n\t            'font-family': 'Arial', 'font-size': 12,\n\t            'ref-x': .5, 'ref-y': .5,\n\t            'y-alignment': 'middle', 'text-anchor': 'middle'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon class=\"outer\"/><polygon class=\"inner\"/></g><text/></g>',\n\t});\n\n\tvar IdentifyingRelationship = Relationship.define('erd.IdentifyingRelationship', {\n\t    attrs: {\n\t        '.inner': { display: 'auto' },\n\t        text: { text: 'Identifying' }\n\t    }\n\t});\n\n\tvar Attribute = Element$1.define('erd.Attribute', {\n\t    size: { width: 100, height: 50 },\n\t    attrs: {\n\t        'ellipse': {\n\t            transform: 'translate(50, 25)'\n\t        },\n\t        '.outer': {\n\t            stroke: '#D35400', 'stroke-width': 2,\n\t            cx: 0, cy: 0, rx: 50, ry: 25,\n\t            fill: '#E67E22'\n\t        },\n\t        '.inner': {\n\t            stroke: '#D35400', 'stroke-width': 2,\n\t            cx: 0, cy: 0, rx: 45, ry: 20,\n\t            fill: '#E67E22', display: 'none'\n\t        },\n\t        text: {\n\t            'font-family': 'Arial', 'font-size': 14,\n\t            'ref-x': .5, 'ref-y': .5,\n\t            'y-alignment': 'middle', 'text-anchor': 'middle'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><ellipse class=\"outer\"/><ellipse class=\"inner\"/></g><text/></g>',\n\t});\n\n\tvar Multivalued = Attribute.define('erd.Multivalued', {\n\t    attrs: {\n\t        '.inner': { display: 'block' },\n\t        text: { text: 'multivalued' }\n\t    }\n\t});\n\n\tvar Derived = Attribute.define('erd.Derived', {\n\t    attrs: {\n\t        '.outer': { 'stroke-dasharray': '3,5' },\n\t        text: { text: 'derived' }\n\t    }\n\t});\n\n\tvar Key = Attribute.define('erd.Key', {\n\t    attrs: {\n\t        ellipse: { 'stroke-width': 4 },\n\t        text: { text: 'key', 'font-weight': '800', 'text-decoration': 'underline' }\n\t    }\n\t});\n\n\tvar Normal = Attribute.define('erd.Normal', {\n\t    attrs: { text: { text: 'Normal' }}\n\t});\n\n\tvar ISA = Element$1.define('erd.ISA', {\n\t    type: 'erd.ISA',\n\t    size: { width: 100, height: 50 },\n\t    attrs: {\n\t        polygon: {\n\t            points: '0,0 50,50 100,0',\n\t            fill: '#F1C40F', stroke: '#F39C12', 'stroke-width': 2\n\t        },\n\t        text: {\n\t            text: 'ISA', 'font-size': 18,\n\t            'ref-x': .5, 'ref-y': .3,\n\t            'y-alignment': 'middle', 'text-anchor': 'middle'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><polygon/></g><text/></g>',\n\t});\n\n\tvar Line$1 = Link.define('erd.Line', {}, {\n\t    cardinality: function(value) {\n\t        this.set('labels', [{ position: -20, attrs: { text: { dy: -8, text: value }}}]);\n\t    }\n\t});\n\n\tvar erd = ({\n\t\tEntity: Entity,\n\t\tWeakEntity: WeakEntity,\n\t\tRelationship: Relationship,\n\t\tIdentifyingRelationship: IdentifyingRelationship,\n\t\tAttribute: Attribute,\n\t\tMultivalued: Multivalued,\n\t\tDerived: Derived,\n\t\tKey: Key,\n\t\tNormal: Normal,\n\t\tISA: ISA,\n\t\tLine: Line$1\n\t});\n\n\tvar State = Circle.define('fsa.State', {\n\t    attrs: {\n\t        circle: { 'stroke-width': 3 },\n\t        text: { 'font-weight': '800' }\n\t    }\n\t});\n\n\tvar StartState = Element$1.define('fsa.StartState', {\n\t    size: { width: 20, height: 20 },\n\t    attrs: {\n\t        circle: {\n\t            transform: 'translate(10, 10)',\n\t            r: 10,\n\t            fill: '#000000'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle/></g></g>',\n\t});\n\n\tvar EndState = Element$1.define('fsa.EndState', {\n\t    size: { width: 20, height: 20 },\n\t    attrs: {\n\t        '.outer': {\n\t            transform: 'translate(10, 10)',\n\t            r: 10,\n\t            fill: '#ffffff',\n\t            stroke: '#000000'\n\t        },\n\n\t        '.inner': {\n\t            transform: 'translate(10, 10)',\n\t            r: 6,\n\t            fill: '#000000'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>',\n\t});\n\n\tvar Arrow = Link.define('fsa.Arrow', {\n\t    attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' }},\n\t    smooth: true\n\t});\n\n\tvar fsa = ({\n\t\tState: State,\n\t\tStartState: StartState,\n\t\tEndState: EndState,\n\t\tArrow: Arrow\n\t});\n\n\tvar Member = Element$1.define('org.Member', {\n\t    size: { width: 180, height: 70 },\n\t    attrs: {\n\t        rect: { width: 170, height: 60 },\n\n\t        '.card': {\n\t            fill: '#FFFFFF', stroke: '#000000', 'stroke-width': 2,\n\t            'pointer-events': 'visiblePainted', rx: 10, ry: 10\n\t        },\n\n\t        image: {\n\t            width: 48, height: 48,\n\t            ref: '.card', 'ref-x': 10, 'ref-y': 5\n\t        },\n\n\t        '.rank': {\n\t            'text-decoration': 'underline',\n\t            ref: '.card', 'ref-x': 0.9, 'ref-y': 0.2,\n\t            'font-family': 'Courier New', 'font-size': 14,\n\t            'text-anchor': 'end'\n\t        },\n\n\t        '.name': {\n\t            'font-weight': '800',\n\t            ref: '.card', 'ref-x': 0.9, 'ref-y': 0.6,\n\t            'font-family': 'Courier New', 'font-size': 14,\n\t            'text-anchor': 'end'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"card\"/><image/></g><text class=\"rank\"/><text class=\"name\"/></g>',\n\t});\n\n\tvar Arrow$1 = Link.define('org.Arrow', {\n\t    source: { selector: '.card' }, target: { selector: '.card' },\n\t    attrs: { '.connection': { stroke: '#585858', 'stroke-width': 3 }},\n\t    z: -1\n\t});\n\n\tvar org = ({\n\t\tMember: Member,\n\t\tArrow: Arrow$1\n\t});\n\n\tvar Place = Generic.define('pn.Place', {\n\t    size: { width: 50, height: 50 },\n\t    attrs: {\n\t        '.root': {\n\t            r: 25,\n\t            fill: '#ffffff',\n\t            stroke: '#000000',\n\t            transform: 'translate(25, 25)'\n\t        },\n\t        '.label': {\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-y': -20,\n\t            ref: '.root',\n\t            fill: '#000000',\n\t            'font-size': 12\n\t        },\n\t        '.tokens > circle': {\n\t            fill: '#000000',\n\t            r: 5\n\t        },\n\t        '.tokens.one > circle': { transform: 'translate(25, 25)' },\n\n\t        '.tokens.two > circle:nth-child(1)': { transform: 'translate(19, 25)' },\n\t        '.tokens.two > circle:nth-child(2)': { transform: 'translate(31, 25)' },\n\n\t        '.tokens.three > circle:nth-child(1)': { transform: 'translate(18, 29)' },\n\t        '.tokens.three > circle:nth-child(2)': { transform: 'translate(25, 19)' },\n\t        '.tokens.three > circle:nth-child(3)': { transform: 'translate(32, 29)' },\n\n\t        '.tokens.alot > text': {\n\t            transform: 'translate(25, 18)',\n\t            'text-anchor': 'middle',\n\t            fill: '#000000'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"root\"/><g class=\"tokens\" /></g><text class=\"label\"/></g>',\n\t});\n\n\tvar PlaceView = ElementView.extend({\n\n\t    presentationAttributes: ElementView.addPresentationAttributes({\n\t        tokens: ['TOKENS']\n\t    }),\n\n\t    initFlag: ElementView.prototype.initFlag.concat(['TOKENS']),\n\n\t    confirmUpdate: function() {\n\t        var ref;\n\n\t        var args = [], len = arguments.length;\n\t        while ( len-- ) args[ len ] = arguments[ len ];\n\t        var flags = (ref = ElementView.prototype.confirmUpdate).call.apply(ref, [ this ].concat( args ));\n\t        if (this.hasFlag(flags, 'TOKENS')) {\n\t            this.renderTokens();\n\t            this.update();\n\t            flags = this.removeFlag(flags, 'TOKENS');\n\t        }\n\t        return flags;\n\t    },\n\n\t    renderTokens: function() {\n\n\t        var vTokens = this.vel.findOne('.tokens').empty();\n\t        ['one', 'two', 'three', 'alot'].forEach(function(className) {\n\t            vTokens.removeClass(className);\n\t        });\n\n\t        var tokens = this.model.get('tokens');\n\t        if (!tokens) { return; }\n\n\t        switch (tokens) {\n\n\t            case 1:\n\t                vTokens.addClass('one');\n\t                vTokens.append(V('circle'));\n\t                break;\n\n\t            case 2:\n\t                vTokens.addClass('two');\n\t                vTokens.append([V('circle'), V('circle')]);\n\t                break;\n\n\t            case 3:\n\t                vTokens.addClass('three');\n\t                vTokens.append([V('circle'), V('circle'), V('circle')]);\n\t                break;\n\n\t            default:\n\t                vTokens.addClass('alot');\n\t                vTokens.append(V('text').text(tokens + ''));\n\t                break;\n\t        }\n\t    }\n\t});\n\n\tvar Transition = Generic.define('pn.Transition', {\n\t    size: { width: 12, height: 50 },\n\t    attrs: {\n\t        'rect': {\n\t            width: 12,\n\t            height: 50,\n\t            fill: '#000000',\n\t            stroke: '#000000'\n\t        },\n\t        '.label': {\n\t            'text-anchor': 'middle',\n\t            'ref-x': .5,\n\t            'ref-y': -20,\n\t            ref: 'rect',\n\t            fill: '#000000',\n\t            'font-size': 12\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><rect class=\"root\"/></g></g><text class=\"label\"/>',\n\t});\n\n\tvar Link$3 = Link.define('pn.Link', {\n\t    attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' }}\n\t});\n\n\tvar pn = ({\n\t\tPlace: Place,\n\t\tPlaceView: PlaceView,\n\t\tTransition: Transition,\n\t\tLink: Link$3\n\t});\n\n\tvar Class = Generic.define('uml.Class', {\n\t    attrs: {\n\t        rect: { 'width': 200 },\n\n\t        '.uml-class-name-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#3498db' },\n\t        '.uml-class-attrs-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#2980b9' },\n\t        '.uml-class-methods-rect': { 'stroke': 'black', 'stroke-width': 2, 'fill': '#2980b9' },\n\n\t        '.uml-class-name-text': {\n\t            'ref': '.uml-class-name-rect',\n\t            'ref-y': .5,\n\t            'ref-x': .5,\n\t            'text-anchor': 'middle',\n\t            'y-alignment': 'middle',\n\t            'font-weight': 'bold',\n\t            'fill': 'black',\n\t            'font-size': 12,\n\t            'font-family': 'Times New Roman'\n\t        },\n\t        '.uml-class-attrs-text': {\n\t            'ref': '.uml-class-attrs-rect', 'ref-y': 5, 'ref-x': 5,\n\t            'fill': 'black', 'font-size': 12, 'font-family': 'Times New Roman'\n\t        },\n\t        '.uml-class-methods-text': {\n\t            'ref': '.uml-class-methods-rect', 'ref-y': 5, 'ref-x': 5,\n\t            'fill': 'black', 'font-size': 12, 'font-family': 'Times New Roman'\n\t        }\n\t    },\n\n\t    name: [],\n\t    attributes: [],\n\t    methods: []\n\t}, {\n\t    markup: [\n\t        '<g class=\"rotatable\">',\n\t        '<g class=\"scalable\">',\n\t        '<rect class=\"uml-class-name-rect\"/><rect class=\"uml-class-attrs-rect\"/><rect class=\"uml-class-methods-rect\"/>',\n\t        '</g>',\n\t        '<text class=\"uml-class-name-text\"/><text class=\"uml-class-attrs-text\"/><text class=\"uml-class-methods-text\"/>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    initialize: function() {\n\n\t        this.on('change:name change:attributes change:methods', function() {\n\t            this.updateRectangles();\n\t            this.trigger('uml-update');\n\t        }, this);\n\n\t        this.updateRectangles();\n\n\t        Generic.prototype.initialize.apply(this, arguments);\n\t    },\n\n\t    getClassName: function() {\n\t        return this.get('name');\n\t    },\n\n\t    updateRectangles: function() {\n\n\t        var attrs = this.get('attrs');\n\n\t        var rects = [\n\t            { type: 'name', text: this.getClassName() },\n\t            { type: 'attrs', text: this.get('attributes') },\n\t            { type: 'methods', text: this.get('methods') }\n\t        ];\n\n\t        var offsetY = 0;\n\n\t        rects.forEach(function(rect) {\n\n\t            var lines = Array.isArray(rect.text) ? rect.text : [rect.text];\n\t            var rectHeight = lines.length * 20 + 20;\n\n\t            attrs['.uml-class-' + rect.type + '-text'].text = lines.join('\\n');\n\t            attrs['.uml-class-' + rect.type + '-rect'].height = rectHeight;\n\t            attrs['.uml-class-' + rect.type + '-rect'].transform = 'translate(0,' + offsetY + ')';\n\n\t            offsetY += rectHeight;\n\t        });\n\t    }\n\n\t});\n\n\tvar ClassView = ElementView.extend({\n\n\t    initialize: function() {\n\n\t        ElementView.prototype.initialize.apply(this, arguments);\n\n\t        this.listenTo(this.model, 'uml-update', function() {\n\t            this.update();\n\t            this.resize();\n\t        });\n\t    }\n\t});\n\n\tvar Abstract = Class.define('uml.Abstract', {\n\t    attrs: {\n\t        '.uml-class-name-rect': { fill: '#e74c3c' },\n\t        '.uml-class-attrs-rect': { fill: '#c0392b' },\n\t        '.uml-class-methods-rect': { fill: '#c0392b' }\n\t    }\n\t}, {\n\n\t    getClassName: function() {\n\t        return ['<<Abstract>>', this.get('name')];\n\t    }\n\n\t});\n\tvar AbstractView = ClassView;\n\n\tvar Interface = Class.define('uml.Interface', {\n\t    attrs: {\n\t        '.uml-class-name-rect': { fill: '#f1c40f' },\n\t        '.uml-class-attrs-rect': { fill: '#f39c12' },\n\t        '.uml-class-methods-rect': { fill: '#f39c12' }\n\t    }\n\t}, {\n\t    getClassName: function() {\n\t        return ['<<Interface>>', this.get('name')];\n\t    }\n\t});\n\tvar InterfaceView = ClassView;\n\n\tvar Generalization = Link.define('uml.Generalization', {\n\t    attrs: { '.marker-target': { d: 'M 20 0 L 0 10 L 20 20 z', fill: 'white' }}\n\t});\n\n\tvar Implementation = Link.define('uml.Implementation', {\n\t    attrs: {\n\t        '.marker-target': { d: 'M 20 0 L 0 10 L 20 20 z', fill: 'white' },\n\t        '.connection': { 'stroke-dasharray': '3,3' }\n\t    }\n\t});\n\n\tvar Aggregation = Link.define('uml.Aggregation', {\n\t    attrs: { '.marker-target': { d: 'M 40 10 L 20 20 L 0 10 L 20 0 z', fill: 'white' }}\n\t});\n\n\tvar Composition = Link.define('uml.Composition', {\n\t    attrs: { '.marker-target': { d: 'M 40 10 L 20 20 L 0 10 L 20 0 z', fill: 'black' }}\n\t});\n\n\tvar Association = Link.define('uml.Association');\n\n\t// Statechart\n\n\tvar State$1 = Generic.define('uml.State', {\n\t    attrs: {\n\t        '.uml-state-body': {\n\t            'width': 200, 'height': 200, 'rx': 10, 'ry': 10,\n\t            'fill': '#ecf0f1', 'stroke': '#bdc3c7', 'stroke-width': 3\n\t        },\n\t        '.uml-state-separator': {\n\t            'stroke': '#bdc3c7', 'stroke-width': 2\n\t        },\n\t        '.uml-state-name': {\n\t            'ref': '.uml-state-body', 'ref-x': .5, 'ref-y': 5, 'text-anchor': 'middle',\n\t            'fill': '#000000', 'font-family': 'Courier New', 'font-size': 14\n\t        },\n\t        '.uml-state-events': {\n\t            'ref': '.uml-state-separator', 'ref-x': 5, 'ref-y': 5,\n\t            'fill': '#000000', 'font-family': 'Courier New', 'font-size': 14\n\t        }\n\t    },\n\n\t    name: 'State',\n\t    events: []\n\n\t}, {\n\t    markup: [\n\t        '<g class=\"rotatable\">',\n\t        '<g class=\"scalable\">',\n\t        '<rect class=\"uml-state-body\"/>',\n\t        '</g>',\n\t        '<path class=\"uml-state-separator\"/>',\n\t        '<text class=\"uml-state-name\"/>',\n\t        '<text class=\"uml-state-events\"/>',\n\t        '</g>'\n\t    ].join(''),\n\n\t    initialize: function() {\n\n\t        this.on({\n\t            'change:name': this.updateName,\n\t            'change:events': this.updateEvents,\n\t            'change:size': this.updatePath\n\t        }, this);\n\n\t        this.updateName();\n\t        this.updateEvents();\n\t        this.updatePath();\n\n\t        Generic.prototype.initialize.apply(this, arguments);\n\t    },\n\n\t    updateName: function() {\n\n\t        this.attr('.uml-state-name/text', this.get('name'));\n\t    },\n\n\t    updateEvents: function() {\n\n\t        this.attr('.uml-state-events/text', this.get('events').join('\\n'));\n\t    },\n\n\t    updatePath: function() {\n\n\t        var d = 'M 0 20 L ' + this.get('size').width + ' 20';\n\n\t        // We are using `silent: true` here because updatePath() is meant to be called\n\t        // on resize and there's no need to to update the element twice (`change:size`\n\t        // triggers also an update).\n\t        this.attr('.uml-state-separator/d', d, { silent: true });\n\t    }\n\t});\n\n\tvar StartState$1 = Circle.define('uml.StartState', {\n\t    type: 'uml.StartState',\n\t    attrs: { circle: { 'fill': '#34495e', 'stroke': '#2c3e50', 'stroke-width': 2, 'rx': 1 }}\n\t});\n\n\tvar EndState$1 = Generic.define('uml.EndState', {\n\t    size: { width: 20, height: 20 },\n\t    attrs: {\n\t        'circle.outer': {\n\t            transform: 'translate(10, 10)',\n\t            r: 10,\n\t            fill: '#ffffff',\n\t            stroke: '#2c3e50'\n\t        },\n\n\t        'circle.inner': {\n\t            transform: 'translate(10, 10)',\n\t            r: 6,\n\t            fill: '#34495e'\n\t        }\n\t    }\n\t}, {\n\t    markup: '<g class=\"rotatable\"><g class=\"scalable\"><circle class=\"outer\"/><circle class=\"inner\"/></g></g>',\n\t});\n\n\tvar Transition$1 = Link.define('uml.Transition', {\n\t    attrs: {\n\t        '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z', fill: '#34495e', stroke: '#2c3e50' },\n\t        '.connection': { stroke: '#2c3e50' }\n\t    }\n\t});\n\n\tvar uml = ({\n\t\tClass: Class,\n\t\tClassView: ClassView,\n\t\tAbstract: Abstract,\n\t\tAbstractView: AbstractView,\n\t\tInterface: Interface,\n\t\tInterfaceView: InterfaceView,\n\t\tGeneralization: Generalization,\n\t\tImplementation: Implementation,\n\t\tAggregation: Aggregation,\n\t\tComposition: Composition,\n\t\tAssociation: Association,\n\t\tState: State$1,\n\t\tStartState: StartState$1,\n\t\tEndState: EndState$1,\n\t\tTransition: Transition$1\n\t});\n\n\n\n\tvar index$3 = ({\n\t\tbasic: basic,\n\t\tstandard: standard,\n\t\tdevs: devs,\n\t\tlogic: logic,\n\t\tchess: chess,\n\t\terd: erd,\n\t\tfsa: fsa,\n\t\torg: org,\n\t\tpn: pn,\n\t\tuml: uml\n\t});\n\n\tfunction abs2rel(value, max) {\n\n\t    if (max === 0) { return '0%'; }\n\t    return Math.round(value / max * 100) + '%';\n\t}\n\n\tfunction pin(relative) {\n\n\t    return function(end, view, magnet, coords) {\n\t        var fn = (view.isNodeConnection(magnet)) ? pinnedLinkEnd : pinnedElementEnd;\n\t        return fn(relative, end, view, magnet, coords);\n\t    };\n\t}\n\n\tfunction pinnedElementEnd(relative, end, view, magnet, coords) {\n\n\t    var angle = view.model.angle();\n\t    var bbox = view.getNodeUnrotatedBBox(magnet);\n\t    var origin = view.model.getBBox().center();\n\t    coords.rotate(origin, angle);\n\t    var dx = coords.x - bbox.x;\n\t    var dy = coords.y - bbox.y;\n\n\t    if (relative) {\n\t        dx = abs2rel(dx, bbox.width);\n\t        dy = abs2rel(dy, bbox.height);\n\t    }\n\n\t    end.anchor = {\n\t        name: 'topLeft',\n\t        args: {\n\t            dx: dx,\n\t            dy: dy,\n\t            rotate: true\n\t        }\n\t    };\n\n\t    return end;\n\t}\n\n\tfunction pinnedLinkEnd(relative, end, view, _magnet, coords) {\n\n\t    var connection = view.getConnection();\n\t    if (!connection) { return end; }\n\t    var length = connection.closestPointLength(coords);\n\t    if (relative) {\n\t        var totalLength = connection.length();\n\t        end.anchor = {\n\t            name: 'connectionRatio',\n\t            args: {\n\t                ratio: length / totalLength\n\t            }\n\t        };\n\t    } else {\n\t        end.anchor = {\n\t            name: 'connectionLength',\n\t            args: {\n\t                length: length\n\t            }\n\t        };\n\t    }\n\t    return end;\n\t}\n\n\tvar useDefaults = noop;\n\tvar pinAbsolute = pin(false);\n\tvar pinRelative = pin(true);\n\n\tvar index$4 = ({\n\t\tuseDefaults: useDefaults,\n\t\tpinAbsolute: pinAbsolute,\n\t\tpinRelative: pinRelative\n\t});\n\n\tfunction getAnchor(coords, view, magnet) {\n\t    // take advantage of an existing logic inside of the\n\t    // pin relative connection strategy\n\t    var end = pinRelative.call(\n\t        this.paper,\n\t        {},\n\t        view,\n\t        magnet,\n\t        coords,\n\t        this.model\n\t    );\n\t    return end.anchor;\n\t}\n\n\tfunction snapAnchor(coords, view, magnet, type, relatedView, toolView) {\n\t    var snapRadius = toolView.options.snapRadius;\n\t    var isSource = (type === 'source');\n\t    var refIndex = (isSource ? 0 : -1);\n\t    var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? 'target' : 'source');\n\t    if (ref) {\n\t        if (Math.abs(ref.x - coords.x) < snapRadius) { coords.x = ref.x; }\n\t        if (Math.abs(ref.y - coords.y) < snapRadius) { coords.y = ref.y; }\n\t    }\n\t    return coords;\n\t}\n\n\tfunction getViewBBox(view, useModelGeometry) {\n\t    var model = view.model;\n\t    if (useModelGeometry) { return model.getBBox(); }\n\t    return (model.isLink()) ? view.getConnection().bbox() : view.getNodeUnrotatedBBox(view.el);\n\t}\n\n\t// Vertex Handles\n\tvar VertexHandle = View.extend({\n\t    tagName: 'circle',\n\t    svgElement: true,\n\t    className: 'marker-vertex',\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown',\n\t        dblclick: 'onDoubleClick'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    attributes: {\n\t        'r': 6,\n\t        'fill': '#33334F',\n\t        'stroke': '#FFFFFF',\n\t        'stroke-width': 2,\n\t        'cursor': 'move'\n\t    },\n\t    position: function(x, y) {\n\t        this.vel.attr({ cx: x, cy: y });\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.options.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        this.options.paper.undelegateEvents();\n\t        this.delegateDocumentEvents(null, evt.data);\n\t        this.trigger('will-change', this, evt);\n\t    },\n\t    onPointerMove: function(evt) {\n\t        this.trigger('changing', this, evt);\n\t    },\n\t    onDoubleClick: function(evt) {\n\t        this.trigger('remove', this, evt);\n\t    },\n\t    onPointerUp: function(evt) {\n\t        this.trigger('changed', this, evt);\n\t        this.undelegateDocumentEvents();\n\t        this.options.paper.delegateEvents();\n\t    }\n\t});\n\n\tvar Vertices = ToolView.extend({\n\t    name: 'vertices',\n\t    options: {\n\t        handleClass: VertexHandle,\n\t        snapRadius: 20,\n\t        redundancyRemoval: true,\n\t        vertexAdding: true,\n\t        stopPropagation: true\n\t    },\n\t    children: [{\n\t        tagName: 'path',\n\t        selector: 'connection',\n\t        className: 'joint-vertices-path',\n\t        attributes: {\n\t            'fill': 'none',\n\t            'stroke': 'transparent',\n\t            'stroke-width': 10,\n\t            'cursor': 'cell'\n\t        }\n\t    }],\n\t    handles: null,\n\t    events: {\n\t        'mousedown .joint-vertices-path': 'onPathPointerDown',\n\t        'touchstart .joint-vertices-path': 'onPathPointerDown'\n\t    },\n\t    onRender: function() {\n\t        if (this.options.vertexAdding) {\n\t            this.renderChildren();\n\t            this.updatePath();\n\t        }\n\t        this.resetHandles();\n\t        this.renderHandles();\n\t        return this;\n\t    },\n\t    update: function() {\n\t        var relatedView = this.relatedView;\n\t        var vertices = relatedView.model.vertices();\n\t        if (vertices.length === this.handles.length) {\n\t            this.updateHandles();\n\t        } else {\n\t            this.resetHandles();\n\t            this.renderHandles();\n\t        }\n\t        if (this.options.vertexAdding) {\n\t            this.updatePath();\n\t        }\n\t        return this;\n\t    },\n\t    resetHandles: function() {\n\t        var handles = this.handles;\n\t        this.handles = [];\n\t        this.stopListening();\n\t        if (!Array.isArray(handles)) { return; }\n\t        for (var i = 0, n = handles.length; i < n; i++) {\n\t            handles[i].remove();\n\t        }\n\t    },\n\t    renderHandles: function() {\n\t        var this$1 = this;\n\n\t        var relatedView = this.relatedView;\n\t        var vertices = relatedView.model.vertices();\n\t        for (var i = 0, n = vertices.length; i < n; i++) {\n\t            var vertex = vertices[i];\n\t            var handle = new (this.options.handleClass)({\n\t                index: i,\n\t                paper: this.paper,\n\t                guard: function (evt) { return this$1.guard(evt); }\n\t            });\n\t            handle.render();\n\t            handle.position(vertex.x, vertex.y);\n\t            this.simulateRelatedView(handle.el);\n\t            handle.vel.appendTo(this.el);\n\t            this.handles.push(handle);\n\t            this.startHandleListening(handle);\n\t        }\n\t    },\n\t    updateHandles: function() {\n\t        var relatedView = this.relatedView;\n\t        var vertices = relatedView.model.vertices();\n\t        for (var i = 0, n = vertices.length; i < n; i++) {\n\t            var vertex = vertices[i];\n\t            var handle = this.handles[i];\n\t            if (!handle) { return; }\n\t            handle.position(vertex.x, vertex.y);\n\t        }\n\t    },\n\t    updatePath: function() {\n\t        var connection = this.childNodes.connection;\n\t        if (connection) { connection.setAttribute('d', this.relatedView.getSerializedConnection()); }\n\t    },\n\t    startHandleListening: function(handle) {\n\t        var relatedView = this.relatedView;\n\t        if (relatedView.can('vertexMove')) {\n\t            this.listenTo(handle, 'will-change', this.onHandleWillChange);\n\t            this.listenTo(handle, 'changing', this.onHandleChanging);\n\t            this.listenTo(handle, 'changed', this.onHandleChanged);\n\t        }\n\t        if (relatedView.can('vertexRemove')) {\n\t            this.listenTo(handle, 'remove', this.onHandleRemove);\n\t        }\n\t    },\n\t    getNeighborPoints: function(index) {\n\t        var linkView = this.relatedView;\n\t        var vertices = linkView.model.vertices();\n\t        var prev = (index > 0) ? vertices[index - 1] : linkView.sourceAnchor;\n\t        var next = (index < vertices.length - 1) ? vertices[index + 1] : linkView.targetAnchor;\n\t        return {\n\t            prev: new Point(prev),\n\t            next: new Point(next)\n\t        };\n\t    },\n\t    onHandleWillChange: function(_handle, evt) {\n\t        this.focus();\n\t        var ref = this;\n\t        var relatedView = ref.relatedView;\n\t        var options = ref.options;\n\t        relatedView.model.startBatch('vertex-move', { ui: true, tool: this.cid });\n\t        if (!options.stopPropagation) { relatedView.notifyPointerdown.apply(relatedView, relatedView.paper.getPointerArgs(evt)); }\n\t    },\n\t    onHandleChanging: function(handle, evt) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var linkView = ref.relatedView;\n\t        var index = handle.options.index;\n\t        var ref$1 = linkView.paper.getPointerArgs(evt);\n\t        var normalizedEvent = ref$1[0];\n\t        var x = ref$1[1];\n\t        var y = ref$1[2];\n\t        var vertex = { x: x, y: y };\n\t        this.snapVertex(vertex, index);\n\t        linkView.model.vertex(index, vertex, { ui: true, tool: this.cid });\n\t        handle.position(vertex.x, vertex.y);\n\t        if (!options.stopPropagation) { linkView.notifyPointermove(normalizedEvent, x, y); }\n\t    },\n\t    onHandleChanged: function(_handle, evt) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var linkView = ref.relatedView;\n\t        if (options.vertexAdding) { this.updatePath(); }\n\t        if (!options.redundancyRemoval) { return; }\n\t        var verticesRemoved = linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n\t        if (verticesRemoved) { this.render(); }\n\t        this.blur();\n\t        linkView.model.stopBatch('vertex-move', { ui: true, tool: this.cid });\n\t        if (this.eventData(evt).vertexAdded) {\n\t            linkView.model.stopBatch('vertex-add', { ui: true, tool: this.cid });\n\t        }\n\t        var ref$1 = linkView.paper.getPointerArgs(evt);\n\t        var normalizedEvt = ref$1[0];\n\t        var x = ref$1[1];\n\t        var y = ref$1[2];\n\t        if (!options.stopPropagation) { linkView.notifyPointerup(normalizedEvt, x, y); }\n\t        linkView.checkMouseleave(normalizedEvt);\n\t    },\n\t    snapVertex: function(vertex, index) {\n\t        var snapRadius = this.options.snapRadius;\n\t        if (snapRadius > 0) {\n\t            var neighbors = this.getNeighborPoints(index);\n\t            var prev = neighbors.prev;\n\t            var next = neighbors.next;\n\t            if (Math.abs(vertex.x - prev.x) < snapRadius) {\n\t                vertex.x = prev.x;\n\t            } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n\t                vertex.x = next.x;\n\t            }\n\t            if (Math.abs(vertex.y - prev.y) < snapRadius) {\n\t                vertex.y = neighbors.prev.y;\n\t            } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n\t                vertex.y = next.y;\n\t            }\n\t        }\n\t    },\n\t    onHandleRemove: function(handle, evt) {\n\t        var index$1 = handle.options.index;\n\t        var linkView = this.relatedView;\n\t        linkView.model.removeVertex(index$1, { ui: true });\n\t        if (this.options.vertexAdding) { this.updatePath(); }\n\t        linkView.checkMouseleave(normalizeEvent(evt));\n\t    },\n\t    onPathPointerDown: function(evt) {\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();\n\t        var relatedView = this.relatedView;\n\t        relatedView.model.startBatch('vertex-add', { ui: true, tool: this.cid });\n\t        var index$1 = relatedView.getVertexIndex(vertex.x, vertex.y);\n\t        this.snapVertex(vertex, index$1);\n\t        relatedView.model.insertVertex(index$1, vertex, { ui: true, tool: this.cid });\n\t        this.render();\n\t        var handle = this.handles[index$1];\n\t        this.eventData(normalizedEvent, { vertexAdded: true });\n\t        handle.onPointerDown(normalizedEvent);\n\t    },\n\t    onRemove: function() {\n\t        this.resetHandles();\n\t    }\n\t}, {\n\t    VertexHandle: VertexHandle // keep as class property\n\t});\n\n\tvar SegmentHandle = View.extend({\n\t    tagName: 'g',\n\t    svgElement: true,\n\t    className: 'marker-segment',\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    children: [{\n\t        tagName: 'line',\n\t        selector: 'line',\n\t        attributes: {\n\t            'stroke': '#33334F',\n\t            'stroke-width': 2,\n\t            'fill': 'none',\n\t            'pointer-events': 'none'\n\t        }\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'handle',\n\t        attributes: {\n\t            'width': 20,\n\t            'height': 8,\n\t            'x': -10,\n\t            'y': -4,\n\t            'rx': 4,\n\t            'ry': 4,\n\t            'fill': '#33334F',\n\t            'stroke': '#FFFFFF',\n\t            'stroke-width': 2\n\t        }\n\t    }],\n\t    onRender: function() {\n\t        this.renderChildren();\n\t    },\n\t    position: function(x, y, angle, view) {\n\n\t        var matrix = V.createSVGMatrix().translate(x, y).rotate(angle);\n\t        var handle = this.childNodes.handle;\n\t        handle.setAttribute('transform', V.matrixToTransformString(matrix));\n\t        handle.setAttribute('cursor', (angle % 180 === 0) ? 'row-resize' : 'col-resize');\n\n\t        var viewPoint = view.getClosestPoint(new Point(x, y));\n\t        var line = this.childNodes.line;\n\t        line.setAttribute('x1', x);\n\t        line.setAttribute('y1', y);\n\t        line.setAttribute('x2', viewPoint.x);\n\t        line.setAttribute('y2', viewPoint.y);\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.options.guard(evt)) { return; }\n\t        this.trigger('change:start', this, evt);\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        this.options.paper.undelegateEvents();\n\t        this.delegateDocumentEvents(null, evt.data);\n\t    },\n\t    onPointerMove: function(evt) {\n\t        this.trigger('changing', this, evt);\n\t    },\n\t    onPointerUp: function(evt) {\n\t        this.undelegateDocumentEvents();\n\t        this.options.paper.delegateEvents();\n\t        this.trigger('change:end', this, evt);\n\t    },\n\t    show: function() {\n\t        this.el.style.display = '';\n\t    },\n\t    hide: function() {\n\t        this.el.style.display = 'none';\n\t    }\n\t});\n\n\tvar Segments = ToolView.extend({\n\t    name: 'segments',\n\t    precision: .5,\n\t    options: {\n\t        handleClass: SegmentHandle,\n\t        segmentLengthThreshold: 40,\n\t        redundancyRemoval: true,\n\t        anchor: getAnchor,\n\t        snapRadius: 10,\n\t        snapHandle: true,\n\t        stopPropagation: true\n\t    },\n\t    handles: null,\n\t    onRender: function() {\n\t        this.resetHandles();\n\t        var relatedView = this.relatedView;\n\t        var vertices = relatedView.model.vertices();\n\t        vertices.unshift(relatedView.sourcePoint);\n\t        vertices.push(relatedView.targetPoint);\n\t        for (var i = 0, n = vertices.length; i < n - 1; i++) {\n\t            var vertex = vertices[i];\n\t            var nextVertex = vertices[i + 1];\n\t            var handle = this.renderHandle(vertex, nextVertex);\n\t            this.simulateRelatedView(handle.el);\n\t            this.handles.push(handle);\n\t            handle.options.index = i;\n\t        }\n\t        return this;\n\t    },\n\t    renderHandle: function(vertex, nextVertex) {\n\t        var this$1 = this;\n\n\t        var handle = new (this.options.handleClass)({\n\t            paper: this.paper,\n\t            guard: function (evt) { return this$1.guard(evt); }\n\t        });\n\t        handle.render();\n\t        this.updateHandle(handle, vertex, nextVertex);\n\t        handle.vel.appendTo(this.el);\n\t        this.startHandleListening(handle);\n\t        return handle;\n\t    },\n\t    update: function() {\n\t        this.render();\n\t        return this;\n\t    },\n\t    startHandleListening: function(handle) {\n\t        this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n\t        this.listenTo(handle, 'changing', this.onHandleChanging);\n\t        this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n\t    },\n\t    resetHandles: function() {\n\t        var handles = this.handles;\n\t        this.handles = [];\n\t        this.stopListening();\n\t        if (!Array.isArray(handles)) { return; }\n\t        for (var i = 0, n = handles.length; i < n; i++) {\n\t            handles[i].remove();\n\t        }\n\t    },\n\t    shiftHandleIndexes: function(value) {\n\t        var handles = this.handles;\n\t        for (var i = 0, n = handles.length; i < n; i++) { handles[i].options.index += value; }\n\t    },\n\t    resetAnchor: function(type, anchor) {\n\t        var relatedModel = this.relatedView.model;\n\t        if (anchor) {\n\t            relatedModel.prop([type, 'anchor'], anchor, {\n\t                rewrite: true,\n\t                ui: true,\n\t                tool: this.cid\n\t            });\n\t        } else {\n\t            relatedModel.removeProp([type, 'anchor'], {\n\t                ui: true,\n\t                tool: this.cid\n\t            });\n\t        }\n\t    },\n\t    snapHandle: function(handle, position, data) {\n\n\t        var index = handle.options.index;\n\t        var linkView = this.relatedView;\n\t        var link = linkView.model;\n\t        var vertices = link.vertices();\n\t        var axis = handle.options.axis;\n\t        var prev = vertices[index - 2] || data.sourceAnchor;\n\t        var next = vertices[index + 1] || data.targetAnchor;\n\t        var snapRadius = this.options.snapRadius;\n\t        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n\t            position[axis] = prev[axis];\n\t        } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n\t            position[axis] = next[axis];\n\t        }\n\t        return position;\n\t    },\n\n\t    onHandleChanging: function(handle, evt) {\n\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var data = this.eventData(evt);\n\t        var relatedView = this.relatedView;\n\t        var paper = relatedView.paper;\n\t        var index$1 = handle.options.index - 1;\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        var position = this.snapHandle(handle, coords.clone(), data);\n\t        var axis = handle.options.axis;\n\t        var offset = (this.options.snapHandle) ? 0 : (coords[axis] - position[axis]);\n\t        var link = relatedView.model;\n\t        var vertices = cloneDeep(link.vertices());\n\t        var vertex = vertices[index$1];\n\t        var nextVertex = vertices[index$1 + 1];\n\t        var anchorFn = this.options.anchor;\n\t        if (typeof anchorFn !== 'function') { anchorFn = null; }\n\n\t        // First Segment\n\t        var sourceView = relatedView.sourceView;\n\t        var sourceBBox = relatedView.sourceBBox;\n\t        var changeSourceAnchor = false;\n\t        var deleteSourceAnchor = false;\n\t        if (!vertex) {\n\t            vertex = relatedView.sourceAnchor.toJSON();\n\t            vertex[axis] = position[axis];\n\t            if (sourceBBox.containsPoint(vertex)) {\n\t                vertex[axis] = position[axis];\n\t                changeSourceAnchor = true;\n\t            } else {\n\t                // we left the area of the source magnet for the first time\n\t                vertices.unshift(vertex);\n\t                this.shiftHandleIndexes(1);\n\t                deleteSourceAnchor = true;\n\t            }\n\t        } else if (index$1 === 0) {\n\t            if (sourceBBox.containsPoint(vertex)) {\n\t                vertices.shift();\n\t                this.shiftHandleIndexes(-1);\n\t                changeSourceAnchor = true;\n\t            } else {\n\t                vertex[axis] = position[axis];\n\t                deleteSourceAnchor = true;\n\t            }\n\t        } else {\n\t            vertex[axis] = position[axis];\n\t        }\n\n\t        if (anchorFn && sourceView) {\n\t            if (changeSourceAnchor) {\n\t                var sourceAnchorPosition = data.sourceAnchor.clone();\n\t                sourceAnchorPosition[axis] = position[axis];\n\t                var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n\t                this.resetAnchor('source', sourceAnchor);\n\t            }\n\t            if (deleteSourceAnchor) {\n\t                this.resetAnchor('source', data.sourceAnchorDef);\n\t            }\n\t        }\n\n\t        // Last segment\n\t        var targetView = relatedView.targetView;\n\t        var targetBBox = relatedView.targetBBox;\n\t        var changeTargetAnchor = false;\n\t        var deleteTargetAnchor = false;\n\t        if (!nextVertex) {\n\t            nextVertex = relatedView.targetAnchor.toJSON();\n\t            nextVertex[axis] = position[axis];\n\t            if (targetBBox.containsPoint(nextVertex)) {\n\t                changeTargetAnchor = true;\n\t            } else {\n\t                // we left the area of the target magnet for the first time\n\t                vertices.push(nextVertex);\n\t                deleteTargetAnchor = true;\n\t            }\n\t        } else if (index$1 === vertices.length - 2) {\n\t            if (targetBBox.containsPoint(nextVertex)) {\n\t                vertices.pop();\n\t                changeTargetAnchor = true;\n\t            } else {\n\t                nextVertex[axis] = position[axis];\n\t                deleteTargetAnchor = true;\n\t            }\n\t        } else {\n\t            nextVertex[axis] = position[axis];\n\t        }\n\n\t        if (anchorFn && targetView) {\n\t            if (changeTargetAnchor) {\n\t                var targetAnchorPosition = data.targetAnchor.clone();\n\t                targetAnchorPosition[axis] = position[axis];\n\t                var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n\t                this.resetAnchor('target', targetAnchor);\n\t            }\n\t            if (deleteTargetAnchor) {\n\t                this.resetAnchor('target', data.targetAnchorDef);\n\t            }\n\t        }\n\n\t        link.vertices(vertices, { ui: true, tool: this.cid });\n\t        this.updateHandle(handle, vertex, nextVertex, offset);\n\t        if (!options.stopPropagation) { relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y); }\n\t    },\n\t    onHandleChangeStart: function(handle, evt) {\n\t        var ref = this;\n\t        var options = ref.options;\n\t        var handles = ref.handles;\n\t        var linkView = ref.relatedView;\n\t        var model = linkView.model;\n\t        var paper = linkView.paper;\n\t        var index$1 = handle.options.index;\n\t        if (!Array.isArray(handles)) { return; }\n\t        for (var i = 0, n = handles.length; i < n; i++) {\n\t            if (i !== index$1) { handles[i].hide(); }\n\t        }\n\t        this.focus();\n\t        this.eventData(evt, {\n\t            sourceAnchor: linkView.sourceAnchor.clone(),\n\t            targetAnchor: linkView.targetAnchor.clone(),\n\t            sourceAnchorDef: clone(model.prop(['source', 'anchor'])),\n\t            targetAnchorDef: clone(model.prop(['target', 'anchor']))\n\t        });\n\t        model.startBatch('segment-move', { ui: true, tool: this.cid });\n\t        if (!options.stopPropagation) { linkView.notifyPointerdown.apply(linkView, paper.getPointerArgs(evt)); }\n\t    },\n\t    onHandleChangeEnd: function(_handle, evt) {\n\t        var ref= this;\n\t        var options = ref.options;\n\t        var linkView = ref.relatedView;\n\t        var paper = linkView.paper;\n\t        var model = linkView.model;\n\t        if (options.redundancyRemoval) {\n\t            linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n\t        }\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        this.render();\n\t        this.blur();\n\t        model.stopBatch('segment-move', { ui: true, tool: this.cid });\n\t        if (!options.stopPropagation) { linkView.notifyPointerup(normalizedEvent, coords.x, coords.y); }\n\t        linkView.checkMouseleave(normalizedEvent);\n\t    },\n\t    updateHandle: function(handle, vertex, nextVertex, offset) {\n\t        var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n\t        var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n\t        if (vertical || horizontal) {\n\t            var segmentLine = new Line(vertex, nextVertex);\n\t            var length = segmentLine.length();\n\t            if (length < this.options.segmentLengthThreshold) {\n\t                handle.hide();\n\t            } else {\n\t                var position = segmentLine.midpoint();\n\t                var axis = (vertical) ? 'x' : 'y';\n\t                position[axis] += offset || 0;\n\t                var angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n\t                handle.position(position.x, position.y, angle, this.relatedView);\n\t                handle.show();\n\t                handle.options.axis = axis;\n\t            }\n\t        } else {\n\t            handle.hide();\n\t        }\n\t    },\n\t    onRemove: function() {\n\t        this.resetHandles();\n\t    }\n\t}, {\n\t    SegmentHandle: SegmentHandle // keep as class property\n\t});\n\n\t// End Markers\n\tvar Arrowhead = ToolView.extend({\n\t    tagName: 'path',\n\t    xAxisVector: new Point(1, 0),\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    onRender: function() {\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        var ratio = this.ratio;\n\t        var view = this.relatedView;\n\t        var tangent = view.getTangentAtRatio(ratio);\n\t        var position, angle;\n\t        if (tangent) {\n\t            position = tangent.start;\n\t            angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;\n\t        } else {\n\t            position = view.getPointAtRatio(ratio);\n\t            angle = 0;\n\t        }\n\t        if (!position) { return this; }\n\t        var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle);\n\t        this.vel.transform(matrix, { absolute: true });\n\t        return this;\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        var relatedView = this.relatedView;\n\t        relatedView.model.startBatch('arrowhead-move', { ui: true, tool: this.cid });\n\t        if (relatedView.can('arrowheadMove')) {\n\t            relatedView.startArrowheadMove(this.arrowheadType);\n\t            this.delegateDocumentEvents();\n\t            relatedView.paper.undelegateEvents();\n\t        }\n\t        this.focus();\n\t        this.el.style.pointerEvents = 'none';\n\t    },\n\t    onPointerMove: function(evt) {\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);\n\t    },\n\t    onPointerUp: function(evt) {\n\t        this.undelegateDocumentEvents();\n\t        var relatedView = this.relatedView;\n\t        var paper = relatedView.paper;\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        relatedView.pointerup(normalizedEvent, coords.x, coords.y);\n\t        paper.delegateEvents();\n\t        this.blur();\n\t        this.el.style.pointerEvents = '';\n\t        relatedView.model.stopBatch('arrowhead-move', { ui: true, tool: this.cid });\n\t    }\n\t});\n\n\tvar TargetArrowhead = Arrowhead.extend({\n\t    name: 'target-arrowhead',\n\t    ratio: 1,\n\t    arrowheadType: 'target',\n\t    attributes: {\n\t        'd': 'M -10 -8 10 0 -10 8 Z',\n\t        'fill': '#33334F',\n\t        'stroke': '#FFFFFF',\n\t        'stroke-width': 2,\n\t        'cursor': 'move',\n\t        'class': 'target-arrowhead'\n\t    }\n\t});\n\n\tvar SourceArrowhead = Arrowhead.extend({\n\t    name: 'source-arrowhead',\n\t    ratio: 0,\n\t    arrowheadType: 'source',\n\t    attributes: {\n\t        'd': 'M 10 -8 -10 0 10 8 Z',\n\t        'fill': '#33334F',\n\t        'stroke': '#FFFFFF',\n\t        'stroke-width': 2,\n\t        'cursor': 'move',\n\t        'class': 'source-arrowhead'\n\t    }\n\t});\n\n\tvar Button = ToolView.extend({\n\t    name: 'button',\n\t    events: {\n\t        'mousedown': 'onPointerDown',\n\t        'touchstart': 'onPointerDown'\n\t    },\n\t    options: {\n\t        distance: 0,\n\t        offset: 0,\n\t        rotate: false\n\t    },\n\t    onRender: function() {\n\t        this.renderChildren(this.options.markup);\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        this.position();\n\t        return this;\n\t    },\n\t    position: function() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var vel = ref.vel;\n\t        var matrix = view.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();\n\t        vel.transform(matrix, { absolute: true });\n\t    },\n\t    getElementMatrix: function getElementMatrix() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var options = ref.options;\n\t        var x = options.x; if ( x === void 0 ) x = 0;\n\t        var y = options.y; if ( y === void 0 ) y = 0;\n\t        var offset = options.offset; if ( offset === void 0 ) offset = {};\n\t        var useModelGeometry = options.useModelGeometry;\n\t        var rotate = options.rotate;\n\t        var bbox = getViewBBox(view, useModelGeometry);\n\t        var angle = view.model.angle();\n\t        if (!rotate) { bbox = bbox.bbox(angle); }\n\t        var offsetX = offset.x; if ( offsetX === void 0 ) offsetX = 0;\n\t        var offsetY = offset.y; if ( offsetY === void 0 ) offsetY = 0;\n\t        if (isPercentage(x)) {\n\t            x = parseFloat(x) / 100 * bbox.width;\n\t        }\n\t        if (isPercentage(y)) {\n\t            y = parseFloat(y) / 100 * bbox.height;\n\t        }\n\t        var matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\t        if (rotate) { matrix = matrix.rotate(angle); }\n\t        matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n\t        return matrix;\n\t    },\n\t    getLinkMatrix: function getLinkMatrix() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var options = ref.options;\n\t        var offset = options.offset; if ( offset === void 0 ) offset = 0;\n\t        var distance = options.distance; if ( distance === void 0 ) distance = 0;\n\t        var rotate = options.rotate;\n\t        var tangent, position, angle;\n\t        if (isPercentage(distance)) {\n\t            tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n\t        } else {\n\t            tangent = view.getTangentAtLength(distance);\n\t        }\n\t        if (tangent) {\n\t            position = tangent.start;\n\t            angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;\n\t        } else {\n\t            position = view.getConnection().start;\n\t            angle = 0;\n\t        }\n\t        var matrix = V.createSVGMatrix()\n\t            .translate(position.x, position.y)\n\t            .rotate(angle)\n\t            .translate(0, offset);\n\t        if (!rotate) { matrix = matrix.rotate(-angle); }\n\t        return matrix;\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        var actionFn = this.options.action;\n\t        if (typeof actionFn === 'function') {\n\t            actionFn.call(this.relatedView, evt, this.relatedView, this);\n\t        }\n\t    }\n\t});\n\n\n\tvar Remove = Button.extend({\n\t    children: [{\n\t        tagName: 'circle',\n\t        selector: 'button',\n\t        attributes: {\n\t            'r': 7,\n\t            'fill': '#FF1D00',\n\t            'cursor': 'pointer'\n\t        }\n\t    }, {\n\t        tagName: 'path',\n\t        selector: 'icon',\n\t        attributes: {\n\t            'd': 'M -3 -3 3 3 M -3 3 3 -3',\n\t            'fill': 'none',\n\t            'stroke': '#FFFFFF',\n\t            'stroke-width': 2,\n\t            'pointer-events': 'none'\n\t        }\n\t    }],\n\t    options: {\n\t        distance: 60,\n\t        offset: 0,\n\t        action: function(evt, view, tool) {\n\t            view.model.remove({ ui: true, tool: tool.cid });\n\t        }\n\t    }\n\t});\n\n\tvar Boundary = ToolView.extend({\n\t    name: 'boundary',\n\t    tagName: 'rect',\n\t    options: {\n\t        padding: 10,\n\t        useModelGeometry: false,\n\t    },\n\t    attributes: {\n\t        'fill': 'none',\n\t        'stroke': '#33334F',\n\t        'stroke-width': .5,\n\t        'stroke-dasharray': '5, 5',\n\t        'pointer-events': 'none'\n\t    },\n\t    onRender: function() {\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        var ref = this;\n\t        var view = ref.relatedView;\n\t        var options = ref.options;\n\t        var vel = ref.vel;\n\t        var useModelGeometry = options.useModelGeometry;\n\t        var rotate = options.rotate;\n\t        var padding = normalizeSides(options.padding);\n\t        var bbox = getViewBBox(view, useModelGeometry).moveAndExpand({\n\t            x: -padding.left,\n\t            y: -padding.top,\n\t            width: padding.left + padding.right,\n\t            height: padding.top + padding.bottom\n\t        });\n\t        var model = view.model;\n\t        if (model.isElement()) {\n\t            var angle = model.angle();\n\t            if (angle) {\n\t                if (rotate) {\n\t                    var origin = model.getBBox().center();\n\t                    vel.rotate(angle, origin.x, origin.y, { absolute: true });\n\t                } else {\n\t                    bbox = bbox.bbox(angle);\n\t                }\n\t            }\n\t        }\n\t        vel.attr(bbox.toJSON());\n\t        return this;\n\t    }\n\t});\n\n\tvar Anchor = ToolView.extend({\n\t    tagName: 'g',\n\t    type: null,\n\t    children: [{\n\t        tagName: 'circle',\n\t        selector: 'anchor',\n\t        attributes: {\n\t            'cursor': 'pointer'\n\t        }\n\t    }, {\n\t        tagName: 'rect',\n\t        selector: 'area',\n\t        attributes: {\n\t            'pointer-events': 'none',\n\t            'fill': 'none',\n\t            'stroke': '#33334F',\n\t            'stroke-dasharray': '2,4',\n\t            'rx': 5,\n\t            'ry': 5\n\t        }\n\t    }],\n\t    events: {\n\t        mousedown: 'onPointerDown',\n\t        touchstart: 'onPointerDown',\n\t        dblclick: 'onPointerDblClick'\n\t    },\n\t    documentEvents: {\n\t        mousemove: 'onPointerMove',\n\t        touchmove: 'onPointerMove',\n\t        mouseup: 'onPointerUp',\n\t        touchend: 'onPointerUp',\n\t        touchcancel: 'onPointerUp'\n\t    },\n\t    options: {\n\t        snap: snapAnchor,\n\t        anchor: getAnchor,\n\t        resetAnchor: true,\n\t        customAnchorAttributes: {\n\t            'stroke-width': 4,\n\t            'stroke': '#33334F',\n\t            'fill': '#FFFFFF',\n\t            'r': 5\n\t        },\n\t        defaultAnchorAttributes: {\n\t            'stroke-width': 2,\n\t            'stroke': '#FFFFFF',\n\t            'fill': '#33334F',\n\t            'r': 6\n\t        },\n\t        areaPadding: 6,\n\t        snapRadius: 10,\n\t        restrictArea: true,\n\t        redundancyRemoval: true\n\t    },\n\t    onRender: function() {\n\t        this.renderChildren();\n\t        this.toggleArea(false);\n\t        this.update();\n\t    },\n\t    update: function() {\n\t        var type = this.type;\n\t        var relatedView = this.relatedView;\n\t        var view = relatedView.getEndView(type);\n\t        if (view) {\n\t            this.updateAnchor();\n\t            this.updateArea();\n\t            this.el.style.display = '';\n\t        } else {\n\t            this.el.style.display = 'none';\n\t        }\n\t        return this;\n\t    },\n\t    updateAnchor: function() {\n\t        var childNodes = this.childNodes;\n\t        if (!childNodes) { return; }\n\t        var anchorNode = childNodes.anchor;\n\t        if (!anchorNode) { return; }\n\t        var relatedView = this.relatedView;\n\t        var type = this.type;\n\t        var position = relatedView.getEndAnchor(type);\n\t        var options = this.options;\n\t        var customAnchor = relatedView.model.prop([type, 'anchor']);\n\t        anchorNode.setAttribute('transform', 'translate(' + position.x + ',' + position.y + ')');\n\t        var anchorAttributes = (customAnchor) ? options.customAnchorAttributes : options.defaultAnchorAttributes;\n\t        for (var attrName in anchorAttributes) {\n\t            anchorNode.setAttribute(attrName, anchorAttributes[attrName]);\n\t        }\n\t    },\n\t    updateArea: function() {\n\t        var childNodes = this.childNodes;\n\t        if (!childNodes) { return; }\n\t        var areaNode = childNodes.area;\n\t        if (!areaNode) { return; }\n\t        var relatedView = this.relatedView;\n\t        var type = this.type;\n\t        var view = relatedView.getEndView(type);\n\t        var model = view.model;\n\t        var magnet = relatedView.getEndMagnet(type);\n\t        var padding = this.options.areaPadding;\n\t        if (!isFinite(padding)) { padding = 0; }\n\t        var bbox, angle, center;\n\t        if (view.isNodeConnection(magnet)) {\n\t            bbox = view.getBBox();\n\t            angle = 0;\n\t            center = bbox.center();\n\t        } else {\n\t            bbox = view.getNodeUnrotatedBBox(magnet);\n\t            angle = model.angle();\n\t            center = bbox.center();\n\t            if (angle) { center.rotate(model.getBBox().center(), -angle); }\n\t            // TODO: get the link's magnet rotation into account\n\t        }\n\t        bbox.inflate(padding);\n\t        areaNode.setAttribute('x', -bbox.width / 2);\n\t        areaNode.setAttribute('y', -bbox.height / 2);\n\t        areaNode.setAttribute('width', bbox.width);\n\t        areaNode.setAttribute('height', bbox.height);\n\t        areaNode.setAttribute('transform', 'translate(' + center.x + ',' + center.y + ') rotate(' + angle + ')');\n\t    },\n\t    toggleArea: function(visible) {\n\t        this.childNodes.area.style.display = (visible) ? '' : 'none';\n\t    },\n\t    onPointerDown: function(evt) {\n\t        if (this.guard(evt)) { return; }\n\t        evt.stopPropagation();\n\t        evt.preventDefault();\n\t        this.paper.undelegateEvents();\n\t        this.delegateDocumentEvents();\n\t        this.focus();\n\t        this.toggleArea(this.options.restrictArea);\n\t        this.relatedView.model.startBatch('anchor-move', { ui: true, tool: this.cid });\n\t    },\n\t    resetAnchor: function(anchor) {\n\t        var type = this.type;\n\t        var relatedModel = this.relatedView.model;\n\t        if (anchor) {\n\t            relatedModel.prop([type, 'anchor'], anchor, {\n\t                rewrite: true,\n\t                ui: true,\n\t                tool: this.cid\n\t            });\n\t        } else {\n\t            relatedModel.removeProp([type, 'anchor'], {\n\t                ui: true,\n\t                tool: this.cid\n\t            });\n\t        }\n\t    },\n\t    onPointerMove: function(evt) {\n\n\t        var relatedView = this.relatedView;\n\t        var type = this.type;\n\t        var view = relatedView.getEndView(type);\n\t        var model = view.model;\n\t        var magnet = relatedView.getEndMagnet(type);\n\t        var normalizedEvent = normalizeEvent(evt);\n\t        var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n\t        var snapFn = this.options.snap;\n\t        if (typeof snapFn === 'function') {\n\t            coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);\n\t            coords = new Point(coords);\n\t        }\n\n\t        if (this.options.restrictArea) {\n\t            if (view.isNodeConnection(magnet)) {\n\t                // snap coords to the link's connection\n\t                var pointAtConnection = view.getClosestPoint(coords);\n\t                if (pointAtConnection) { coords = pointAtConnection; }\n\t            } else {\n\t                // snap coords within node bbox\n\t                var bbox = view.getNodeUnrotatedBBox(magnet);\n\t                var angle = model.angle();\n\t                var origin = model.getBBox().center();\n\t                var rotatedCoords = coords.clone().rotate(origin, angle);\n\t                if (!bbox.containsPoint(rotatedCoords)) {\n\t                    coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);\n\t                }\n\t            }\n\t        }\n\n\t        var anchor;\n\t        var anchorFn = this.options.anchor;\n\t        if (typeof anchorFn === 'function') {\n\t            anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);\n\t        }\n\n\t        this.resetAnchor(anchor);\n\t        this.update();\n\t    },\n\n\t    onPointerUp: function(evt) {\n\t        this.paper.delegateEvents();\n\t        this.undelegateDocumentEvents();\n\t        this.blur();\n\t        this.toggleArea(false);\n\t        var linkView = this.relatedView;\n\t        if (this.options.redundancyRemoval) { linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid }); }\n\t        linkView.model.stopBatch('anchor-move', { ui: true, tool: this.cid });\n\t    },\n\n\t    onPointerDblClick: function() {\n\t        var anchor = this.options.resetAnchor;\n\t        if (anchor === false) { return; } // reset anchor disabled\n\t        if (anchor === true) { anchor = null; } // remove the current anchor\n\t        this.resetAnchor(cloneDeep(anchor));\n\t        this.update();\n\t    }\n\t});\n\n\tvar SourceAnchor = Anchor.extend({\n\t    name: 'source-anchor',\n\t    type: 'source'\n\t});\n\n\tvar TargetAnchor = Anchor.extend({\n\t    name: 'target-anchor',\n\t    type: 'target'\n\t});\n\n\tvar index$5 = ({\n\t\tVertices: Vertices,\n\t\tSegments: Segments,\n\t\tSourceArrowhead: SourceArrowhead,\n\t\tTargetArrowhead: TargetArrowhead,\n\t\tSourceAnchor: SourceAnchor,\n\t\tTargetAnchor: TargetAnchor,\n\t\tButton: Button,\n\t\tRemove: Remove,\n\t\tBoundary: Boundary\n\t});\n\n\n\n\tvar index$6 = ({\n\t\tButton: Button,\n\t\tRemove: Remove,\n\t\tBoundary: Boundary\n\t});\n\n\tvar version = \"3.3.1\";\n\n\tvar Vectorizer = V;\n\tvar layout = { PortLabel: PortLabel, Port: Port };\n\tvar setTheme = function(theme, opt) {\n\n\t    opt = opt || {};\n\n\t    invoke(views, 'setTheme', theme, opt);\n\n\t    // Update the default theme on the view prototype.\n\t    View.prototype.defaultTheme = theme;\n\t};\n\n\tvar layout$1 = { DirectedGraph: DirectedGraph, PortLabel: PortLabel, Port: Port };\n\n\t// export empty namespaces - backward compatibility\n\tvar format$1 = {};\n\tvar ui = {};\n\n\texports.V = V;\n\texports.Vectorizer = Vectorizer;\n\texports.anchors = anchors;\n\texports.config = config;\n\texports.connectionPoints = connectionPoints;\n\texports.connectionStrategies = index$4;\n\texports.connectors = connectors;\n\texports.dia = index$2;\n\texports.elementTools = index$6;\n\texports.env = env;\n\texports.format = format$1;\n\texports.g = g;\n\texports.highlighters = highlighters;\n\texports.layout = layout$1;\n\texports.linkAnchors = linkAnchors;\n\texports.linkTools = index$5;\n\texports.mvc = index$1;\n\texports.routers = routers;\n\texports.setTheme = setTheme;\n\texports.shapes = index$3;\n\texports.ui = ui;\n\texports.util = index;\n\texports.version = version;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\nif (typeof joint !== 'undefined') { var g = joint.g, V = joint.V, Vectorizer = joint.V; }\n"],"sourceRoot":"webpack:///"}