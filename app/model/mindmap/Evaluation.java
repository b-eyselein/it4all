package model.mindmap;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;

import model.mindmap.basics.TreeNode;
import model.mindmap.evaluation.ParsingException;
import model.mindmap.evaluation.Properties;
import model.mindmap.evaluation.RWExcel;
import model.mindmap.evaluation.TupelDifferenceContainer;
import model.mindmap.evaluation.Tuple;
import model.mindmap.evaluation.Util;
import model.mindmap.evaluation.enums.ParserType;
import model.mindmap.parser.AbstractEvaluationParser;
import model.mindmap.parser.AbstractParser;
import play.Logger;

public class Evaluation {

  private Evaluation() {

  }

  /**
   * Takes a mindmap in .xml or .xmmap file format and creates a latex .tex TOC
   * file based on the input file.
   *
   * @see {@link #createTOC(String, String, String, String, String)}}
   *
   * @param readPath
   *          input file path
   * @param writePath
   *          output file path
   * @param templatePath
   *          template path
   */
  public static void craeteTOCMMtoLatex(Path readPath, Path writePath, Path templatePath) {
    createTOC(ParserType.MINDMANAGER.getParser(), ParserType.LATEX.getParser(), readPath, writePath, templatePath);
  }

  /**
   * Takes a mindmap in .xml or .xmmap file format and creates a word .docx TOC
   * file based on the input file.
   *
   * @see {@link #createTOC(String, String, String, String, String)}}
   *
   * @param readPath
   *          input file path
   * @param writePath
   *          output file path
   * @param templatePath
   *          template path
   */
  public static void craeteTOCMMtoWord(Path readPath, Path writePath, Path templatePath) {
    createTOC(ParserType.MINDMANAGER.getParser(), ParserType.WORD.getParser(), readPath, writePath, templatePath);
  }

  /**
   * This method creates a table of content file in the specified file format
   * based on the input file and template file.
   *
   * @param readParser
   *          input file format
   * @param writeParser
   *          output file format
   * @param readPath
   *          input file path
   * @param writePath
   *          output file path
   * @param templatePath
   *          template path
   */
  public static void createTOC(AbstractParser readParser, AbstractParser writeParser, Path readPath, Path writePath,
      Path templatePath) {
    try {
      List<TreeNode> listOfRoots = readParser.read(readPath.toFile());
      listOfRoots = Util.mergeTrees(listOfRoots);
      writeParser.write(writePath, listOfRoots, templatePath);
    } catch (ParsingException e) {
      Logger.error("FEHLER: ", e);
    }
  }

  /**
   * This method performs the evaluation of a mindmap from a user in comparison
   * to a solution mindmap. In order to do this, several parameters are needed.
   * At first a specific parser must be chosen (currently only MindManager is
   * supported). The path to the user generated file (input) is needed as well
   * as the path to the sample solution. Further paths to the used template and
   * the meta file are needed. The template defines the look of the altered
   * solution/input files. This method also creates three new files. Two of them
   * are altered versions of the input/solution mindmaps and the third is an
   * naryOverview of the evaluation results. The input and solution mindmaps must be
   * XML or XMMAP. It is critical that the chosen parser type and the template
   * fit together.
   *
   * @param parserType
   *          specifies the parser which will be used (currently only
   *          MindManager is supported)
   * @param input
   *          the path to the mindmap generated by the user
   * @param solution
   *          the path to the mindmap which represents the perfect solution
   * @param result
   *          the path where the result naryOverview will be generated
   * @param alteredSolution
   *          the path where the altered solution will be generated
   * @param alteredInput
   *          the path where the altered input will be generated
   * @param metaData
   *          the path where the meta file is
   * @param template
   *          the path where the template file is
   * @throws Exception
   */
  public static void evaluate(AbstractEvaluationParser abstractEvaluationParser, Path input, Path solution, Path result,
      Path alteredSolution, Path alteredInput, Path metaData, Path template) throws ParsingException, IOException {

    RWExcel rwe = new RWExcel();
    List<TreeNode> inputRoots = abstractEvaluationParser.read(input.toFile());
    List<TreeNode> solutionRoots = abstractEvaluationParser.read(solution.toFile());
    // this must be called before handleMetaData()... //else there might be
    // redundant 'yes' in the meta file.
    Util.applyMetaDataFromSolutionToInput(solutionRoots, inputRoots);
    Properties properties = rwe.readMetaFile(metaData, solutionRoots);
    abstractEvaluationParser.setProperties(properties);
    // ...and after. //this is a must
    Util.applyMetaDataFromSolutionToInput(solutionRoots, inputRoots);
    Map<String, List<Tuple>> mapInput = Util.buildTuples(inputRoots);
    Map<String, List<Tuple>> mapSolutions = Util.buildTuples(solutionRoots);
    TupelDifferenceContainer resultDifferences = Util.getDifferenceTupel(mapSolutions, mapInput);
    Util.applyResultToNodes(solutionRoots, resultDifferences);
    Util.applyResultToNodes(inputRoots, resultDifferences);
    Util.checkIfFeedbackPossible(solutionRoots, inputRoots);
    Util.setRealPoints(solutionRoots);
    Util.setRealPoints(inputRoots);
    rwe.writeEvaluation(result, inputRoots, solutionRoots);
    abstractEvaluationParser.setPathsForAlteredOutputs(result, metaData, alteredInput, alteredSolution);
    abstractEvaluationParser.write(alteredInput, inputRoots, template);
    abstractEvaluationParser.write(alteredSolution, solutionRoots, template);
  }
}
